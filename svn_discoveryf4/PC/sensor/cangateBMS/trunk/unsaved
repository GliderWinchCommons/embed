	while ( (fgets (&buf[0],LINESZ,fpIn)) != NULL)	// Get a line
	{
		sscanf(&buf[ 2],"%8x%c%s",&cantbl[cantblsz].id, &cantbl[cantblsz].tag,&cantbl[cantblsz].c);
		sscanf(&buf[11],"%c",&cantbl[cantblsz].tag);
		sscanf(&buf[12],"%s",&cantbl[cantblsz].c);
		if (buf[0] == '#')
			continue;
		if (cantbl[cantblsz].tag == 'T')
		{
			canTid = cantbl[cantblsz].id; i = 0;
		}
		else if (cantbl[cantblsz].tag == 'S')
		{
			canSid = cantbl[cantblsz].id; i = 0;
		}

		cantblsz += i;
		if (cantblsz > FIELDSZ) 
		{	
			printf("Input table file %s exceeds fields allowed table size (%d)\n",*(argv+1),cantblsz);
			exit(-1);
		}
	}

	printf("CAN ID selection input file list--\n");
	printf("#0x%08X Time/Date CAN id\n",canTid);
	printf("#0x%08X Time sync CAN id\n\n",canSid);

	for (i = 0; i < cantblsz; i++)
	{
		printf("#%2d 0x%08X %c %s\n",i+1,cantbl[i].id,cantbl[i].tag,cantbl[i].c);
	}
	
	/* **********************************************************************************  
	 * Go though input data until all the CAN ids in the selection list have been encountered.  
    *
    * The input data file generated by 'jcancnvt' lists the payload type code.  Use this code
    * To generate a table of comma separated fields, the table index corresponding to the sequence
    * of the selection file, AND duplicate entries where the payload code designates multiple
    * readings in one CAN msg.
    *
    * In this initial readin of the input data, load the first enountered value into the field
    * table entries, to give an initial value for the field for readings that do not report
    * every time sync (1/64th sec).
    *
    * Time sync msg coordination with date/time is done similar to the foregoing readings.  The
    * first time sync zero msgs are counted until the first date/time is encountered.  On the
    * subsequent pass through the data count-to-date-time is subtracted from the first date/time 
    * for date/time assignment to initial time-sync msgs.
	 * **********************************************************************************  */
	// Input data is from stdin

	sync0ct = 0;		// Count time sync with payload zero until 1st time msg
	runningtime = 0;
	int syncnum;	// Time sync payload number
	char* p;

	linect = 0;
	while ( (fgets (&buf[0],LINESZ,stdin)) != NULL)	// Get a line from stdin
	{
		if ((buf[0] == '0') && ((buf[1] == 'x') || (buf[1] == 'X')))
		{ // Here, looks like a good CAN data line
			sscanf(&buf[2],"%x %d",id, &paycode);	// Extract CAN id and payload type code

			// Time/date or time/sync case handling
			if ((canTid == id) || (canSid == id))
			{ 
				if (canTid == id)
				{ // Here, a date/time msg
					p = strchr(&buf[12],'X');
					if (p == NULL)
					{
						printf("#### ARGH: date/time CAN id msg has no 'X' field %s\n",buf);
						exit(-1);
					}
					sscanf((p+2),"%x",&running time);
				}
				else
				{ // Here a time sync msg
					sscanf(&buf[12],"%d",&syncnum);
					// Count 1 sec time sync marks to first time/date msg
					if ((syncnum == 0) && (runningtime == 0))
					{
						sync0ct += 1;
					}
				}
			}
			else
			{ // Not time sync nor date/time; check if CAN id in list
				for (i = 0; i < cantblsz; i++)
				{
					// See if this CAN id is in the selection list
					if (cantbl[i].id == id)
					{ // This CAN id is in the list of fields
						if (field[i].rn == 0)
						{ // Here, no data has been stored 
							field[i].id = id;
							field[i].paycode = paycode;
							field_extract(&field[i],&buf[17]);
						}		
					}
				}
			}
		}
		linect += 1;
	}
	return 0;
}
/* *********************************************************************************
 * void field_extract(struct FIELD* pf, char* pc);
 * @brief	: Handle different field types	
 * @param	: pf = pointer to field table
 * @param	: pc = pointer to input line buffer where readings begin
 * @param	: id = CAN id extracted from 'buf' earlier
 * @param	: paycode = payload type code extracted from 'buf' earlier
 ***********************************************************************************/
void field_extract(struct FIELD* pf, char* pc)
{
	unsigned int i;
	char* p;


	/* Map payload code into number of readings */
	switch (pf->paycode)
	{
		case 2: // FF_FF
					
			break;

		case 23: // U8
			break;						

		default:
			printf("### OH NO! payload type is not in our list: line ct: %d  0x%08x\n",linect, f->id);
			return;
	}





