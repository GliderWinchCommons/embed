/******************************************************************************
* File Name          : cmd_code_dispatch.c
* Date First Issued  : 10/03/2016
* Board              :
* Description        : Dispatch to handler based on command code number
*******************************************************************************/
/*
 payload [0] contains the command code.
 definitions are generated by the database table:
 CMD_CODES_INSERT.sql
*/
#include "cmd_code_dispatch.h"
#include "readings_dispatch.h"
#include "db/gen_db.h"
#include "can_driver.h"

extern struct CAN_CTLBLOCK* pctl0;

/* **************************************************************************************
 * unsigned int cmd_code_dispatch(struct CANRCVBUF* pcan, struct TENSIONFUNCTION* p);
 * @brief	: Handle command code msg
 * @param	: pcan = pointer to command msg received
 * @param	: p = pointer to struct with values for this instance
 * @return	:  0 = OK; AND *pcan setup with return msg
 *		: -1 = code not in table, and pcan->cd.uc[0]
 *		: 255 = dlc less than 1
 *		: 254 = code not in table
 * ************************************************************************************** */
unsigned int cmd_code_dispatch(struct CANRCVBUF* pcan, struct TENSIONFUNCTION* p)
{
	/* Use the response command CANID to the incoming "i" commmand CAN ID. */
	pcan->id = *p->pcanid_cmd_func_r; // "r" = response

	if (pcan->dlc < 1)	// Check payload size
	{ // No payload is bogus
		pcan->cd.uc[0] = 255; pcan->cd.uc[1] = 0; pcan->dlc = 2;
		can_driver_put(pctl0,pcan,4,0);	// Add/send to CAN driver
		return -1;
	}

	switch (pcan->cd.uc[0])
	{
case LDR_SET_ADDR:	// 1,	'5 Set address pointer (not FLASH) (bytes 2-5):  Respond with last written address.');
	break;
case LDR_SET_ADDR_FL: 	// 2,	'5 Set address pointer (FLASH) (bytes 2-5):  Respond with last written address.');
	break;
case LDR_CRC: 		// 3,	'8 Get CRC: 2-4 = count; 5-8 = start address; Reply CRC 2-4 na, 5-8 computed CRC ');
	break;
case LDR_ACK: 		// 4,	'1 ACK: Positive acknowledge (Get next something)');
	break;
case LDR_NACK: 		// 5,	'1 NACK: Negative acknowledge (So? How do we know it is wrong?)');
	break;
case LDR_JMP: 		// 6,	'5 Jump: to address supplied (bytes 2-5)');
	break;
case LDR_WRBLK: 	// 7,	'1 Done with block: write block with whatever you have.');
	break;
case LDR_RESET: 	// 8,	'1 RESET: Execute a software forced RESET');
	break;
case LDR_XON: 		// 9,	'1 Resume sending');
	break;
case LDR_XOFF: 		// 10,	'1 Stop sending');
	break;
case LDR_FLASHSIZE: 	// 11,	'1 Get flash size; bytes 2-3 = flash block size (short)');
	break;
case LDR_ADDR_OOB: 	// 12,	'1 Address is out-of-bounds');
	break;
case LDR_DLC_ERR: 	// 13,	'1 Unexpected DLC');
	break;
case LDR_FIXEDADDR: 	// 14,	'5 Get address of flash with fixed loader info (e.g. unique CAN ID)');
	break;
case LDR_RD4: 		// 15,	'5 Read 4 bytes at address (bytes 2-5)');
	break;
case LDR_APPOFFSET: 	// 16,	'5 Get address where application begins storing.');
	break;
case LDR_HIGHFLASHH: 	// 17,	'5 Get address of beginning of struct with crc check and CAN ID info for app');
	break;
case LDR_HIGHFLASHP: 	// 18,	'8 Get address and size of struct with app calibrations, parameters, etc.');
	break;
case LDR_ASCII_SW: 	// 19,	'2 Switch mode to send printf ASCII in CAN msgs');
	break;
case LDR_ASCII_DAT: 	// 20,	'3-8 [1]=line position;[2]-[8]=ASCII chars');
	break;
case LDR_WRVAL_PTR: 	// 21,	'2-8 Write: 2-8=bytes to be written via address ptr previous set.');
	break;
case LDR_WRVAL_PTR_SIZE:// 22,	'Write data payload size');
	break;
case LDR_WRVAL_AI: 	// 23,	'8 Write: 2=memory area; 3-4=index; 5-8=one 4 byte value');
	break;
case LDR_SQUELCH: 	// 24,	'8 Send squelch sending tick ct: 2-8 count');
	break;
case CMD_GET_IDENT: 	// 30,	'Get parameter using indentification name/number in byte [1]');
	break;
case CMD_PUT_IDENT: 	// 31,	'Put parameter using indentification name/number in byte [1]');
	break;
case CMD_GET_INDEX: 	// 32,	'Get parameter using index name/number in byte [1]');
	break;
case CMD_PUT_INDEX: 	// 33,	'Put parameter using index name/number in byte [1]');
	break;
case CMD_REVERT: 	// 34,	'Revert (re-initialize) working parameters/calibrations/CANIDs back to stored non-volatile values');
	break;
case CMD_SAVE: 		// 35,	'Write current working parameters/calibrations/CANIDs to non-volatile storage');
	break;

case CMD_GET_READING: 	// 36,	'Send a reading for the code specified in byte [1]');
	return readings_dispatch(pcan, p);

case CMD_GET_READING_BRD: // 37,'Send a reading for the code specified in byte [1] for board; common to functions');
	break;

	default: 
		pcan->cd.uc[0] = 254;
		can_driver_put(pctl0,pcan,4,0);	// Add/send to CAN driver
		return -1;
	}
	return 0;
}
