/******************************************************************************
* File Name          : readings_dispatch.c
* Date First Issued  : 10/03/2016
* Board              :
* Description        : Dispatch to handler based on payload [1]
*******************************************************************************/
/*
 payload [1] contains the readings code
 definitions are generated by the database table:
 READINGS_LIST_INSERT.sql  Defines the readings by type of function.

See 'tension_a_functionS.h' for the struct that holds the readings for this
instance of tension_a.
*/
#include "readings_dispatch.h"
#include "db/gen_db.h"
#include "can_driver.h"

extern struct CAN_CTLBLOCK* pctl0;

/* **************************************************************************************
 * unsigned int readings_dispatch(struct CANRCVBUF* pcan, struct TENSIONFUNCTION* p);
 * @brief	: Handle command code msg
 * @param	: pcan = pointer to command msg received
 * @param	: p = pointer to struct with values for this instance
 * @return	: 0 = OK & dlc and payload setup
 * 		: -2 = not in table, and cd.uc[1]--
 *		: 253 = dlc less than 2 (no readings code)
 *		: 252 = code not in table
 * ************************************************************************************** */
unsigned int readings_dispatch(struct CANRCVBUF* pcan, struct TENSIONFUNCTION* p)
{
	union FT
	{
		float f;	// Union needed to use floats as four bytes
		unsigned int i;
		signed int s;
		unsigned char uc[8];
	}ft;

	if (pcan->dlc < 2)
	{
		pcan->cd.uc[1] = 253; pcan->dlc = 2;
		can_driver_put(pctl0,pcan,4,0);	// Add/send to CAN driver
		return -2;
	}

	switch (pcan->cd.uc[1])
	{
case TENSION_READ_FILTADC_THERM1: // , 1, 'TYP_U32' ,'%u', 	 'TENSION_a', 'Tension: READING: double thrm[0]; Filtered ADC for Thermistor on AD7799');
	ft.f = (float)p->thrm[0];  	   break;
case TENSION_READ_FILTADC_THERM2: // , 2, 'TYP_U32' ,'%u',	 'TENSION_a', 'Tension: READING: double thrm[1]; Filtered ADC for Thermistor external');
	ft.f = (float)p->thrm[1];  	   break;
case TENSION_READ_FORMCAL_THERM1: // , 4, 'TYP_FLT' ,'%0.2f', 	 'TENSION_a', 'Tension: READING: double degX[0]; Formula computed thrm for Thermistor on AD7799');
	ft.f = (float)p->degX[0];  	   break;
case TENSION_READ_FORMCAL_THERM2: // , 5, 'TYP_FLT' ,'%0.2f', 	 'TENSION_a', 'Tension: READING: double degX[1]; Formula computed thrm for Thermistor external');
	ft.f = (float)p->degX[1];  	   break;
case TENSION_READ_POLYCAL_THERM1: // , 6, 'TYP_FLT' ,'%0.2f', 	 'TENSION_a', 'Tension: READING: double degC[0]; Polynomial adjusted degX for Thermistor on AD7799');
	ft.f = (float)p->degC[0];  	   break;
case TENSION_READ_POLYCAL_THERM2: // , 7, 'TYP_FLT' ,'%0.2f', 	 'TENSION_a', 'Tension: READING: double degC[1]; Polynomial adjusted degX for Thermistor external');
	ft.f = (float)p->degC[1];  	   break;
case TENSION_READ_AD7799_LGR: 	  // , 8, 'TYP_S32' ,'%u', 	 'TENSION_a', 'Tension: READING: int32_t lgr; last_good_reading (no filtering or adjustments)');
	ft.f = p->fcalib_lgr;	   	   break;
case TENSION_READ_AD7799_CALIB_1: // , 9, 'TYP_FLT' ,'0.3f',  	 'TENSION_a', 'Tension: READING: ten_iircal[0];  AD7799 filtered (fast) and calibrated');
	ft.f = p->ten_iircal[0];   	   break;
case TENSION_READ_AD7799_CALIB_2: // ,10, 'TYP_FLT' ,'0.3f',  	 'TENSION_a', 'Tension: READING: ten_iircal[1];  AD7799 filtered (slow) and calibrated');
	ft.f = p->ten_iircal[1];   	   break;
case TENSION_READ_CIC_RAW: 	  // ,11, 'TYP_U32' ,'%u', 	 'TENSION_a', 'Tension: READING: int32_t cicraw; cic before averaging');
	ft.s = p->cicraw;	   	   break;
case TENSION_READ_CIC_AVE: 	  // ,12, 'TYP_U32' ,'%u', 	 'TENSION_a', 'Tension: READING: int32_t cicave; cic averaged for determining offset');
	ft.s = -1;		   	   break;
case TENSION_READ_CIC_AVE_CT: 	  // ,13, 'TYP_U32' ,'%u', 	 'TENSION_a', 'Tension: READING: int32_t ave.n;  current count for above average');
	ft.s = -1;		   	   break;
case TENSION_READ_OFFSET_REG: 	  // ,14, 'TYP_U32' ,'%u', 	 'TENSION_a', 'Tension: READING: Last reading of AD7799 offset register');
	ft.s = p->offset_reg;	   	   break;
case TENSION_READ_OFFSET_REG_FILT:// ,15, 'TYP_U32' ,'%u', 	 'TENSION_a', 'Tension: READING: Last filtered AD7799 offset register');
	ft.s = p->offset_reg_filt; 	   break;
case TENSION_READ_OFFSET_REG_RDBK:// ,16, 'TYP_U32' ,'%u', 	 'TENSION_a', 'Tension: READING: Last filtered AD7799 offset register set read-back');
	ft.s = p->offset_reg_rdbk; 	   break;
case TENSION_READ_FULLSCALE_REG:  // ,17, 'TYP_U32' ,'%u', 	 'TENSION_a', 'Tension: READING: Last reading of AD7799 fullscale register');
	ft.s = p->fullscale_reg;   	   break;
case TENSION_READ_POLL_MASK: 	  // ,18, 'TYP_U32' ,'%u', 	 'TENSION_a', 'Tension: READING: Mask for first two bytes of a poll msg (necessary?)';
	ft.i = p->poll_mask;	   	   break;
case TENSION_READ_READINGSCT: 	  // ,19, 'TYP_U32' ,'%u', 	 'TENSION_a', 'Tension: READING: Running count of readings (conversions completed)');
	ft.i = p->readingsct;	   	   break;
case TENSION_READ_READINGSCT_LASTPOLL: // ,20, 'TYP_U32' ,'%u',  'TENSION_a', 'Tension: READING: Reading count the last time a poll msg sent');
	ft.i = p->readingsct_lastpoll;     break;
case TENSION_READ_OFFSET_CT: 	  // ,21, 'TYP_U32' ,'%u', 	 'TENSION_a', 'Tension: READING: Running ct of offset updates');
	ft.i = p->offset_ct;	    	   break;
case TENSION_READ_ZERO_FLAG: 	  // ,22, 'TYP_U32' ,'%u', 	 'TENSION_a', 'Tension: READING: 1 = zero-calibration operation competed');
	ft.s = p->zero_flag;	   	   break;
case TENSION_READ_STATUS_BYTE: 	  // ,23, 'TYP_U32' ,'%u', 	 'TENSION_a', 'Tension: READING: Reading status byte');
	ft.uc[0] = p->status_byte;	   break;
case TENSION_READ_IIR_OFFSET_K:   // ,24, 'TYP_U32' ,'%u', 	 'TENSION_a', 'Tension: READING: IIR filter for offsets: parameter for setting time constant');
	ft.i = p->iir_offset.pprm->k;	   break;
case TENSION_READ_IIR_OFFSET_SCL: // ,25, 'TYP_U32' ,'%u', 	 'TENSION_a', 'Tension: READING: IIR filter for offsets: Scaling to improve spare bits with integer math');
	ft.i = p->iir_offset.pprm->scale;  break;
case TENSION_READ_IIR_Z_RECAl_W_K: //',26, 'TYP_U32' ,'%u', 	 'TENSION_a', 'Tension: READING: IIR filter for zeroing: parameter for setting time constant');
	ft.i = p->iir_z_recal_w.pprm->k;   break;
case TENSION_READ_IIR_Z_RECAl_W_SCL: //',27, 'TYP_U32' ,'%u',  	 'TENSION_a', 'Tension: READING: IIR filter for zeroing: Scaling to improve spare bits with integer math');
	ft.i = p->iir_z_recal_w.pprm->scale;	   break;
default:
	pcan->dlc = 2;
	pcan->cd.uc[1] = 252;	// 0Xfc Return--reading code not in table
	can_driver_put(pctl0,pcan,4,0);	// Add/send to CAN driver
	return -3;
	}
	// Set dlc and payload.  can ID, and cd.uc[0], cd.uc[1] remain the same.
	pcan->dlc = 6;
	pcan->cd.uc[2] = (ft.i >>  0) & 0x0ff;
	pcan->cd.uc[3] = (ft.i >>  8) & 0x0ff;
	pcan->cd.uc[4] = (ft.i >> 16) & 0x0ff;
	pcan->cd.uc[5] = (ft.i >> 24) & 0x0ff;
	can_driver_put(pctl0,pcan,4,0);	// Add/send to CAN driver
	return 0;
}

