
ldr:     file format elf32-littlearm


Disassembly of section .flash:

08000000 <vector_table>:
 8000000:	fc 4f 00 20 15 1b 00 08 69 01 00 08 51 01 00 08     .O. ....i...Q...
 8000010:	57 01 00 08 5d 01 00 08 63 01 00 08 00 00 00 00     W...]...c.......
	...
 800002c:	69 01 00 08 69 01 00 08 00 00 00 00 69 01 00 08     i...i.......i...
 800003c:	69 01 00 08 69 01 00 08 69 01 00 08 69 01 00 08     i...i...i...i...
 800004c:	00 00 00 00 69 01 00 08 69 01 00 08 69 01 00 08     ....i...i...i...
 800005c:	69 01 00 08 69 01 00 08 69 01 00 08 69 01 00 08     i...i...i...i...
 800006c:	69 01 00 08 00 00 00 00 69 01 00 08 69 01 00 08     i.......i...i...
 800007c:	00 00 00 00 69 01 00 08 69 01 00 08 69 01 00 08     ....i...i...i...
 800008c:	e9 30 00 08 01 31 00 08 15 31 00 08 69 01 00 08     .0...1...1..i...
 800009c:	69 01 00 08 69 01 00 08 69 01 00 08 69 01 00 08     i...i...i...i...
 80000ac:	69 01 00 08 69 01 00 08 00 00 00 00 69 01 00 08     i...i.......i...
 80000bc:	69 01 00 08 69 01 00 08 69 01 00 08 69 01 00 08     i...i...i...i...
 80000cc:	69 01 00 08 00 00 00 00 dd 1b 00 08 69 01 00 08     i...........i...
 80000dc:	69 01 00 08 69 01 00 08 00 00 00 00 69 01 00 08     i...i.......i...
 80000ec:	69 01 00 08 69 01 00 08 69 01 00 08 69 01 00 08     i...i...i...i...
 80000fc:	69 01 00 08 69 01 00 08 69 01 00 08 69 01 00 08     i...i...i...i...
 800010c:	69 01 00 08 00 00 00 00 00 00 00 00 69 01 00 08     i...........i...
 800011c:	69 01 00 08 69 01 00 08 69 01 00 08 69 01 00 08     i...i...i...i...
 800012c:	00 00 00 00                                         ....

08000130 <unique_can_block>:
extern const void* __appoffset;

__attribute__ ((section(".vectors")))

void unique_can_block(void)
{
 8000130:	b508      	push	{r3, lr}
	Reset_Handler();
 8000132:	f001 fcef 	bl	8001b14 <Reset_Handler>
 8000136:	e7fe      	b.n	8000136 <unique_can_block+0x6>

08000138 <fixedaddress>:
 8000138:	0000 02a0 0003 0000 20e1 0800 0000 0000     ......... ......
	...

08000150 <hard_fault_handler>:
	DMA2CH4_IRQHandler,	//dma2_channel4_5_isr,
};

void hard_fault_handler(void)
{
	panic_leds_pod(1);
 8000150:	2001      	movs	r0, #1
 8000152:	f002 b838 	b.w	80021c6 <panic_leds_pod>

08000156 <mem_manage_handler>:
//	while (1) ;
}
void mem_manage_handler(void)
{
	panic_leds_pod(2);
 8000156:	2002      	movs	r0, #2
 8000158:	f002 b835 	b.w	80021c6 <panic_leds_pod>

0800015c <bus_fault_handler>:
//	while (1) ;
}
void bus_fault_handler(void)
{
	panic_leds_pod(3);
 800015c:	2003      	movs	r0, #3
 800015e:	f002 b832 	b.w	80021c6 <panic_leds_pod>

08000162 <usage_fault_handler>:
//	while (1) ;
}
void usage_fault_handler(void)
{
	panic_leds_pod(4);
 8000162:	2004      	movs	r0, #4
 8000164:	f002 b82f 	b.w	80021c6 <panic_leds_pod>

08000168 <null_handler>:
//	while (1) ;
}

void null_handler(void)
{
	panic_leds_pod(5);
 8000168:	2005      	movs	r0, #5
 800016a:	f002 b82c 	b.w	80021c6 <panic_leds_pod>

0800016e <relocate_vector>:
//	{
//		*pram++ = *pflash++;
//	}
	
	/* Disable all interrupts */
	NVIC_ICER(0) = -1;
 800016e:	4a05      	ldr	r2, [pc, #20]	; (8000184 <relocate_vector+0x16>)
 8000170:	f04f 33ff 	mov.w	r3, #4294967295
 8000174:	6013      	str	r3, [r2, #0]
	NVIC_ICER(1) = -1;
 8000176:	6053      	str	r3, [r2, #4]
	NVIC_ICER(2) = -1;
 8000178:	6093      	str	r3, [r2, #8]

	/* Reset stack pointer */
	
	/* Move vector to beginning of sram*/
//	SCB_VTOR  = (1<<29);
	SCB_VTOR = (unsigned int)vector_table;
 800017a:	4b03      	ldr	r3, [pc, #12]	; (8000188 <relocate_vector+0x1a>)
 800017c:	4a03      	ldr	r2, [pc, #12]	; (800018c <relocate_vector+0x1e>)
 800017e:	601a      	str	r2, [r3, #0]
 8000180:	4770      	bx	lr
 8000182:	bf00      	nop
 8000184:	e000e180 	.word	0xe000e180
 8000188:	e000ed08 	.word	0xe000ed08
 800018c:	08000000 	.word	0x08000000

08000190 <putc>:
// Note: the compiler will give a warning about conflicting types
// for the built in function 'putc'.  Use ' -fno-builtin-putc' to eliminate compile warning.
void putc ( void* p, char c)
	{
		p=p;	// Get rid of the unused variable compiler warning
		USART1_txint_putc(c);
 8000190:	4608      	mov	r0, r1
 8000192:	f001 bd59 	b.w	8001c48 <USART1_txint_putc>

08000196 <system_reset>:
      This bit reads as 0.
      0: No system reset request
      1: Asserts a signal to the outer system that requests a reset.
*/
//	SCB_AIRCR = (0x5FA << 16) | SCB_AIRCR_SYSRESETREQ;	// Cause a RESET
	SCB_AIRCR = (0x5FA << 16) | 0x4;	// Cause a RESET
 8000196:	4a02      	ldr	r2, [pc, #8]	; (80001a0 <system_reset+0xa>)
 8000198:	4b02      	ldr	r3, [pc, #8]	; (80001a4 <system_reset+0xe>)
 800019a:	601a      	str	r2, [r3, #0]
 800019c:	e7fe      	b.n	800019c <system_reset+0x6>
 800019e:	bf00      	nop
 80001a0:	05fa0004 	.word	0x05fa0004
 80001a4:	e000ed0c 	.word	0xe000ed0c

080001a8 <toggle_1led>:
5 green   ADC1   black    0   LED5
6 yellow  ADC1   white    1   LED6
  --------------------------------------*/
void toggle_1led(int led)
{
	if ((GPIO_ODR(GPIOE) & (1<<led)) == 0)
 80001a8:	4b06      	ldr	r3, [pc, #24]	; (80001c4 <toggle_1led+0x1c>)
 80001aa:	681a      	ldr	r2, [r3, #0]
 80001ac:	2301      	movs	r3, #1
 80001ae:	fa03 f000 	lsl.w	r0, r3, r0
 80001b2:	4202      	tst	r2, r0
	{ // Here, LED bit was off
		GPIO_BSRR(GPIOE) = (1<<led);	// Set bits = all four LEDs off
 80001b4:	bf0d      	iteet	eq
 80001b6:	4b04      	ldreq	r3, [pc, #16]	; (80001c8 <toggle_1led+0x20>)
	}
	else
	{ // HEre, LED bit was on
		GPIO_BRR(GPIOE) = (1<<led);	// Reset bits = all four LEDs on
 80001b8:	4b04      	ldrne	r3, [pc, #16]	; (80001cc <toggle_1led+0x24>)
 80001ba:	b280      	uxthne	r0, r0
  --------------------------------------*/
void toggle_1led(int led)
{
	if ((GPIO_ODR(GPIOE) & (1<<led)) == 0)
	{ // Here, LED bit was off
		GPIO_BSRR(GPIOE) = (1<<led);	// Set bits = all four LEDs off
 80001bc:	6018      	streq	r0, [r3, #0]
	}
	else
	{ // HEre, LED bit was on
		GPIO_BRR(GPIOE) = (1<<led);	// Reset bits = all four LEDs on
 80001be:	bf18      	it	ne
 80001c0:	8018      	strhne	r0, [r3, #0]
 80001c2:	4770      	bx	lr
 80001c4:	4001180c 	.word	0x4001180c
 80001c8:	40011810 	.word	0x40011810
 80001cc:	40011814 	.word	0x40011814

080001d0 <main>:

/*#################################################################################################
And now for the main routine 
  #################################################################################################*/
int main(void)
{
 80001d0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u32 j;
//	struct TWO32 canid
	u32 flashblocksize1;
/* --------------------- Type of RESET detection and dispatch ------------------------------------- */
	/* Check type of RESET and set us on the correct journey. */
	u32 rcc_csr = RCC_CSR;	// Get reset flags
 80001d4:	4c7e      	ldr	r4, [pc, #504]	; (80003d0 <main+0x200>)
 80001d6:	6822      	ldr	r2, [r4, #0]
	RCC_CSR |= (1 << 24);	// Clear flags in RCC_CSR (prep for next RESET)
 80001d8:	6823      	ldr	r3, [r4, #0]
	if (rcc_csr & (1 << 29))	// Was it Independent watchdog reset flag?
 80001da:	0092      	lsls	r2, r2, #2
//	struct TWO32 canid
	u32 flashblocksize1;
/* --------------------- Type of RESET detection and dispatch ------------------------------------- */
	/* Check type of RESET and set us on the correct journey. */
	u32 rcc_csr = RCC_CSR;	// Get reset flags
	RCC_CSR |= (1 << 24);	// Clear flags in RCC_CSR (prep for next RESET)
 80001dc:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80001e0:	6023      	str	r3, [r4, #0]
	if (rcc_csr & (1 << 29))	// Was it Independent watchdog reset flag?
 80001e2:	d502      	bpl.n	80001ea <main+0x1a>
	{ // Here, yes.
		/* Jump to the application. */
//		(*(  (void (**)(void))APPJUMP)  )();	// Indirect via address common_can.h
		(*(  (void (*)(void))__appjump)  )();	// Indirect via label in .ld file (better)
 80001e4:	4b7b      	ldr	r3, [pc, #492]	; (80003d4 <main+0x204>)
 80001e6:	681b      	ldr	r3, [r3, #0]
 80001e8:	4798      	blx	r3
	}
	/* Here, not the IWDG flag, so printf some stuff and wait for possible download, before app jump. */

/* --------------------- Begin setting things up -------------------------------------------------- */ 
	// Start system clocks using parameters matching CAN setup parameters for F103 boards
	clockspecifysetup(canwinch_setup_F103_pod_clocks() );
 80001ea:	f001 ffb3 	bl	8002154 <canwinch_setup_F103_pod_clocks>
 80001ee:	f001 fa3f 	bl	8001670 <clockspecifysetup>
/* ---------------------- Set up pins ------------------------------------------------------------- */
	PODgpiopins_default();	// Set gpio port register bits for low power
 80001f2:	f002 fa39 	bl	8002668 <PODgpiopins_default>
	PODgpiopins_Config();	// Now, configure pins
 80001f6:	f002 f9b9 	bl	800256c <PODgpiopins_Config>
	MAX3232SW_on;		// Turn on RS-232 level converter (if doesn't work--no RS-232 chars seen)
 80001fa:	4b77      	ldr	r3, [pc, #476]	; (80003d8 <main+0x208>)
 80001fc:	2280      	movs	r2, #128	; 0x80
 80001fe:	801a      	strh	r2, [r3, #0]
/* ---------------------- Set up 32b DTW system counter ------------------------------------------- */
	DTW_counter_init();
 8000200:	f001 fb02 	bl	8001808 <DTW_counter_init>
		rx line buffer size, (long enough for the longest line)
		number of rx line buffers, (must be > 1)
		tx line buffer size, (long enough for the longest line)
		number of tx line buffers, (must be > 1)
*/
	USART1_rxinttxint_init(115200,96,4,96,4); // Initialize USART and setup control blocks and pointers
 8000204:	2204      	movs	r2, #4
 8000206:	2360      	movs	r3, #96	; 0x60
 8000208:	9200      	str	r2, [sp, #0]
 800020a:	4619      	mov	r1, r3
 800020c:	f44f 30e1 	mov.w	r0, #115200	; 0x1c200
 8000210:	f001 fca0 	bl	8001b54 <USART1_rxinttxint_init>

	/* Announce who we are */
	USART1_txint_puts("\r\n\n\n #### ../LDRFIXEDPOD/TRUNK/LDR #### 03/29/2018 v0 \n\r");
 8000214:	4871      	ldr	r0, [pc, #452]	; (80003dc <main+0x20c>)
 8000216:	f001 fd33 	bl	8001c80 <USART1_txint_puts>

	USART1_txint_send();	// Start the line buffer sending
 800021a:	f001 fd47 	bl	8001cac <USART1_txint_send>

	/* Display things for to entertain the hapless op */
	init_printf(0,putc);	// This one-time initialization is needed by the tiny printf routine
 800021e:	4970      	ldr	r1, [pc, #448]	; (80003e0 <main+0x210>)
 8000220:	2000      	movs	r0, #0
 8000222:	f001 fc49 	bl	8001ab8 <init_printf>

	printf ("  hclk_freq (MHz) : %9u\n\r",  hclk_freq/1000000);	
 8000226:	4b6f      	ldr	r3, [pc, #444]	; (80003e4 <main+0x214>)
 8000228:	4d6f      	ldr	r5, [pc, #444]	; (80003e8 <main+0x218>)
 800022a:	6819      	ldr	r1, [r3, #0]
 800022c:	486f      	ldr	r0, [pc, #444]	; (80003ec <main+0x21c>)
 800022e:	fbb1 f1f5 	udiv	r1, r1, r5
 8000232:	f001 fc47 	bl	8001ac4 <tfp_printf>
	printf (" pclk1_freq (MHz) : %9u\n\r", pclk1_freq/1000000);	USART1_txint_send();
 8000236:	4b6e      	ldr	r3, [pc, #440]	; (80003f0 <main+0x220>)
 8000238:	486e      	ldr	r0, [pc, #440]	; (80003f4 <main+0x224>)
 800023a:	6819      	ldr	r1, [r3, #0]
	printf (" pclk2_freq (MHz) : %9u\n\r", pclk2_freq/1000000);	
	printf ("sysclk_freq (MHz) : %9u\n\r",sysclk_freq/1000000);
 800023c:	4e6e      	ldr	r6, [pc, #440]	; (80003f8 <main+0x228>)

	/* Display things for to entertain the hapless op */
	init_printf(0,putc);	// This one-time initialization is needed by the tiny printf routine

	printf ("  hclk_freq (MHz) : %9u\n\r",  hclk_freq/1000000);	
	printf (" pclk1_freq (MHz) : %9u\n\r", pclk1_freq/1000000);	USART1_txint_send();
 800023e:	fbb1 f1f5 	udiv	r1, r1, r5
 8000242:	f001 fc3f 	bl	8001ac4 <tfp_printf>
 8000246:	f001 fd31 	bl	8001cac <USART1_txint_send>
	printf (" pclk2_freq (MHz) : %9u\n\r", pclk2_freq/1000000);	
 800024a:	4b6c      	ldr	r3, [pc, #432]	; (80003fc <main+0x22c>)
 800024c:	486c      	ldr	r0, [pc, #432]	; (8000400 <main+0x230>)
 800024e:	6819      	ldr	r1, [r3, #0]
/* --------------------- CAN setup ------------------------------------------------------------------- */
	/* Configure CAN criver RS pin: Sensor RxT6 board = (PB 7) */
	can_nxp_setRS(0,1); // (1st arg) 0 = high speed mode; not-zero = standby mode

	/* Initialize CAN for POD board (F103) and get control block */
	pctl1 = canwinch_setup_F103_pod(&msginit,IAMUNITNUMBER);
 8000250:	f8df 8200 	ldr.w	r8, [pc, #512]	; 8000454 <main+0x284>
	/* Display things for to entertain the hapless op */
	init_printf(0,putc);	// This one-time initialization is needed by the tiny printf routine

	printf ("  hclk_freq (MHz) : %9u\n\r",  hclk_freq/1000000);	
	printf (" pclk1_freq (MHz) : %9u\n\r", pclk1_freq/1000000);	USART1_txint_send();
	printf (" pclk2_freq (MHz) : %9u\n\r", pclk2_freq/1000000);	
 8000254:	fbb1 f1f5 	udiv	r1, r1, r5
 8000258:	f001 fc34 	bl	8001ac4 <tfp_printf>
	printf ("sysclk_freq (MHz) : %9u\n\r",sysclk_freq/1000000);
 800025c:	6831      	ldr	r1, [r6, #0]
 800025e:	4869      	ldr	r0, [pc, #420]	; (8000404 <main+0x234>)
 8000260:	fbb1 f1f5 	udiv	r1, r1, r5
 8000264:	f001 fc2e 	bl	8001ac4 <tfp_printf>

	printf ("\n\rControl/status register (RCC_CSR) : %08x\n\r",RCC_CSR);
 8000268:	6821      	ldr	r1, [r4, #0]
 800026a:	4867      	ldr	r0, [pc, #412]	; (8000408 <main+0x238>)
 800026c:	f001 fc2a 	bl	8001ac4 <tfp_printf>
	RCC_CSR |= (1 << 24);
 8000270:	6823      	ldr	r3, [r4, #0]
	printf ("Control/status register (RCC_CSR) : %08x After RMVF written\n\r\n",RCC_CSR);
 8000272:	4866      	ldr	r0, [pc, #408]	; (800040c <main+0x23c>)
	printf (" pclk1_freq (MHz) : %9u\n\r", pclk1_freq/1000000);	USART1_txint_send();
	printf (" pclk2_freq (MHz) : %9u\n\r", pclk2_freq/1000000);	
	printf ("sysclk_freq (MHz) : %9u\n\r",sysclk_freq/1000000);

	printf ("\n\rControl/status register (RCC_CSR) : %08x\n\r",RCC_CSR);
	RCC_CSR |= (1 << 24);
 8000274:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8000278:	6023      	str	r3, [r4, #0]
	printf ("Control/status register (RCC_CSR) : %08x After RMVF written\n\r\n",RCC_CSR);
 800027a:	6821      	ldr	r1, [r4, #0]
 800027c:	f001 fc22 	bl	8001ac4 <tfp_printf>
	RCC_CSR |= (7 << 29);
 8000280:	6823      	ldr	r3, [r4, #0]
	printf ("Control/status register (RCC_CSR) : %08x After LPWR written\n\r\n",RCC_CSR);
 8000282:	4863      	ldr	r0, [pc, #396]	; (8000410 <main+0x240>)
	printf ("sysclk_freq (MHz) : %9u\n\r",sysclk_freq/1000000);

	printf ("\n\rControl/status register (RCC_CSR) : %08x\n\r",RCC_CSR);
	RCC_CSR |= (1 << 24);
	printf ("Control/status register (RCC_CSR) : %08x After RMVF written\n\r\n",RCC_CSR);
	RCC_CSR |= (7 << 29);
 8000284:	f043 4360 	orr.w	r3, r3, #3758096384	; 0xe0000000
 8000288:	6023      	str	r3, [r4, #0]
	printf ("Control/status register (RCC_CSR) : %08x After LPWR written\n\r\n",RCC_CSR);
 800028a:	6821      	ldr	r1, [r4, #0]
 800028c:	f001 fc1a 	bl	8001ac4 <tfp_printf>
/* --------------------- CAN setup ------------------------------------------------------------------- */
	/* Configure CAN criver RS pin: Sensor RxT6 board = (PB 7) */
	can_nxp_setRS(0,1); // (1st arg) 0 = high speed mode; not-zero = standby mode
 8000290:	2101      	movs	r1, #1
 8000292:	2000      	movs	r0, #0
 8000294:	f001 ff38 	bl	8002108 <can_nxp_setRS>

	/* Initialize CAN for POD board (F103) and get control block */
	pctl1 = canwinch_setup_F103_pod(&msginit,IAMUNITNUMBER);
 8000298:	f04f 7128 	mov.w	r1, #44040192	; 0x2a00000
 800029c:	485d      	ldr	r0, [pc, #372]	; (8000414 <main+0x244>)
 800029e:	f001 ff5d 	bl	800215c <canwinch_setup_F103_pod>
 80002a2:	f8c8 0000 	str.w	r0, [r8]

	/* Check if initialization was successful. */
	if (pctl1 == NULL)
 80002a6:	b928      	cbnz	r0, 80002b4 <main+0xe4>
	{
		printf("CAN1 init failed: NULL ptr\n\r");USART1_txint_send(); 
 80002a8:	485b      	ldr	r0, [pc, #364]	; (8000418 <main+0x248>)
 80002aa:	f001 fc0b 	bl	8001ac4 <tfp_printf>
 80002ae:	f001 fcfd 	bl	8001cac <USART1_txint_send>
 80002b2:	e7fe      	b.n	80002b2 <main+0xe2>
		while (1==1);
	}
	if (pctl1->ret < 0)
 80002b4:	f990 109c 	ldrsb.w	r1, [r0, #156]	; 0x9c
 80002b8:	2900      	cmp	r1, #0
 80002ba:	da05      	bge.n	80002c8 <main+0xf8>
	{
		printf("CAN init failed: return code = %d\n\r",pctl1->ret);USART1_txint_send(); 
 80002bc:	4857      	ldr	r0, [pc, #348]	; (800041c <main+0x24c>)
 80002be:	f001 fc01 	bl	8001ac4 <tfp_printf>
 80002c2:	f001 fcf3 	bl	8001cac <USART1_txint_send>
 80002c6:	e7fe      	b.n	80002c6 <main+0xf6>
		while (1==1);
	}
/* ----------------------- Header for columns of CAN error printf ------------------------------------- */
//canwinch_pod_common_systick2048_printerr_header();
/* ---------------- When CAN interrupts are enabled reception of msgs begins! ------------------------ */
	can_msg_reset_init(pctl1, IAMUNITNUMBER);	// Specify CAN ID for this unit for msg caused RESET
 80002c8:	f04f 7128 	mov.w	r1, #44040192	; 0x2a00000
 80002cc:	f003 f9a2 	bl	8003614 <can_msg_reset_init>

// RX msgs begin immediately following enabling CAN interrupts.  Get 'peek' 'toss' of RX msgs going soon.
	can_driver_enable_interrupts();	// Enable CAN interrupts
 80002d0:	f002 fca0 	bl	8002c14 <can_driver_enable_interrupts>
/* -------------- Get the program loader stuff setup -------------------------------------- */
	canwinch_ldrproto_init(IAMUNITNUMBER);
 80002d4:	f04f 7028 	mov.w	r0, #44040192	; 0x2a00000
 80002d8:	f000 f9f0 	bl	80006bc <canwinch_ldrproto_init>
printf(  "BOARD_TYP : %08X\n\r", pfixedaddress->board_typ); 	USART1_txint_send();
printf(  "rc_crc32  : %08X\n\r", (u32)pfixedaddress->func1);
printf(  "MY CAN ID : %08X\n\r", IAMUNITNUMBER);	
*/
// Right justify to show unit number (based on a basic 11 bit CAN id, though 29 bit might be used 
printf(  "  i.e. unit#: %d\n\r", IAMUNITNUMBER); USART1_txint_send();
 80002dc:	f04f 7128 	mov.w	r1, #44040192	; 0x2a00000
 80002e0:	484f      	ldr	r0, [pc, #316]	; (8000420 <main+0x250>)
 80002e2:	f001 fbef 	bl	8001ac4 <tfp_printf>
 80002e6:	f001 fce1 	bl	8001cac <USART1_txint_send>

	flashblocksize1 = (*(u16*)(0x1FFFF7E0)); // Get size of flash in Kbytes
 80002ea:	4b4e      	ldr	r3, [pc, #312]	; (8000424 <main+0x254>)

printf(  "FLASH SIZE: %d\n\r",flashblocksize1);USART1_txint_send();


	u32* pcrcblk = (u32*)((u32)((u8*)*&__appjump + 7 + 0));	// First table entry = number of crcblocks	
	printf(  "(u32)*pcrcblk: %08X\n\r", (u32)*pcrcblk++ );	USART1_txint_send();
 80002ec:	4f39      	ldr	r7, [pc, #228]	; (80003d4 <main+0x204>)
*/
// Right justify to show unit number (based on a basic 11 bit CAN id, though 29 bit might be used 
printf(  "  i.e. unit#: %d\n\r", IAMUNITNUMBER); USART1_txint_send();

	flashblocksize1 = (*(u16*)(0x1FFFF7E0)); // Get size of flash in Kbytes
	if (flashblocksize1 > 256) 
 80002ee:	881b      	ldrh	r3, [r3, #0]
		flashblocksize1 = 2048;	// XL series flash block size
	else
		flashblocksize1 = 1024;	// Med, and High series flash block size

printf(  "FLASH SIZE: %d\n\r",flashblocksize1);USART1_txint_send();
 80002f0:	484d      	ldr	r0, [pc, #308]	; (8000428 <main+0x258>)
// Right justify to show unit number (based on a basic 11 bit CAN id, though 29 bit might be used 
printf(  "  i.e. unit#: %d\n\r", IAMUNITNUMBER); USART1_txint_send();

	flashblocksize1 = (*(u16*)(0x1FFFF7E0)); // Get size of flash in Kbytes
	if (flashblocksize1 > 256) 
		flashblocksize1 = 2048;	// XL series flash block size
 80002f2:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
	else
		flashblocksize1 = 1024;	// Med, and High series flash block size

printf(  "FLASH SIZE: %d\n\r",flashblocksize1);USART1_txint_send();
 80002f6:	bf94      	ite	ls
 80002f8:	f44f 6180 	movls.w	r1, #1024	; 0x400
 80002fc:	f44f 6100 	movhi.w	r1, #2048	; 0x800
 8000300:	f001 fbe0 	bl	8001ac4 <tfp_printf>
 8000304:	f001 fcd2 	bl	8001cac <USART1_txint_send>


	u32* pcrcblk = (u32*)((u32)((u8*)*&__appjump + 7 + 0));	// First table entry = number of crcblocks	
	printf(  "(u32)*pcrcblk: %08X\n\r", (u32)*pcrcblk++ );	USART1_txint_send();
 8000308:	683b      	ldr	r3, [r7, #0]
 800030a:	4848      	ldr	r0, [pc, #288]	; (800042c <main+0x25c>)
 800030c:	f8d3 1007 	ldr.w	r1, [r3, #7]

	u32 flashincrement = sysclk_freq/6;

	// for debug multipy the increment to give the hapless Op time to think
	u32 can_waitdelay_ct = (DTWTIME + 5*sysclk_freq); // Set number secs to wait before jumping to app
 8000310:	4d47      	ldr	r5, [pc, #284]	; (8000430 <main+0x260>)

printf(  "FLASH SIZE: %d\n\r",flashblocksize1);USART1_txint_send();


	u32* pcrcblk = (u32*)((u32)((u8*)*&__appjump + 7 + 0));	// First table entry = number of crcblocks	
	printf(  "(u32)*pcrcblk: %08X\n\r", (u32)*pcrcblk++ );	USART1_txint_send();
 8000312:	f001 fbd7 	bl	8001ac4 <tfp_printf>
 8000316:	f001 fcc9 	bl	8001cac <USART1_txint_send>

	u32 flashincrement = sysclk_freq/6;
 800031a:	6833      	ldr	r3, [r6, #0]

	// for debug multipy the increment to give the hapless Op time to think
	u32 can_waitdelay_ct = (DTWTIME + 5*sysclk_freq); // Set number secs to wait before jumping to app
 800031c:	682a      	ldr	r2, [r5, #0]


	u32* pcrcblk = (u32*)((u32)((u8*)*&__appjump + 7 + 0));	// First table entry = number of crcblocks	
	printf(  "(u32)*pcrcblk: %08X\n\r", (u32)*pcrcblk++ );	USART1_txint_send();

	u32 flashincrement = sysclk_freq/6;
 800031e:	f04f 0906 	mov.w	r9, #6
 8000322:	fbb3 f9f9 	udiv	r9, r3, r9

	// for debug multipy the increment to give the hapless Op time to think
	u32 can_waitdelay_ct = (DTWTIME + 5*sysclk_freq); // Set number secs to wait before jumping to app
 8000326:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800032a:	eb03 0a02 	add.w	sl, r3, r2
/* --------------------- Endless Stuff ----------------------------------------------- */

	/* If PC is listening this will tell it that unit is running the loader program. */
//int i; for (i = 0; i < 10; i++)
	can_driver_put(pctl1, (struct CANRCVBUF*)&can_ldr_ready, 8, 0); // Send msg that ldr is running
 800032e:	f8d8 0000 	ldr.w	r0, [r8]
 8000332:	2300      	movs	r3, #0
 8000334:	2208      	movs	r2, #8
 8000336:	493f      	ldr	r1, [pc, #252]	; (8000434 <main+0x264>)
 8000338:	f002 fca0 	bl	8002c7c <can_driver_put>

	ldr_phase = 0;	// /Switch to prevent jumping to app once loading starts
 800033c:	4b3e      	ldr	r3, [pc, #248]	; (8000438 <main+0x268>)
 800033e:	2200      	movs	r2, #0
 8000340:	469b      	mov	fp, r3
 8000342:	601a      	str	r2, [r3, #0]

	u32 dwt = (DTWTIME + flashincrement); // DWT_CYCNT
 8000344:	682a      	ldr	r2, [r5, #0]
 8000346:	eb09 0802 	add.w	r8, r9, r2
	while (1==1)
	{
		/* Wait for time to expire. */
		if (  ( (int)dwt - (int)(DTWTIME)) < 0 )
 800034a:	682b      	ldr	r3, [r5, #0]
 800034c:	ebc3 0308 	rsb	r3, r3, r8
 8000350:	2b00      	cmp	r3, #0
 8000352:	da03      	bge.n	800035c <main+0x18c>
		{
			dwt += flashincrement;	// Set next LED toggle time
			toggle_1led(LEDGREEN1);
 8000354:	2003      	movs	r0, #3
	while (1==1)
	{
		/* Wait for time to expire. */
		if (  ( (int)dwt - (int)(DTWTIME)) < 0 )
		{
			dwt += flashincrement;	// Set next LED toggle time
 8000356:	44c8      	add	r8, r9
			toggle_1led(LEDGREEN1);
 8000358:	f7ff ff26 	bl	80001a8 <toggle_1led>
		}

		/* Do loader'ing, if there are applicable msgs. */
		canwinch_ldrproto_poll();
 800035c:	f000 fd1e 	bl	8000d9c <canwinch_ldrproto_poll>

		/* Have we written to flash?  If so, don't jump to the the app unless commanded. */
		if (ldr_phase == 0)
 8000360:	f8db 3000 	ldr.w	r3, [fp]
 8000364:	2b00      	cmp	r3, #0
 8000366:	d1f0      	bne.n	800034a <main+0x17a>
		{ // Here, we haven't done anything to disturb the integrity of the app
			if (  ((int)can_waitdelay_ct - (int)(DTWTIME)) < 0 )
 8000368:	682b      	ldr	r3, [r5, #0]
 800036a:	ebc3 030a 	rsb	r3, r3, sl
 800036e:	2b00      	cmp	r3, #0
 8000370:	daeb      	bge.n	800034a <main+0x17a>
			{ // We timed out.
				if (((u32)&__appjump > (u32)__appjump) || ((u32)__appjump > (u32)0x08040000))
 8000372:	683a      	ldr	r2, [r7, #0]
 8000374:	42ba      	cmp	r2, r7
 8000376:	d302      	bcc.n	800037e <main+0x1ae>
 8000378:	4b30      	ldr	r3, [pc, #192]	; (800043c <main+0x26c>)
 800037a:	429a      	cmp	r2, r3
 800037c:	d911      	bls.n	80003a2 <main+0x1d2>
				{ // Here, jump address is bogus
					printf("\n\r\n#### At offset %08X address %08X is bogus ####\n\r\n",(u32)&__appjump, __appjump);
 800037e:	4915      	ldr	r1, [pc, #84]	; (80003d4 <main+0x204>)
 8000380:	482f      	ldr	r0, [pc, #188]	; (8000440 <main+0x270>)
 8000382:	f001 fb9f 	bl	8001ac4 <tfp_printf>
					USART1_txint_send();
 8000386:	f001 fc91 	bl	8001cac <USART1_txint_send>
					dwt = (DTWTIME + sysclk_freq/2);
 800038a:	682b      	ldr	r3, [r5, #0]
 800038c:	6832      	ldr	r2, [r6, #0]
 800038e:	eb03 0252 	add.w	r2, r3, r2, lsr #1
					while (  ((int)dwt - (int)(DTWTIME)) > 0 );
 8000392:	682b      	ldr	r3, [r5, #0]
 8000394:	1ad3      	subs	r3, r2, r3
 8000396:	2b00      	cmp	r3, #0
 8000398:	dcfb      	bgt.n	8000392 <main+0x1c2>
      This bit reads as 0.
      0: No system reset request
      1: Asserts a signal to the outer system that requests a reset.
*/
//	SCB_AIRCR = (0x5FA << 16) | SCB_AIRCR_SYSRESETREQ;	// Cause a RESET
	SCB_AIRCR = (0x5FA << 16) | 0x4;	// Cause a RESET
 800039a:	4a2a      	ldr	r2, [pc, #168]	; (8000444 <main+0x274>)
 800039c:	4b2a      	ldr	r3, [pc, #168]	; (8000448 <main+0x278>)
 800039e:	601a      	str	r2, [r3, #0]
 80003a0:	e7fe      	b.n	80003a0 <main+0x1d0>
					dwt = (DTWTIME + sysclk_freq/2);
					while (  ((int)dwt - (int)(DTWTIME)) > 0 );
					system_reset();	// Software reset
				}
				/* Set Indpendent Watch Dog and let it cause a reset. */
				RCC_CSR |= (1<<0);			// LSI enable, necessary for IWDG
 80003a2:	6823      	ldr	r3, [r4, #0]
 80003a4:	f043 0301 	orr.w	r3, r3, #1
 80003a8:	6023      	str	r3, [r4, #0]
				while ((RCC_CSR & (1<<1)) == 0);	// wait till LSI is ready
 80003aa:	6823      	ldr	r3, [r4, #0]
 80003ac:	079b      	lsls	r3, r3, #30
 80003ae:	d5fc      	bpl.n	80003aa <main+0x1da>
  				IWDG_KR  = 0x5555;			// enable write to PR, RLR
 80003b0:	f245 5255 	movw	r2, #21845	; 0x5555
 80003b4:	4b25      	ldr	r3, [pc, #148]	; (800044c <main+0x27c>)
  				IWDG_PR  = 0;				// Init prescaler
 80003b6:	2100      	movs	r1, #0
					system_reset();	// Software reset
				}
				/* Set Indpendent Watch Dog and let it cause a reset. */
				RCC_CSR |= (1<<0);			// LSI enable, necessary for IWDG
				while ((RCC_CSR & (1<<1)) == 0);	// wait till LSI is ready
  				IWDG_KR  = 0x5555;			// enable write to PR, RLR
 80003b8:	601a      	str	r2, [r3, #0]
  				IWDG_PR  = 0;				// Init prescaler
 80003ba:	4a25      	ldr	r2, [pc, #148]	; (8000450 <main+0x280>)
 80003bc:	6011      	str	r1, [r2, #0]
  				IWDG_RLR = 0x02;			// Init RLR
 80003be:	2102      	movs	r1, #2
 80003c0:	6051      	str	r1, [r2, #4]
  				IWDG_KR  = 0xAAAA;			// Reload the watchdog
 80003c2:	f64a 22aa 	movw	r2, #43690	; 0xaaaa
 80003c6:	601a      	str	r2, [r3, #0]
  				IWDG_KR  = 0xCCCC;			// Start the watchdog
 80003c8:	f64c 42cc 	movw	r2, #52428	; 0xcccc
 80003cc:	601a      	str	r2, [r3, #0]
 80003ce:	e7fe      	b.n	80003ce <main+0x1fe>
 80003d0:	40021024 	.word	0x40021024
 80003d4:	08005004 	.word	0x08005004
 80003d8:	40011414 	.word	0x40011414
 80003dc:	08003734 	.word	0x08003734
 80003e0:	08000191 	.word	0x08000191
 80003e4:	200010e0 	.word	0x200010e0
 80003e8:	000f4240 	.word	0x000f4240
 80003ec:	0800376d 	.word	0x0800376d
 80003f0:	200010dc 	.word	0x200010dc
 80003f4:	08003787 	.word	0x08003787
 80003f8:	200010d4 	.word	0x200010d4
 80003fc:	200010d8 	.word	0x200010d8
 8000400:	080037a1 	.word	0x080037a1
 8000404:	080037bb 	.word	0x080037bb
 8000408:	080037d5 	.word	0x080037d5
 800040c:	08003802 	.word	0x08003802
 8000410:	08003841 	.word	0x08003841
 8000414:	08003c58 	.word	0x08003c58
 8000418:	08003880 	.word	0x08003880
 800041c:	0800389d 	.word	0x0800389d
 8000420:	080038c1 	.word	0x080038c1
 8000424:	1ffff7e0 	.word	0x1ffff7e0
 8000428:	080038d4 	.word	0x080038d4
 800042c:	080038e5 	.word	0x080038e5
 8000430:	e0001004 	.word	0xe0001004
 8000434:	08003c68 	.word	0x08003c68
 8000438:	200010c0 	.word	0x200010c0
 800043c:	08040000 	.word	0x08040000
 8000440:	080038fb 	.word	0x080038fb
 8000444:	05fa0004 	.word	0x05fa0004
 8000448:	e000ed0c 	.word	0xe000ed0c
 800044c:	40003000 	.word	0x40003000
 8000450:	40003004 	.word	0x40003004
 8000454:	20000850 	.word	0x20000850

08000458 <_close>:
}

int _close(int file) {
	file=file;
    return -1;
}
 8000458:	f04f 30ff 	mov.w	r0, #4294967295
 800045c:	4770      	bx	lr

0800045e <_execve>:
 execve
 Transfer control to a new process. Minimal implementation (for a system without processes):
 */
int _execve(char *name, char **argv, char **env) {
	name=name; argv=argv; env=env;
    errno = ENOMEM;
 800045e:	4b03      	ldr	r3, [pc, #12]	; (800046c <_execve+0xe>)
 8000460:	220c      	movs	r2, #12
 8000462:	601a      	str	r2, [r3, #0]
    return -1;
}
 8000464:	f04f 30ff 	mov.w	r0, #4294967295
 8000468:	4770      	bx	lr
 800046a:	bf00      	nop
 800046c:	20002228 	.word	0x20002228

08000470 <_fork>:
 fork
 Create a new process. Minimal implementation (for a system without processes):
 */

int _fork(void) {
    errno = EAGAIN;
 8000470:	4b02      	ldr	r3, [pc, #8]	; (800047c <_fork+0xc>)
 8000472:	220b      	movs	r2, #11
 8000474:	601a      	str	r2, [r3, #0]
    return -1;
}
 8000476:	f04f 30ff 	mov.w	r0, #4294967295
 800047a:	4770      	bx	lr
 800047c:	20002228 	.word	0x20002228

08000480 <_fstat>:
 all files are regarded as character special devices.
 The `sys/stat.h' header file required is distributed in the `include' subdirectory for this C library.
 */
int _fstat(int file, struct stat *st) {
	file=file;
    st->st_mode = S_IFCHR;
 8000480:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8000484:	604b      	str	r3, [r1, #4]
    return 0;
}
 8000486:	2000      	movs	r0, #0
 8000488:	4770      	bx	lr

0800048a <_getpid>:
 Process-ID; this is sometimes used to generate strings unlikely to conflict with other processes. Minimal implementation, for a system without processes:
 */

int _getpid(void) {
    return 1;
}
 800048a:	2001      	movs	r0, #1
 800048c:	4770      	bx	lr

0800048e <_isatty>:
/*
 isatty
 Query whether output stream is a terminal. For consistency with the other minimal implementations,
 */
int _isatty(int file) {
    switch (file){
 800048e:	2802      	cmp	r0, #2
    case STDERR_FILENO:
    case STDIN_FILENO:
        return 1;
    default:
        //errno = ENOTTY;
        errno = EBADF;
 8000490:	bf81      	itttt	hi
 8000492:	4b03      	ldrhi	r3, [pc, #12]	; (80004a0 <_isatty+0x12>)
 8000494:	2209      	movhi	r2, #9
        return 0;
 8000496:	2000      	movhi	r0, #0
    case STDERR_FILENO:
    case STDIN_FILENO:
        return 1;
    default:
        //errno = ENOTTY;
        errno = EBADF;
 8000498:	601a      	strhi	r2, [r3, #0]
int _isatty(int file) {
    switch (file){
    case STDOUT_FILENO:
    case STDERR_FILENO:
    case STDIN_FILENO:
        return 1;
 800049a:	bf98      	it	ls
 800049c:	2001      	movls	r0, #1
    default:
        //errno = ENOTTY;
        errno = EBADF;
        return 0;
    }
}
 800049e:	4770      	bx	lr
 80004a0:	20002228 	.word	0x20002228

080004a4 <_kill>:
 kill
 Send a signal. Minimal implementation:
 */
int _kill(int pid, int sig) {
	pid=pid; sig=sig;
    errno = EINVAL;
 80004a4:	4b02      	ldr	r3, [pc, #8]	; (80004b0 <_kill+0xc>)
 80004a6:	2216      	movs	r2, #22
 80004a8:	601a      	str	r2, [r3, #0]
    return (-1);
}
 80004aa:	f04f 30ff 	mov.w	r0, #4294967295
 80004ae:	4770      	bx	lr
 80004b0:	20002228 	.word	0x20002228

080004b4 <_link>:
 Establish a new name for an existing file. Minimal implementation:
 */

int _link(char *old, char *new) {
	old=old; new=new;
    errno = EMLINK;
 80004b4:	4b02      	ldr	r3, [pc, #8]	; (80004c0 <_link+0xc>)
 80004b6:	221f      	movs	r2, #31
 80004b8:	601a      	str	r2, [r3, #0]
    return -1;
}
 80004ba:	f04f 30ff 	mov.w	r0, #4294967295
 80004be:	4770      	bx	lr
 80004c0:	20002228 	.word	0x20002228

080004c4 <_lseek>:
 Set position in a file. Minimal implementation:
 */
int _lseek(int file, int ptr, int dir) {
	file=file; ptr=ptr; dir=dir;
    return 0;
}
 80004c4:	2000      	movs	r0, #0
 80004c6:	4770      	bx	lr

080004c8 <_sbrk>:

caddr_t _sbrk(int incr) 
{
    char *prev_heap_end;

    if (heap_end == 0) {
 80004c8:	4b04      	ldr	r3, [pc, #16]	; (80004dc <_sbrk+0x14>)
static char *heap_end;
extern char _ebss; 	// Defined by .ld
extern char * __MSP;	// Defined in .ld

caddr_t _sbrk(int incr) 
{
 80004ca:	4602      	mov	r2, r0
    char *prev_heap_end;

    if (heap_end == 0) {
 80004cc:	6819      	ldr	r1, [r3, #0]
 80004ce:	b909      	cbnz	r1, 80004d4 <_sbrk+0xc>
        heap_end = &_ebss;
 80004d0:	4903      	ldr	r1, [pc, #12]	; (80004e0 <_sbrk+0x18>)
 80004d2:	6019      	str	r1, [r3, #0]
    }
    prev_heap_end = heap_end;
 80004d4:	6818      	ldr	r0, [r3, #0]
//         errno = ENOMEM;
//         return  (caddr_t) -1;
//         //abort ();
//     }

    heap_end += incr;
 80004d6:	4402      	add	r2, r0
 80004d8:	601a      	str	r2, [r3, #0]
    return (caddr_t) prev_heap_end;

}
 80004da:	4770      	bx	lr
 80004dc:	20000854 	.word	0x20000854
 80004e0:	2000222c 	.word	0x2000222c

080004e4 <_read>:


int _read(int file, char *ptr, int len) {
    int num = 0;
 ptr=ptr; len=len;
    switch (file) {
 80004e4:	b120      	cbz	r0, 80004f0 <_read+0xc>
    case STDIN_FILENO:
        break;
    default:
        errno = EBADF;
 80004e6:	4b03      	ldr	r3, [pc, #12]	; (80004f4 <_read+0x10>)
 80004e8:	2209      	movs	r2, #9
 80004ea:	601a      	str	r2, [r3, #0]
        return -1;
 80004ec:	f04f 30ff 	mov.w	r0, #4294967295
    }
    return num;
}
 80004f0:	4770      	bx	lr
 80004f2:	bf00      	nop
 80004f4:	20002228 	.word	0x20002228

080004f8 <_stat>:
 int    _EXFUN(stat,( const char *__path, struct stat *__sbuf ));
 */

int _stat(const char *filepath, struct stat *st) {
	filepath=filepath;
    st->st_mode = S_IFCHR;
 80004f8:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80004fc:	604b      	str	r3, [r1, #4]
    return 0;
}
 80004fe:	2000      	movs	r0, #0
 8000500:	4770      	bx	lr

08000502 <_times>:
 */

clock_t _times(struct tms *buf) {
	buf=buf;
    return -1;
}
 8000502:	f04f 30ff 	mov.w	r0, #4294967295
 8000506:	4770      	bx	lr

08000508 <_unlink>:
 unlink
 Remove a file's directory entry. Minimal implementation:
 */
int _unlink(char *name) {
	name=name;
    errno = ENOENT;
 8000508:	4b02      	ldr	r3, [pc, #8]	; (8000514 <_unlink+0xc>)
 800050a:	2202      	movs	r2, #2
 800050c:	601a      	str	r2, [r3, #0]
    return -1;
}
 800050e:	f04f 30ff 	mov.w	r0, #4294967295
 8000512:	4770      	bx	lr
 8000514:	20002228 	.word	0x20002228

08000518 <_wait>:
 wait
 Wait for a child process. Minimal implementation:
 */
int _wait(int *status) {
	status=status;
    errno = ECHILD;
 8000518:	4b02      	ldr	r3, [pc, #8]	; (8000524 <_wait+0xc>)
 800051a:	220a      	movs	r2, #10
 800051c:	601a      	str	r2, [r3, #0]
    return -1;
}
 800051e:	f04f 30ff 	mov.w	r0, #4294967295
 8000522:	4770      	bx	lr
 8000524:	20002228 	.word	0x20002228

08000528 <_write>:
 Write a character to a file. `libc' subroutines will use this system routine for output to all files, including stdout
 Returns -1 on error or number of bytes sent
 */
int _write(int file, char *ptr, int len) {
    int n;
    switch (file) {
 8000528:	2801      	cmp	r0, #1
/*
 write
 Write a character to a file. `libc' subroutines will use this system routine for output to all files, including stdout
 Returns -1 on error or number of bytes sent
 */
int _write(int file, char *ptr, int len) {
 800052a:	b570      	push	{r4, r5, r6, lr}
 800052c:	460d      	mov	r5, r1
 800052e:	4614      	mov	r4, r2
    int n;
    switch (file) {
 8000530:	d003      	beq.n	800053a <_write+0x12>
 8000532:	2802      	cmp	r0, #2
 8000534:	d123      	bne.n	800057e <_write+0x56>
 8000536:	460e      	mov	r6, r1
 8000538:	e01c      	b.n	8000574 <_write+0x4c>
 800053a:	460e      	mov	r6, r1

    case STDOUT_FILENO: /*stdout*/
        for (n = 0; n < len; n++) 
 800053c:	1b73      	subs	r3, r6, r5
 800053e:	42a3      	cmp	r3, r4
 8000540:	da1b      	bge.n	800057a <_write+0x52>
	{
		USART1_txint_putc(*ptr);
 8000542:	7830      	ldrb	r0, [r6, #0]
 8000544:	f001 fb80 	bl	8001c48 <USART1_txint_putc>
		if (*ptr++ == '\n') 	
 8000548:	f816 3b01 	ldrb.w	r3, [r6], #1
 800054c:	2b0a      	cmp	r3, #10
 800054e:	d1f5      	bne.n	800053c <_write+0x14>
		{			
			USART1_txint_putc('\r');
 8000550:	200d      	movs	r0, #13
 8000552:	f001 fb79 	bl	8001c48 <USART1_txint_putc>
			USART1_txint_send();
 8000556:	f001 fba9 	bl	8001cac <USART1_txint_send>
 800055a:	e7ef      	b.n	800053c <_write+0x14>
        break;

    case STDERR_FILENO: /* stderr */
        for (n = 0; n < len; n++) 
	{
		USART1_txint_putc(*ptr);
 800055c:	7830      	ldrb	r0, [r6, #0]
 800055e:	f001 fb73 	bl	8001c48 <USART1_txint_putc>
		if (*ptr++ == '\n') 	
 8000562:	f816 3b01 	ldrb.w	r3, [r6], #1
 8000566:	2b0a      	cmp	r3, #10
 8000568:	d104      	bne.n	8000574 <_write+0x4c>
		{			
			USART1_txint_putc('\r');
 800056a:	200d      	movs	r0, #13
 800056c:	f001 fb6c 	bl	8001c48 <USART1_txint_putc>
			USART1_txint_send();
 8000570:	f001 fb9c 	bl	8001cac <USART1_txint_send>
		}
      }
        break;

    case STDERR_FILENO: /* stderr */
        for (n = 0; n < len; n++) 
 8000574:	1b73      	subs	r3, r6, r5
 8000576:	429c      	cmp	r4, r3
 8000578:	dcf0      	bgt.n	800055c <_write+0x34>
		}
        }
        break;
    default:
        errno = EBADF;
        return -1;
 800057a:	4620      	mov	r0, r4
 800057c:	bd70      	pop	{r4, r5, r6, pc}
			USART1_txint_send();
		}
        }
        break;
    default:
        errno = EBADF;
 800057e:	4b03      	ldr	r3, [pc, #12]	; (800058c <_write+0x64>)
 8000580:	2209      	movs	r2, #9
 8000582:	601a      	str	r2, [r3, #0]
        return -1;
 8000584:	f04f 30ff 	mov.w	r0, #4294967295
    }
    return len;
}
 8000588:	bd70      	pop	{r4, r5, r6, pc}
 800058a:	bf00      	nop
 800058c:	20002228 	.word	0x20002228

08000590 <_exit>:
char *__env[1] = { 0 };
char **environ = __env;

int _write(int file, char *ptr, int len);

void _exit(int status) {
 8000590:	b508      	push	{r3, lr}
	status = status;
    _write(1, "exit\n", 4);
 8000592:	2204      	movs	r2, #4
 8000594:	4902      	ldr	r1, [pc, #8]	; (80005a0 <_exit+0x10>)
 8000596:	2001      	movs	r0, #1
 8000598:	f7ff ffc6 	bl	8000528 <_write>
 800059c:	e7fe      	b.n	800059c <_exit+0xc>
 800059e:	bf00      	nop
 80005a0:	08003930 	.word	0x08003930

080005a4 <flashblockinit>:
	u64* pt1;	// Beginning address of flash block
	u64* pt2;	// Beginning address of RAM buff
	u64* ptend;	// End+1 of RAM buff

	/* Load block that padd points to into RAM. */
	pt1 = (u64*)((u32)(padd) & ~(flashblocksize - 1)); 	// Block addr of STM32 memory to be loaded
 80005a4:	4b0f      	ldr	r3, [pc, #60]	; (80005e4 <flashblockinit+0x40>)
 80005a6:	4810      	ldr	r0, [pc, #64]	; (80005e8 <flashblockinit+0x44>)
 80005a8:	681a      	ldr	r2, [r3, #0]
/* **************************************************************************************
 * static void flashblockinit(void);
 * @brief	: Read in flash block to sram buffer
 * ************************************************************************************** */
static void flashblockinit(void)
{
 80005aa:	b530      	push	{r4, r5, lr}
	u64* pt1;	// Beginning address of flash block
	u64* pt2;	// Beginning address of RAM buff
	u64* ptend;	// End+1 of RAM buff

	/* Load block that padd points to into RAM. */
	pt1 = (u64*)((u32)(padd) & ~(flashblocksize - 1)); 	// Block addr of STM32 memory to be loaded
 80005ac:	6804      	ldr	r4, [r0, #0]
 80005ae:	4251      	negs	r1, r2
 80005b0:	4021      	ands	r1, r4
	flblkbuff.base = (u8*)pt1;				// Pointer to beginning of flash block
	flblkbuff.end = flblkbuff.base + flashblocksize;	// End + 1
 80005b2:	188b      	adds	r3, r1, r2
 80005b4:	f8c0 380c 	str.w	r3, [r0, #2060]	; 0x80c
	flblkbuff.p = &flblkbuff.fb.u8[0] + (padd - (u8*)pt1); 	// Pointer to where payload begins storing
 80005b8:	1a64      	subs	r4, r4, r1
 80005ba:	f100 0308 	add.w	r3, r0, #8
 80005be:	441c      	add	r4, r3
 80005c0:	f8c0 4810 	str.w	r4, [r0, #2064]	; 0x810
	flblkbuff.sw = 0;					// Switch for write/erase
	pt2 = &flblkbuff.fb.u64[0];				// RAM buffer for block
	ptend = pt2 + (flashblocksize/sizeof(u64)); 		// End+1 of RAM buffer
 80005c4:	f022 0207 	bic.w	r2, r2, #7
	/* Load block that padd points to into RAM. */
	pt1 = (u64*)((u32)(padd) & ~(flashblocksize - 1)); 	// Block addr of STM32 memory to be loaded
	flblkbuff.base = (u8*)pt1;				// Pointer to beginning of flash block
	flblkbuff.end = flblkbuff.base + flashblocksize;	// End + 1
	flblkbuff.p = &flblkbuff.fb.u8[0] + (padd - (u8*)pt1); 	// Pointer to where payload begins storing
	flblkbuff.sw = 0;					// Switch for write/erase
 80005c8:	2400      	movs	r4, #0
	u64* pt2;	// Beginning address of RAM buff
	u64* ptend;	// End+1 of RAM buff

	/* Load block that padd points to into RAM. */
	pt1 = (u64*)((u32)(padd) & ~(flashblocksize - 1)); 	// Block addr of STM32 memory to be loaded
	flblkbuff.base = (u8*)pt1;				// Pointer to beginning of flash block
 80005ca:	f8c0 1808 	str.w	r1, [r0, #2056]	; 0x808
	flblkbuff.end = flblkbuff.base + flashblocksize;	// End + 1
	flblkbuff.p = &flblkbuff.fb.u8[0] + (padd - (u8*)pt1); 	// Pointer to where payload begins storing
	flblkbuff.sw = 0;					// Switch for write/erase
 80005ce:	f8a0 4814 	strh.w	r4, [r0, #2068]	; 0x814
	pt2 = &flblkbuff.fb.u64[0];				// RAM buffer for block
	ptend = pt2 + (flashblocksize/sizeof(u64)); 		// End+1 of RAM buffer
 80005d2:	441a      	add	r2, r3
//printf("P0: %X %X %X\n\r",pt1, pt2, ptend);USART1_txint_send();
	while (pt2 < ptend) *pt2++ = *pt1++; 			// Copy flash to RAM buffer
 80005d4:	429a      	cmp	r2, r3
 80005d6:	d904      	bls.n	80005e2 <flashblockinit+0x3e>
 80005d8:	e8f1 4502 	ldrd	r4, r5, [r1], #8
 80005dc:	e8e3 4502 	strd	r4, r5, [r3], #8
 80005e0:	e7f8      	b.n	80005d4 <flashblockinit+0x30>
//printf("P1: %X %X %X\n\r",pt1, pt2, ptend);USART1_txint_send();
	return;
}
 80005e2:	bd30      	pop	{r4, r5, pc}
 80005e4:	20000004 	.word	0x20000004
 80005e8:	20000860 	.word	0x20000860

080005ec <can_msg_put>:
 * @brief	: send a CAN msg
 * @param	: pcan = pointer to CAN msg
 ******************************************************************************/
static void can_msg_put(struct CANRCVBUF* pcan)
{
	can_driver_put(pctl1, pcan, 4, 0);
 80005ec:	4601      	mov	r1, r0
 80005ee:	4803      	ldr	r0, [pc, #12]	; (80005fc <can_msg_put+0x10>)
 80005f0:	2300      	movs	r3, #0
 80005f2:	2204      	movs	r2, #4
 80005f4:	6800      	ldr	r0, [r0, #0]
 80005f6:	f002 bb41 	b.w	8002c7c <can_driver_put>
 80005fa:	bf00      	nop
 80005fc:	20000850 	.word	0x20000850

08000600 <wrblk>:
/* **************************************************************************************
 * static void wrblk(struct CANRCVBUF* pcan);
 * @brief	: Write RAM buffer out to flash
 * ************************************************************************************** */
static void wrblk(struct CANRCVBUF* pcan)
{
 8000600:	b537      	push	{r0, r1, r2, r4, r5, lr}
printf("wrblk: %d %X %X %08X %08X\n\r",debugPctr, padd, pcan->dlc, pcan->cd.ui[0], pcan->cd.ui[1]);USART1_txint_send();
 8000602:	68c3      	ldr	r3, [r0, #12]
 8000604:	4c25      	ldr	r4, [pc, #148]	; (800069c <wrblk+0x9c>)
 8000606:	9301      	str	r3, [sp, #4]
 8000608:	6883      	ldr	r3, [r0, #8]
 800060a:	f8d4 1818 	ldr.w	r1, [r4, #2072]	; 0x818
 800060e:	9300      	str	r3, [sp, #0]
 8000610:	6843      	ldr	r3, [r0, #4]
 8000612:	6822      	ldr	r2, [r4, #0]
 8000614:	4822      	ldr	r0, [pc, #136]	; (80006a0 <wrblk+0xa0>)
 8000616:	f001 fa55 	bl	8001ac4 <tfp_printf>
 800061a:	f001 fb47 	bl	8001cac <USART1_txint_send>

	switch (flblkbuff.sw) 
 800061e:	f8b4 1814 	ldrh.w	r1, [r4, #2068]	; 0x814
 8000622:	2903      	cmp	r1, #3
 8000624:	d831      	bhi.n	800068a <wrblk+0x8a>
 8000626:	e8df f001 	tbb	[pc, r1]
 800062a:	1102      	.short	0x1102
 800062c:	0606      	.short	0x0606
	{
	case 0:	// Need to write or erase & write?
printf("wrblk: CASE 0: no need to write block\n\r");USART1_txint_send();
 800062e:	481d      	ldr	r0, [pc, #116]	; (80006a4 <wrblk+0xa4>)
 8000630:	f001 fa48 	bl	8001ac4 <tfp_printf>
 8000634:	e02c      	b.n	8000690 <wrblk+0x90>
		break;	// No need to write the block

	case 2:
	case 3: // Erase block, then write
printf("wrblk: CASE 2: erase block before writing\n\r");USART1_txint_send();
 8000636:	481c      	ldr	r0, [pc, #112]	; (80006a8 <wrblk+0xa8>)
 8000638:	f001 fa44 	bl	8001ac4 <tfp_printf>
 800063c:	f001 fb36 	bl	8001cac <USART1_txint_send>
		can_msg_cmd.cd.uc[2] = flash_erase((u16*)flblkbuff.base);
 8000640:	f8d4 0808 	ldr.w	r0, [r4, #2056]	; 0x808
 8000644:	f001 feba 	bl	80023bc <flash_erase>
 8000648:	f884 082a 	strb.w	r0, [r4, #2090]	; 0x82a

	case 1: // Write, but no need for erase
		can_msg_cmd.cd.uc[1] = flash_write( (u16*)flblkbuff.base, &flblkbuff.fb.u16[0], flashblocksize );
 800064c:	4b17      	ldr	r3, [pc, #92]	; (80006ac <wrblk+0xac>)
 800064e:	4d13      	ldr	r5, [pc, #76]	; (800069c <wrblk+0x9c>)
 8000650:	681a      	ldr	r2, [r3, #0]
 8000652:	f105 0108 	add.w	r1, r5, #8
 8000656:	f8d4 0808 	ldr.w	r0, [r4, #2056]	; 0x808
 800065a:	f001 fe3b 	bl	80022d4 <flash_write>
 800065e:	f884 0829 	strb.w	r0, [r4, #2089]	; 0x829
printf("wrblk: CASE 1: writing block\n\r");USART1_txint_send();
 8000662:	4813      	ldr	r0, [pc, #76]	; (80006b0 <wrblk+0xb0>)
 8000664:	f001 fa2e 	bl	8001ac4 <tfp_printf>
 8000668:	f001 fb20 	bl	8001cac <USART1_txint_send>

if ((can_msg_cmd.cd.uc[1] != 0) || (can_msg_cmd.cd.uc[2] != 0))
 800066c:	f8d4 3828 	ldr.w	r3, [r4, #2088]	; 0x828
 8000670:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8000674:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 8000678:	b153      	cbz	r3, 8000690 <wrblk+0x90>
 printf("wrblk: pay[1] %X pay[2] %X\n\r",can_msg_cmd.cd.uc[1], can_msg_cmd.cd.uc[2]);USART1_txint_send();
 800067a:	f895 282a 	ldrb.w	r2, [r5, #2090]	; 0x82a
 800067e:	f895 1829 	ldrb.w	r1, [r5, #2089]	; 0x829
 8000682:	480c      	ldr	r0, [pc, #48]	; (80006b4 <wrblk+0xb4>)
 8000684:	f001 fa1e 	bl	8001ac4 <tfp_printf>
 8000688:	e002      	b.n	8000690 <wrblk+0x90>
		break;	
	default:
printf("wrblk: default: %d\n\r",flblkbuff.sw);USART1_txint_send();
 800068a:	480b      	ldr	r0, [pc, #44]	; (80006b8 <wrblk+0xb8>)
 800068c:	f001 fa1a 	bl	8001ac4 <tfp_printf>
	}
	return;
}
 8000690:	b003      	add	sp, #12
 8000692:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}

if ((can_msg_cmd.cd.uc[1] != 0) || (can_msg_cmd.cd.uc[2] != 0))
 printf("wrblk: pay[1] %X pay[2] %X\n\r",can_msg_cmd.cd.uc[1], can_msg_cmd.cd.uc[2]);USART1_txint_send();
		break;	
	default:
printf("wrblk: default: %d\n\r",flblkbuff.sw);USART1_txint_send();
 8000696:	f001 bb09 	b.w	8001cac <USART1_txint_send>
 800069a:	bf00      	nop
 800069c:	20000860 	.word	0x20000860
 80006a0:	08003936 	.word	0x08003936
 80006a4:	08003952 	.word	0x08003952
 80006a8:	0800397a 	.word	0x0800397a
 80006ac:	20000004 	.word	0x20000004
 80006b0:	080039a6 	.word	0x080039a6
 80006b4:	080039c5 	.word	0x080039c5
 80006b8:	080039e2 	.word	0x080039e2

080006bc <canwinch_ldrproto_init>:
 * void canwinch_ldrproto_init(u32 iamunitnumber);
 * @brief	: Initialization for loader
 * @param	: Unit number 
 * ************************************************************************************** */
void canwinch_ldrproto_init(u32 iamunitnumber)
{
 80006bc:	b538      	push	{r3, r4, r5, lr}
 80006be:	4605      	mov	r5, r0
	padd = (u8*)(0x08000000);	// Set to something that doesn't give a bad address error
 80006c0:	4c21      	ldr	r4, [pc, #132]	; (8000748 <canwinch_ldrproto_init+0x8c>)
 80006c2:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 80006c6:	6023      	str	r3, [r4, #0]

	/* Flash block size */
	flashblocksize = (*(u16*)(0x1FFFF7E0)); // Get size of flash in Kbytes
 80006c8:	4b20      	ldr	r3, [pc, #128]	; (800074c <canwinch_ldrproto_init+0x90>)
 80006ca:	4a21      	ldr	r2, [pc, #132]	; (8000750 <canwinch_ldrproto_init+0x94>)
 80006cc:	881b      	ldrh	r3, [r3, #0]
	/* Highest flash address plus one = lowest + (flash size(kbytes) * 1024)  */
	flash_hi = (u8*)(0x08000000 + (u32)((*(u16*)(0x1FFFF7E0)) << 10) );

	flbblkbuff_init(); // Set initial pointer.

printf("FLASH BLK SZE: %d K\n\r",flashblocksize);
 80006ce:	4821      	ldr	r0, [pc, #132]	; (8000754 <canwinch_ldrproto_init+0x98>)
{
	padd = (u8*)(0x08000000);	// Set to something that doesn't give a bad address error

	/* Flash block size */
	flashblocksize = (*(u16*)(0x1FFFF7E0)); // Get size of flash in Kbytes
	if (flashblocksize > 256) 
 80006d0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
		flashblocksize = 2048;	// XL series flash block size
 80006d4:	bf8c      	ite	hi
 80006d6:	f44f 6100 	movhi.w	r1, #2048	; 0x800
	else
		flashblocksize = 1024;	// Med, and High series flash block size
 80006da:	f44f 6180 	movls.w	r1, #1024	; 0x400
 80006de:	6011      	str	r1, [r2, #0]

	/* Highest flash address plus one = lowest + (flash size(kbytes) * 1024)  */
	flash_hi = (u8*)(0x08000000 + (u32)((*(u16*)(0x1FFFF7E0)) << 10) );
 80006e0:	029b      	lsls	r3, r3, #10
 * ************************************************************************************** */
static void flbblkbuff_init(void)
{

	/* Assure start address for block is on an even boundary */
	flblkbuff.base = (u8*)((u32)(padd) & (flashblocksize - 1));
 80006e2:	6811      	ldr	r1, [r2, #0]
		flashblocksize = 2048;	// XL series flash block size
	else
		flashblocksize = 1024;	// Med, and High series flash block size

	/* Highest flash address plus one = lowest + (flash size(kbytes) * 1024)  */
	flash_hi = (u8*)(0x08000000 + (u32)((*(u16*)(0x1FFFF7E0)) << 10) );
 80006e4:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
{

	/* Assure start address for block is on an even boundary */
	flblkbuff.base = (u8*)((u32)(padd) & (flashblocksize - 1));

	flblkbuff.p = &flblkbuff.fb.u8[0]; // Pointer into flash block
 80006e8:	4a1b      	ldr	r2, [pc, #108]	; (8000758 <canwinch_ldrproto_init+0x9c>)
		flashblocksize = 2048;	// XL series flash block size
	else
		flashblocksize = 1024;	// Med, and High series flash block size

	/* Highest flash address plus one = lowest + (flash size(kbytes) * 1024)  */
	flash_hi = (u8*)(0x08000000 + (u32)((*(u16*)(0x1FFFF7E0)) << 10) );
 80006ea:	f8c4 3830 	str.w	r3, [r4, #2096]	; 0x830
 * ************************************************************************************** */
static void flbblkbuff_init(void)
{

	/* Assure start address for block is on an even boundary */
	flblkbuff.base = (u8*)((u32)(padd) & (flashblocksize - 1));
 80006ee:	2300      	movs	r3, #0

	flblkbuff.p = &flblkbuff.fb.u8[0]; // Pointer into flash block
 80006f0:	f8c4 2810 	str.w	r2, [r4, #2064]	; 0x810
 * ************************************************************************************** */
static void flbblkbuff_init(void)
{

	/* Assure start address for block is on an even boundary */
	flblkbuff.base = (u8*)((u32)(padd) & (flashblocksize - 1));
 80006f4:	f8c4 3808 	str.w	r3, [r4, #2056]	; 0x808

	flblkbuff.p = &flblkbuff.fb.u8[0]; // Pointer into flash block
	flblkbuff.sw = 0;	// need to write, or erase and write, switch
 80006f8:	f8a4 3814 	strh.w	r3, [r4, #2068]	; 0x814
	/* Highest flash address plus one = lowest + (flash size(kbytes) * 1024)  */
	flash_hi = (u8*)(0x08000000 + (u32)((*(u16*)(0x1FFFF7E0)) << 10) );

	flbblkbuff_init(); // Set initial pointer.

printf("FLASH BLK SZE: %d K\n\r",flashblocksize);
 80006fc:	f001 f9e2 	bl	8001ac4 <tfp_printf>
printf("FLASH HI ADDR: %08X\n\r",flash_hi);
 8000700:	f8d4 1830 	ldr.w	r1, [r4, #2096]	; 0x830
 8000704:	4815      	ldr	r0, [pc, #84]	; (800075c <canwinch_ldrproto_init+0xa0>)
 8000706:	f001 f9dd 	bl	8001ac4 <tfp_printf>

	/* Set fixed part of CAN msgs */
//	can_msg_cmd.id = iamunitnumber | (CAN_EXTRID_DATA_CMD << CAN_EXTRID_SHIFT); // Command
	can_msg_cmd.id = iamunitnumber; // Command
	can_msg_rd.id  = iamunitnumber | (CAN_EXTRID_DATA_RD  << CAN_EXTRID_SHIFT); // Read
	can_msg_wr.id  = iamunitnumber | (CAN_EXTRID_DATA_WR  << CAN_EXTRID_SHIFT); // Write
 800070a:	f045 4040 	orr.w	r0, r5, #3221225472	; 0xc0000000
printf("FLASH HI ADDR: %08X\n\r",flash_hi);

	/* Set fixed part of CAN msgs */
//	can_msg_cmd.id = iamunitnumber | (CAN_EXTRID_DATA_CMD << CAN_EXTRID_SHIFT); // Command
	can_msg_cmd.id = iamunitnumber; // Command
	can_msg_rd.id  = iamunitnumber | (CAN_EXTRID_DATA_RD  << CAN_EXTRID_SHIFT); // Read
 800070e:	f045 4330 	orr.w	r3, r5, #2952790016	; 0xb0000000
	can_msg_wr.id  = iamunitnumber | (CAN_EXTRID_DATA_WR  << CAN_EXTRID_SHIFT); // Write
 8000712:	f8c4 0848 	str.w	r0, [r4, #2120]	; 0x848

printf("CAN ID's\n\r");
 8000716:	4812      	ldr	r0, [pc, #72]	; (8000760 <canwinch_ldrproto_init+0xa4>)
printf("FLASH HI ADDR: %08X\n\r",flash_hi);

	/* Set fixed part of CAN msgs */
//	can_msg_cmd.id = iamunitnumber | (CAN_EXTRID_DATA_CMD << CAN_EXTRID_SHIFT); // Command
	can_msg_cmd.id = iamunitnumber; // Command
	can_msg_rd.id  = iamunitnumber | (CAN_EXTRID_DATA_RD  << CAN_EXTRID_SHIFT); // Read
 8000718:	f8c4 3838 	str.w	r3, [r4, #2104]	; 0x838
printf("FLASH BLK SZE: %d K\n\r",flashblocksize);
printf("FLASH HI ADDR: %08X\n\r",flash_hi);

	/* Set fixed part of CAN msgs */
//	can_msg_cmd.id = iamunitnumber | (CAN_EXTRID_DATA_CMD << CAN_EXTRID_SHIFT); // Command
	can_msg_cmd.id = iamunitnumber; // Command
 800071c:	f8c4 5820 	str.w	r5, [r4, #2080]	; 0x820
	can_msg_rd.id  = iamunitnumber | (CAN_EXTRID_DATA_RD  << CAN_EXTRID_SHIFT); // Read
	can_msg_wr.id  = iamunitnumber | (CAN_EXTRID_DATA_WR  << CAN_EXTRID_SHIFT); // Write

printf("CAN ID's\n\r");
 8000720:	f001 f9d0 	bl	8001ac4 <tfp_printf>
printf( "CMD: %08X\n\r",can_msg_cmd.id);
 8000724:	f8d4 1820 	ldr.w	r1, [r4, #2080]	; 0x820
 8000728:	480e      	ldr	r0, [pc, #56]	; (8000764 <canwinch_ldrproto_init+0xa8>)
 800072a:	f001 f9cb 	bl	8001ac4 <tfp_printf>
printf( "RD : %08X\n\r",can_msg_rd.id);
 800072e:	f8d4 1838 	ldr.w	r1, [r4, #2104]	; 0x838
 8000732:	480d      	ldr	r0, [pc, #52]	; (8000768 <canwinch_ldrproto_init+0xac>)
 8000734:	f001 f9c6 	bl	8001ac4 <tfp_printf>
printf( "WR : %08X\n\r",can_msg_wr.id);
 8000738:	f8d4 1848 	ldr.w	r1, [r4, #2120]	; 0x848
 800073c:	480b      	ldr	r0, [pc, #44]	; (800076c <canwinch_ldrproto_init+0xb0>)

	return;
}
 800073e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	can_msg_wr.id  = iamunitnumber | (CAN_EXTRID_DATA_WR  << CAN_EXTRID_SHIFT); // Write

printf("CAN ID's\n\r");
printf( "CMD: %08X\n\r",can_msg_cmd.id);
printf( "RD : %08X\n\r",can_msg_rd.id);
printf( "WR : %08X\n\r",can_msg_wr.id);
 8000742:	f001 b9bf 	b.w	8001ac4 <tfp_printf>
 8000746:	bf00      	nop
 8000748:	20000860 	.word	0x20000860
 800074c:	1ffff7e0 	.word	0x1ffff7e0
 8000750:	20000004 	.word	0x20000004
 8000754:	080039f7 	.word	0x080039f7
 8000758:	20000868 	.word	0x20000868
 800075c:	08003a0d 	.word	0x08003a0d
 8000760:	08003a23 	.word	0x08003a23
 8000764:	08003a2e 	.word	0x08003a2e
 8000768:	08003a3a 	.word	0x08003a3a
 800076c:	08003a46 	.word	0x08003a46

08000770 <mv2>:
 * @brief	: Convert 2 bytes into a 1/2 word
 * u32 mv4(u8* p2);
 * @brief	: Convert 4 bytes into a word

 * ************************************************************************************** */
u16 mv2(u8* p2){ return ( *(p2+1)<<8 | *p2 ); }
 8000770:	7842      	ldrb	r2, [r0, #1]
 8000772:	7800      	ldrb	r0, [r0, #0]
 8000774:	ea40 2002 	orr.w	r0, r0, r2, lsl #8
 8000778:	4770      	bx	lr

0800077a <mv4>:
u32 mv4(u8* p2){ return ( *(p2+3)<<24 | *(p2+2)<<16 | *(p2+1)<<8 | *p2 ); }
 800077a:	6800      	ldr	r0, [r0, #0]
 800077c:	4770      	bx	lr

0800077e <do_dataread>:
{
	u32 i;
	/* We will assume the bozo asking for read has set a valid address.  If the address
           is not valid there might be a hard fault/invalid address crash and a power cycling \
           to recover would be needed. */
	u32 count = p->dlc & 0xf;	// Get the byte count request
 800077e:	6843      	ldr	r3, [r0, #4]
 * void do_dataread(struct CANRCVBUF* p);
 * @brief	: Do something!
 * @param	: Point to message buffer
 * ************************************************************************************** */
void do_dataread(struct CANRCVBUF* p)
{
 8000780:	b430      	push	{r4, r5}
	u32 i;
	/* We will assume the bozo asking for read has set a valid address.  If the address
           is not valid there might be a hard fault/invalid address crash and a power cycling \
           to recover would be needed. */
	u32 count = p->dlc & 0xf;	// Get the byte count request
 8000782:	f003 030f 	and.w	r3, r3, #15
 8000786:	2b08      	cmp	r3, #8
 8000788:	bf28      	it	cs
 800078a:	2308      	movcs	r3, #8
 800078c:	3307      	adds	r3, #7
	{ // In case we got a bogus byte count
		count = 8;
	}
	for (i = 0; i < count; i++)
	{
		p->cd.uc[i] = *padd++;
 800078e:	4907      	ldr	r1, [pc, #28]	; (80007ac <do_dataread+0x2e>)
 8000790:	1dc2      	adds	r2, r0, #7
 8000792:	4403      	add	r3, r0
	
	if (count > 8)
	{ // In case we got a bogus byte count
		count = 8;
	}
	for (i = 0; i < count; i++)
 8000794:	429a      	cmp	r2, r3
 8000796:	d006      	beq.n	80007a6 <do_dataread+0x28>
	{
		p->cd.uc[i] = *padd++;
 8000798:	680c      	ldr	r4, [r1, #0]
 800079a:	1c65      	adds	r5, r4, #1
 800079c:	600d      	str	r5, [r1, #0]
 800079e:	7824      	ldrb	r4, [r4, #0]
 80007a0:	f802 4f01 	strb.w	r4, [r2, #1]!
 80007a4:	e7f6      	b.n	8000794 <do_dataread+0x16>
	}
		can_msg_put(p);	// Set it up for tranmission
	
	return;
}
 80007a6:	bc30      	pop	{r4, r5}
	}
	for (i = 0; i < count; i++)
	{
		p->cd.uc[i] = *padd++;
	}
		can_msg_put(p);	// Set it up for tranmission
 80007a8:	e720      	b.n	80005ec <can_msg_put>
 80007aa:	bf00      	nop
 80007ac:	20000860 	.word	0x20000860

080007b0 <addressOK>:
 * @return	: 0 = OK, not zero = bad
 * ************************************************************************************** */
int addressOK(u8* pa)
{
	u32 p;
	if ( ((u32)pa > 0x1FFFE000) && ((u32)pa <= 0x1FFFF80F) ) return 0; // Information block
 80007b0:	f641 020e 	movw	r2, #6158	; 0x180e
 80007b4:	4b0a      	ldr	r3, [pc, #40]	; (80007e0 <addressOK+0x30>)
 80007b6:	4403      	add	r3, r0
 80007b8:	4293      	cmp	r3, r2
 80007ba:	d90b      	bls.n	80007d4 <addressOK+0x24>
	if (  (u32)pa < 0x08000000) return -1;	// Return below any flash
 80007bc:	f1b0 6f00 	cmp.w	r0, #134217728	; 0x8000000
 80007c0:	d30a      	bcc.n	80007d8 <addressOK+0x28>
	p = *(u32*)0x1FFFF7E0;			// Get size of flash in Kbytes
 80007c2:	4b08      	ldr	r3, [pc, #32]	; (80007e4 <addressOK+0x34>)
 80007c4:	681b      	ldr	r3, [r3, #0]
	p = (p << 10); 				// Multiply by 1024 (K)
	if ((u32)pa > p) return -1;		// Above flash for this part
 80007c6:	ebb0 2f83 	cmp.w	r0, r3, lsl #10
 80007ca:	bf8c      	ite	hi
 80007cc:	f04f 30ff 	movhi.w	r0, #4294967295
 80007d0:	2000      	movls	r0, #0
 80007d2:	4770      	bx	lr
 * @return	: 0 = OK, not zero = bad
 * ************************************************************************************** */
int addressOK(u8* pa)
{
	u32 p;
	if ( ((u32)pa > 0x1FFFE000) && ((u32)pa <= 0x1FFFF80F) ) return 0; // Information block
 80007d4:	2000      	movs	r0, #0
 80007d6:	4770      	bx	lr
	if (  (u32)pa < 0x08000000) return -1;	// Return below any flash
 80007d8:	f04f 30ff 	mov.w	r0, #4294967295
	p = *(u32*)0x1FFFF7E0;			// Get size of flash in Kbytes
	p = (p << 10); 				// Multiply by 1024 (K)
	if ((u32)pa > p) return -1;		// Above flash for this part
	return 0;
}
 80007dc:	4770      	bx	lr
 80007de:	bf00      	nop
 80007e0:	e0001fff 	.word	0xe0001fff
 80007e4:	1ffff7e0 	.word	0x1ffff7e0

080007e8 <do_datawrite>:
/* NOTE: The system block is in flash and is not in the flash address range, so copying it as a
memory address will not change it.  (You shouldn't be messing with it anyway!) */
void do_datawrite(u8* pc, s8 count,struct CANRCVBUF* p)
{

	if (count > 8) 			// Return if count out of range
 80007e8:	2908      	cmp	r1, #8
 * @param	: p = CAN msg pointer (for printf & debugging)
 * ************************************************************************************** */
/* NOTE: The system block is in flash and is not in the flash address range, so copying it as a
memory address will not change it.  (You shouldn't be messing with it anyway!) */
void do_datawrite(u8* pc, s8 count,struct CANRCVBUF* p)
{
 80007ea:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 80007ee:	4606      	mov	r6, r0
 80007f0:	460d      	mov	r5, r1
 80007f2:	4617      	mov	r7, r2
 80007f4:	4c6c      	ldr	r4, [pc, #432]	; (80009a8 <do_datawrite+0x1c0>)

	if (count > 8) 			// Return if count out of range
 80007f6:	dd15      	ble.n	8000824 <do_datawrite+0x3c>
 * @param	: cmd = command code
 ******************************************************************************/
static void sendcanCMD(u8 cmd)
{
	
	can_msg_cmd.dlc = 1;
 80007f8:	2301      	movs	r3, #1
 80007fa:	f8c4 3824 	str.w	r3, [r4, #2084]	; 0x824
	can_msg_cmd.cd.uc[0] = cmd;
	can_msg_put(&can_msg_cmd);
 80007fe:	f504 6002 	add.w	r0, r4, #2080	; 0x820
 ******************************************************************************/
static void sendcanCMD(u8 cmd)
{
	
	can_msg_cmd.dlc = 1;
	can_msg_cmd.cd.uc[0] = cmd;
 8000802:	2305      	movs	r3, #5
 8000804:	f884 3828 	strb.w	r3, [r4, #2088]	; 0x828
	can_msg_put(&can_msg_cmd);
 8000808:	f7ff fef0 	bl	80005ec <can_msg_put>
void do_datawrite(u8* pc, s8 count,struct CANRCVBUF* p)
{

	if (count > 8) 			// Return if count out of range
		{sendcanCMD(LDR_NACK);
printf("NACK0: %d %X %d %X %08X %08X\n\r",debugPctr, padd, count, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
 800080c:	68fb      	ldr	r3, [r7, #12]
 800080e:	6822      	ldr	r2, [r4, #0]
 8000810:	9302      	str	r3, [sp, #8]
 8000812:	68bb      	ldr	r3, [r7, #8]
 8000814:	f8d4 1818 	ldr.w	r1, [r4, #2072]	; 0x818
 8000818:	9301      	str	r3, [sp, #4]
 800081a:	687b      	ldr	r3, [r7, #4]
 800081c:	4863      	ldr	r0, [pc, #396]	; (80009ac <do_datawrite+0x1c4>)
 800081e:	9300      	str	r3, [sp, #0]
 8000820:	462b      	mov	r3, r5
 8000822:	e01c      	b.n	800085e <do_datawrite+0x76>
return;}

	// Return = No valid address in place
	if (sw_padd == 0) { err_novalidadd += 1; sendcanCMD(LDR_NACK);
 8000824:	f8d4 3858 	ldr.w	r3, [r4, #2136]	; 0x858
 8000828:	bb03      	cbnz	r3, 800086c <do_datawrite+0x84>
 800082a:	f8d4 385c 	ldr.w	r3, [r4, #2140]	; 0x85c
static void sendcanCMD(u8 cmd)
{
	
	can_msg_cmd.dlc = 1;
	can_msg_cmd.cd.uc[0] = cmd;
	can_msg_put(&can_msg_cmd);
 800082e:	f504 6002 	add.w	r0, r4, #2080	; 0x820
		{sendcanCMD(LDR_NACK);
printf("NACK0: %d %X %d %X %08X %08X\n\r",debugPctr, padd, count, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
return;}

	// Return = No valid address in place
	if (sw_padd == 0) { err_novalidadd += 1; sendcanCMD(LDR_NACK);
 8000832:	3301      	adds	r3, #1
 8000834:	f8c4 385c 	str.w	r3, [r4, #2140]	; 0x85c
 * @param	: cmd = command code
 ******************************************************************************/
static void sendcanCMD(u8 cmd)
{
	
	can_msg_cmd.dlc = 1;
 8000838:	2301      	movs	r3, #1
 800083a:	f8c4 3824 	str.w	r3, [r4, #2084]	; 0x824
	can_msg_cmd.cd.uc[0] = cmd;
 800083e:	2305      	movs	r3, #5
 8000840:	f884 3828 	strb.w	r3, [r4, #2088]	; 0x828
	can_msg_put(&can_msg_cmd);
 8000844:	f7ff fed2 	bl	80005ec <can_msg_put>
printf("NACK0: %d %X %d %X %08X %08X\n\r",debugPctr, padd, count, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
return;}

	// Return = No valid address in place
	if (sw_padd == 0) { err_novalidadd += 1; sendcanCMD(LDR_NACK);
printf("NAC1K: %d %X %d %X %08X %08X\n\r",debugPctr, padd, count, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
 8000848:	68fb      	ldr	r3, [r7, #12]
 800084a:	6822      	ldr	r2, [r4, #0]
 800084c:	9302      	str	r3, [sp, #8]
 800084e:	68bb      	ldr	r3, [r7, #8]
 8000850:	f8d4 1818 	ldr.w	r1, [r4, #2072]	; 0x818
 8000854:	9301      	str	r3, [sp, #4]
 8000856:	687b      	ldr	r3, [r7, #4]
 8000858:	4855      	ldr	r0, [pc, #340]	; (80009b0 <do_datawrite+0x1c8>)
 800085a:	9300      	str	r3, [sp, #0]
 800085c:	462b      	mov	r3, r5
 800085e:	f001 f931 	bl	8001ac4 <tfp_printf>
	{ // Here, not flash address.  Pray that it is a valid address
		copypayload(pc, count);
	}
debugPctr += 1;
	return;
}
 8000862:	b004      	add	sp, #16
 8000864:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
printf("NACK0: %d %X %d %X %08X %08X\n\r",debugPctr, padd, count, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
return;}

	// Return = No valid address in place
	if (sw_padd == 0) { err_novalidadd += 1; sendcanCMD(LDR_NACK);
printf("NAC1K: %d %X %d %X %08X %08X\n\r",debugPctr, padd, count, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
 8000868:	f001 ba20 	b.w	8001cac <USART1_txint_send>
return;}	
	
	/* Is the address is within the flash bounds.  */
	if ( ((u32)padd >= 0x08000000) && ((u32)padd < (u32)flash_hi) ) 
 800086c:	6823      	ldr	r3, [r4, #0]
 800086e:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8000872:	d349      	bcc.n	8000908 <do_datawrite+0x120>
 8000874:	f8d4 2830 	ldr.w	r2, [r4, #2096]	; 0x830
 8000878:	429a      	cmp	r2, r3
 800087a:	d945      	bls.n	8000908 <do_datawrite+0x120>
 800087c:	4681      	mov	r9, r0
			wrblk(p);		// Write RAM buff to flash
			flashblockinit();	// Read in new flash block and init some pointers.
		}

		/* Store one, measly, single, but valuable, byte */
		if (*pc != *padd) // Is new byte different from byte in the flash location?
 800087e:	46a0      	mov	r8, r4
static void writepayloadf1(u8* pc, s8 count,struct CANRCVBUF* p)
{
	while (count > 0)	// Loop through the payload
	{	
		/* Is this address for a different block? */
		if (((u32)padd & ~(flashblocksize - 1)) != (u32)flblkbuff.base)
 8000880:	f8df a134 	ldr.w	sl, [pc, #308]	; 80009b8 <do_datawrite+0x1d0>
 8000884:	1973      	adds	r3, r6, r5
 8000886:	ebc9 0303 	rsb	r3, r9, r3
 * @param	: count = dlc after masking
 * @param	: p = CAN msg pointer (for printf & debugging)
 * ************************************************************************************** */
static void writepayloadf1(u8* pc, s8 count,struct CANRCVBUF* p)
{
	while (count > 0)	// Loop through the payload
 800088a:	b25b      	sxtb	r3, r3
 800088c:	2b00      	cmp	r3, #0
 800088e:	dd66      	ble.n	800095e <do_datawrite+0x176>
	{	
		/* Is this address for a different block? */
		if (((u32)padd & ~(flashblocksize - 1)) != (u32)flblkbuff.base)
 8000890:	f8da 3000 	ldr.w	r3, [sl]
 8000894:	6822      	ldr	r2, [r4, #0]
 8000896:	f8d4 1808 	ldr.w	r1, [r4, #2056]	; 0x808
 800089a:	425b      	negs	r3, r3
 800089c:	4013      	ands	r3, r2
 800089e:	428b      	cmp	r3, r1
 80008a0:	d009      	beq.n	80008b6 <do_datawrite+0xce>
		{ // Here, the load address crossed a flash boundary
printf("padd crossed block boundary: %08X  padd: %08x\n\r",(u32)flblkbuff.base, padd);USART1_txint_send();
 80008a2:	4844      	ldr	r0, [pc, #272]	; (80009b4 <do_datawrite+0x1cc>)
 80008a4:	f001 f90e 	bl	8001ac4 <tfp_printf>
 80008a8:	f001 fa00 	bl	8001cac <USART1_txint_send>
			wrblk(p);		// Write RAM buff to flash
 80008ac:	4638      	mov	r0, r7
 80008ae:	f7ff fea7 	bl	8000600 <wrblk>
			flashblockinit();	// Read in new flash block and init some pointers.
 80008b2:	f7ff fe77 	bl	80005a4 <flashblockinit>
		}

		/* Store one, measly, single, but valuable, byte */
		if (*pc != *padd) // Is new byte different from byte in the flash location?
 80008b6:	6822      	ldr	r2, [r4, #0]
 80008b8:	f899 1000 	ldrb.w	r1, [r9]
 80008bc:	7813      	ldrb	r3, [r2, #0]
 80008be:	4299      	cmp	r1, r3
 80008c0:	d016      	beq.n	80008f0 <do_datawrite+0x108>
		{ // Here, yes.  Flag for writing and mabye even erasing
			ldr_phase |= 0x1;	// Show we are going write flash so don't jump to the app unless commanded
 80008c2:	f8d8 3860 	ldr.w	r3, [r8, #2144]	; 0x860
			flblkbuff.sw |= 0x1;	// Show that we have to write (but may or may not need erase)
			if ( (*(u16*)((u32)padd & ~0x1)) != 0xffff)	// Is the 1/2 word already in an erased condtion?
 80008c6:	f022 0201 	bic.w	r2, r2, #1
		}

		/* Store one, measly, single, but valuable, byte */
		if (*pc != *padd) // Is new byte different from byte in the flash location?
		{ // Here, yes.  Flag for writing and mabye even erasing
			ldr_phase |= 0x1;	// Show we are going write flash so don't jump to the app unless commanded
 80008ca:	f043 0301 	orr.w	r3, r3, #1
 80008ce:	f8c8 3860 	str.w	r3, [r8, #2144]	; 0x860
			flblkbuff.sw |= 0x1;	// Show that we have to write (but may or may not need erase)
 80008d2:	f8b8 3814 	ldrh.w	r3, [r8, #2068]	; 0x814
 80008d6:	f043 0101 	orr.w	r1, r3, #1
 80008da:	f8a8 1814 	strh.w	r1, [r8, #2068]	; 0x814
			if ( (*(u16*)((u32)padd & ~0x1)) != 0xffff)	// Is the 1/2 word already in an erased condtion?
 80008de:	8811      	ldrh	r1, [r2, #0]
 80008e0:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80008e4:	4291      	cmp	r1, r2
				flblkbuff.sw |= 0x2;	// No, show that we have to erase before write
 80008e6:	bf1c      	itt	ne
 80008e8:	f043 0303 	orrne.w	r3, r3, #3
 80008ec:	f8a8 3814 	strhne.w	r3, [r8, #2068]	; 0x814
		}
		*flblkbuff.p++ = *pc++;	// Store this golden byte in the ram block buffer
 80008f0:	f8d4 3810 	ldr.w	r3, [r4, #2064]	; 0x810
 80008f4:	1c5a      	adds	r2, r3, #1
 80008f6:	f8c4 2810 	str.w	r2, [r4, #2064]	; 0x810
 80008fa:	f819 2b01 	ldrb.w	r2, [r9], #1
 80008fe:	701a      	strb	r2, [r3, #0]
		padd++;			// Advance where the next byte would be placed in flash.
 8000900:	6823      	ldr	r3, [r4, #0]
 8000902:	3301      	adds	r3, #1
 8000904:	6023      	str	r3, [r4, #0]
 8000906:	e7bd      	b.n	8000884 <do_datawrite+0x9c>
*/
const u8 table[16] = {2,4,4,8,2,2,2,2,2,4,4,4,2,2,2,2};
static void copypayload(u8* pc, s8 count)
{
	u32 x;
	if (count < 1 ) return;
 8000908:	2d00      	cmp	r5, #0
 800090a:	dd28      	ble.n	800095e <do_datawrite+0x176>
	if (count > 8) count = 8;	// JIC	
	count -= 1; // (count = 0 - 7)
 800090c:	3d01      	subs	r5, #1

	while (count > 0)	// Loop through the payload
	{
		if ( ((count & 0x1) == 0) || ( ((u32)(padd) & 0x1) != 0) ) // Odd byte count and/or odd address requires byte moves
 800090e:	4f26      	ldr	r7, [pc, #152]	; (80009a8 <do_datawrite+0x1c0>)
		}
		else
		{ // Here both count and address are even 
			x = ( ( ( (u32)padd << 1) & 0xc) | ((count >> 1) & 0x3) );
			x &= 0x0f; 	// jic!
			switch (table[x])
 8000910:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 80009bc <do_datawrite+0x1d4>
static void copypayload(u8* pc, s8 count)
{
	u32 x;
	if (count < 1 ) return;
	if (count > 8) count = 8;	// JIC	
	count -= 1; // (count = 0 - 7)
 8000914:	b26d      	sxtb	r5, r5

	while (count > 0)	// Loop through the payload
 8000916:	2d00      	cmp	r5, #0
 8000918:	dd21      	ble.n	800095e <do_datawrite+0x176>
	{
		if ( ((count & 0x1) == 0) || ( ((u32)(padd) & 0x1) != 0) ) // Odd byte count and/or odd address requires byte moves
 800091a:	b2eb      	uxtb	r3, r5
 800091c:	07d8      	lsls	r0, r3, #31
 800091e:	d526      	bpl.n	800096e <do_datawrite+0x186>
 8000920:	6822      	ldr	r2, [r4, #0]
 8000922:	f8df 9084 	ldr.w	r9, [pc, #132]	; 80009a8 <do_datawrite+0x1c0>
 8000926:	07d1      	lsls	r1, r2, #31
 8000928:	d421      	bmi.n	800096e <do_datawrite+0x186>
		}
		else
		{ // Here both count and address are even 
			x = ( ( ( (u32)padd << 1) & 0xc) | ((count >> 1) & 0x3) );
			x &= 0x0f; 	// jic!
			switch (table[x])
 800092a:	0051      	lsls	r1, r2, #1
 800092c:	f001 010c 	and.w	r1, r1, #12
 8000930:	ea41 0165 	orr.w	r1, r1, r5, asr #1
 8000934:	f818 1001 	ldrb.w	r1, [r8, r1]
 8000938:	2904      	cmp	r1, #4
 800093a:	d02b      	beq.n	8000994 <do_datawrite+0x1ac>
 800093c:	2908      	cmp	r1, #8
 800093e:	d11f      	bne.n	8000980 <do_datawrite+0x198>
			case 4: // Move words (4 bytes)
				*(u32*)padd = mv4(pc); padd +=4; pc +=4; count -= 4;
				break;

			case 8: // Move double word (8 bytes)
				*(u32*)padd = mv4(pc); padd +=4; pc +=4; // No need to adjust 'count' as we 'return'
 8000940:	4630      	mov	r0, r6
 8000942:	f7ff ff1a 	bl	800077a <mv4>
 8000946:	4613      	mov	r3, r2
 8000948:	f843 0b04 	str.w	r0, [r3], #4
				*(u32*)padd = mv4(pc); padd +=4; pc +=4;
 800094c:	1d30      	adds	r0, r6, #4
			case 4: // Move words (4 bytes)
				*(u32*)padd = mv4(pc); padd +=4; pc +=4; count -= 4;
				break;

			case 8: // Move double word (8 bytes)
				*(u32*)padd = mv4(pc); padd +=4; pc +=4; // No need to adjust 'count' as we 'return'
 800094e:	f8c9 3000 	str.w	r3, [r9]
				*(u32*)padd = mv4(pc); padd +=4; pc +=4;
 8000952:	f7ff ff12 	bl	800077a <mv4>
 8000956:	6050      	str	r0, [r2, #4]
 8000958:	3208      	adds	r2, #8
 800095a:	f8c9 2000 	str.w	r2, [r9]
	}
	else
	{ // Here, not flash address.  Pray that it is a valid address
		copypayload(pc, count);
	}
debugPctr += 1;
 800095e:	f8d4 3818 	ldr.w	r3, [r4, #2072]	; 0x818
 8000962:	3301      	adds	r3, #1
 8000964:	f8c4 3818 	str.w	r3, [r4, #2072]	; 0x818
	return;
}
 8000968:	b004      	add	sp, #16
 800096a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

	while (count > 0)	// Loop through the payload
	{
		if ( ((count & 0x1) == 0) || ( ((u32)(padd) & 0x1) != 0) ) // Odd byte count and/or odd address requires byte moves
		{ // Here, if either are odd, then we must move one byte at a time.
			*padd++ = *pc++; count -= 1;
 800096e:	6822      	ldr	r2, [r4, #0]
 8000970:	1e5d      	subs	r5, r3, #1
 8000972:	1c51      	adds	r1, r2, #1
 8000974:	6021      	str	r1, [r4, #0]
 8000976:	7831      	ldrb	r1, [r6, #0]
 8000978:	b26d      	sxtb	r5, r5
 800097a:	7011      	strb	r1, [r2, #0]
 800097c:	3601      	adds	r6, #1
 800097e:	e7ca      	b.n	8000916 <do_datawrite+0x12e>
		}
		else
		{ // Here both count and address are even 
			x = ( ( ( (u32)padd << 1) & 0xc) | ((count >> 1) & 0x3) );
			x &= 0x0f; 	// jic!
			switch (table[x])
 8000980:	2902      	cmp	r1, #2
 8000982:	d1c8      	bne.n	8000916 <do_datawrite+0x12e>
			{
			case 2:	// Move 1/2 words (2 bytes)
				*(u8*)padd = mv2(pc); padd +=2; pc +=2; count -= 2;
 8000984:	f816 1b02 	ldrb.w	r1, [r6], #2
 8000988:	1e9d      	subs	r5, r3, #2
 800098a:	7011      	strb	r1, [r2, #0]
 800098c:	683a      	ldr	r2, [r7, #0]
 800098e:	3202      	adds	r2, #2
 8000990:	603a      	str	r2, [r7, #0]
 8000992:	e007      	b.n	80009a4 <do_datawrite+0x1bc>
				break;

			case 4: // Move words (4 bytes)
				*(u32*)padd = mv4(pc); padd +=4; pc +=4; count -= 4;
 8000994:	4630      	mov	r0, r6
 8000996:	f7ff fef0 	bl	800077a <mv4>
 800099a:	f842 0b04 	str.w	r0, [r2], #4
 800099e:	603a      	str	r2, [r7, #0]
 80009a0:	3604      	adds	r6, #4
 80009a2:	1f1d      	subs	r5, r3, #4
 80009a4:	b26d      	sxtb	r5, r5
 80009a6:	e7b6      	b.n	8000916 <do_datawrite+0x12e>
 80009a8:	20000860 	.word	0x20000860
 80009ac:	08003a52 	.word	0x08003a52
 80009b0:	08003a71 	.word	0x08003a71
 80009b4:	08003a90 	.word	0x08003a90
 80009b8:	20000004 	.word	0x20000004
 80009bc:	08003c78 	.word	0x08003c78

080009c0 <do_wrblk>:
/* **************************************************************************************
 * void do_wrblk(struct CANRCVBUF* pcan);
 * @brief	: Write RAM buffer out to flash
 * ************************************************************************************** */
void do_wrblk(struct CANRCVBUF* pcan)
{
 80009c0:	b508      	push	{r3, lr}
	wrblk(pcan);	// Write block to flash
 80009c2:	f7ff fe1d 	bl	8000600 <wrblk>

	/* Let PC know the flash write is complete. Send status in payload. */
	can_msg_cmd.dlc = 3;
 80009c6:	4806      	ldr	r0, [pc, #24]	; (80009e0 <do_wrblk+0x20>)
 80009c8:	2303      	movs	r3, #3
 80009ca:	f8c0 3824 	str.w	r3, [r0, #2084]	; 0x824
	can_msg_cmd.cd.uc[0] = LDR_WRBLK;
 80009ce:	2307      	movs	r3, #7
 80009d0:	f880 3828 	strb.w	r3, [r0, #2088]	; 0x828
	can_msg_put(&can_msg_cmd);		// Place in CAN output buffer

	return;
}
 80009d4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	wrblk(pcan);	// Write block to flash

	/* Let PC know the flash write is complete. Send status in payload. */
	can_msg_cmd.dlc = 3;
	can_msg_cmd.cd.uc[0] = LDR_WRBLK;
	can_msg_put(&can_msg_cmd);		// Place in CAN output buffer
 80009d8:	f500 6002 	add.w	r0, r0, #2080	; 0x820
 80009dc:	e606      	b.n	80005ec <can_msg_put>
 80009de:	bf00      	nop
 80009e0:	20000860 	.word	0x20000860

080009e4 <do_crc>:
 * void do_crc(struct CANRCVBUF* p);
 * @brief	: Compute CRC and send it back
 * @param	: Point to message buffer holding the precious command
 * ************************************************************************************** */
void do_crc(struct CANRCVBUF* p)
{
 80009e4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	u32 pstart;
	u32 count;
	u32 crc32;

	/* Check that the payload is the correct size: start|end addresses */
	if ((p->dlc & 0x0f) != 8)
 80009e6:	6841      	ldr	r1, [r0, #4]
 * void do_crc(struct CANRCVBUF* p);
 * @brief	: Compute CRC and send it back
 * @param	: Point to message buffer holding the precious command
 * ************************************************************************************** */
void do_crc(struct CANRCVBUF* p)
{
 80009e8:	4604      	mov	r4, r0
	u32 pstart;
	u32 count;
	u32 crc32;

	/* Check that the payload is the correct size: start|end addresses */
	if ((p->dlc & 0x0f) != 8)
 80009ea:	f001 070f 	and.w	r7, r1, #15
 80009ee:	2f08      	cmp	r7, #8
 80009f0:	d003      	beq.n	80009fa <do_crc+0x16>
	{ // Send NACK
printf("Send NACK: dlc not 8: %d\n\r",p->dlc);USART1_txint_send();
 80009f2:	4826      	ldr	r0, [pc, #152]	; (8000a8c <do_crc+0xa8>)
 80009f4:	f001 f866 	bl	8001ac4 <tfp_printf>
 80009f8:	e018      	b.n	8000a2c <do_crc+0x48>
	pstart = p->cd.ui[1];	// Address to start

	
	/* Check that we are dealing with valid start address and count */
	extern u8* __appoffset;	// Origin of application define in .ld file
	if ((pstart < (u32)(&__appoffset)) || ((u32)(&__appoffset + count) > (u32)flash_hi)) 
 80009fa:	4a25      	ldr	r2, [pc, #148]	; (8000a90 <do_crc+0xac>)
	{ // Send NACK
printf("Send NACK: dlc not 8: %d\n\r",p->dlc);USART1_txint_send();
		 return;
	}
	/* Get start and end addresses from payload */
	count  = (p->cd.ui[0] >> 8);		// Number of bytes to check
 80009fc:	6885      	ldr	r5, [r0, #8]
	count  &= 0x000fffff; 	// Limit the size
	pstart = p->cd.ui[1];	// Address to start
 80009fe:	68c6      	ldr	r6, [r0, #12]
printf("Send NACK: dlc not 8: %d\n\r",p->dlc);USART1_txint_send();
		 return;
	}
	/* Get start and end addresses from payload */
	count  = (p->cd.ui[0] >> 8);		// Number of bytes to check
	count  &= 0x000fffff; 	// Limit the size
 8000a00:	f3c5 2513 	ubfx	r5, r5, #8, #20
	pstart = p->cd.ui[1];	// Address to start

	
	/* Check that we are dealing with valid start address and count */
	extern u8* __appoffset;	// Origin of application define in .ld file
	if ((pstart < (u32)(&__appoffset)) || ((u32)(&__appoffset + count) > (u32)flash_hi)) 
 8000a04:	4296      	cmp	r6, r2
 8000a06:	4696      	mov	lr, r2
 8000a08:	ea4f 0385 	mov.w	r3, r5, lsl #2
 8000a0c:	4921      	ldr	r1, [pc, #132]	; (8000a94 <do_crc+0xb0>)
 8000a0e:	d304      	bcc.n	8000a1a <do_crc+0x36>
 8000a10:	f8d1 0830 	ldr.w	r0, [r1, #2096]	; 0x830
 8000a14:	441a      	add	r2, r3
 8000a16:	4290      	cmp	r0, r2
 8000a18:	d20d      	bcs.n	8000a36 <do_crc+0x52>
	{ // Send NACK
printf("Send NACK start addr out of range: %08X %X %08X %08X\n\r",pstart, count,(unsigned int)(&__appoffset + count), flash_hi);USART1_txint_send();
 8000a1a:	f8d1 2830 	ldr.w	r2, [r1, #2096]	; 0x830
 8000a1e:	4473      	add	r3, lr
 8000a20:	9200      	str	r2, [sp, #0]
 8000a22:	4631      	mov	r1, r6
 8000a24:	462a      	mov	r2, r5
 8000a26:	481c      	ldr	r0, [pc, #112]	; (8000a98 <do_crc+0xb4>)
 8000a28:	f001 f84c 	bl	8001ac4 <tfp_printf>
	p->cd.ui[1] = crc32;
	p->cd.uc[0] = LDR_CRC;
	can_msg_put(p);		// Place in CAN output buffer

	return;
}
 8000a2c:	b003      	add	sp, #12
 8000a2e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	
	/* Check that we are dealing with valid start address and count */
	extern u8* __appoffset;	// Origin of application define in .ld file
	if ((pstart < (u32)(&__appoffset)) || ((u32)(&__appoffset + count) > (u32)flash_hi)) 
	{ // Send NACK
printf("Send NACK start addr out of range: %08X %X %08X %08X\n\r",pstart, count,(unsigned int)(&__appoffset + count), flash_hi);USART1_txint_send();
 8000a32:	f001 b93b 	b.w	8001cac <USART1_txint_send>
		return;
	}

if ( (pstart < (u32)0x08004000) ||  ( (pstart + count) > (u32)0x08100000) )
 8000a36:	4b19      	ldr	r3, [pc, #100]	; (8000a9c <do_crc+0xb8>)
 8000a38:	429e      	cmp	r6, r3
 8000a3a:	d903      	bls.n	8000a44 <do_crc+0x60>
 8000a3c:	19aa      	adds	r2, r5, r6
 8000a3e:	f1b2 6f01 	cmp.w	r2, #135266304	; 0x8100000
 8000a42:	d905      	bls.n	8000a50 <do_crc+0x6c>
   {printf("Hard Coded address check out-of-range:"); return;}
 8000a44:	4816      	ldr	r0, [pc, #88]	; (8000aa0 <do_crc+0xbc>)
	p->cd.ui[1] = crc32;
	p->cd.uc[0] = LDR_CRC;
	can_msg_put(p);		// Place in CAN output buffer

	return;
}
 8000a46:	b003      	add	sp, #12
 8000a48:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
printf("Send NACK start addr out of range: %08X %X %08X %08X\n\r",pstart, count,(unsigned int)(&__appoffset + count), flash_hi);USART1_txint_send();
		return;
	}

if ( (pstart < (u32)0x08004000) ||  ( (pstart + count) > (u32)0x08100000) )
   {printf("Hard Coded address check out-of-range:"); return;}
 8000a4c:	f001 b83a 	b.w	8001ac4 <tfp_printf>

printf("rc_crc32: %08X %08X %08X\n\r",pstart, (pstart+count), count);USART1_txint_send();
 8000a50:	462b      	mov	r3, r5
 8000a52:	4631      	mov	r1, r6
 8000a54:	4813      	ldr	r0, [pc, #76]	; (8000aa4 <do_crc+0xc0>)
 8000a56:	f001 f835 	bl	8001ac4 <tfp_printf>
 8000a5a:	f001 f927 	bl	8001cac <USART1_txint_send>
	/* Compute the crc and place in msg to be returned. */
	crc32 = rc_crc32((unsigned char*)pstart, count );
 8000a5e:	4629      	mov	r1, r5
 8000a60:	4630      	mov	r0, r6
 8000a62:	f001 fb3d 	bl	80020e0 <rc_crc32>
printf("Send crc-32: %08X\n\r",crc32);USART1_txint_send();USART1_txint_send();
 8000a66:	4601      	mov	r1, r0
if ( (pstart < (u32)0x08004000) ||  ( (pstart + count) > (u32)0x08100000) )
   {printf("Hard Coded address check out-of-range:"); return;}

printf("rc_crc32: %08X %08X %08X\n\r",pstart, (pstart+count), count);USART1_txint_send();
	/* Compute the crc and place in msg to be returned. */
	crc32 = rc_crc32((unsigned char*)pstart, count );
 8000a68:	4605      	mov	r5, r0
printf("Send crc-32: %08X\n\r",crc32);USART1_txint_send();USART1_txint_send();
 8000a6a:	480f      	ldr	r0, [pc, #60]	; (8000aa8 <do_crc+0xc4>)
 8000a6c:	f001 f82a 	bl	8001ac4 <tfp_printf>
 8000a70:	f001 f91c 	bl	8001cac <USART1_txint_send>
 8000a74:	f001 f91a 	bl	8001cac <USART1_txint_send>

	// Return msg with crc
	p->dlc = 8;
	p->cd.ui[1] = crc32;
	p->cd.uc[0] = LDR_CRC;
	can_msg_put(p);		// Place in CAN output buffer
 8000a78:	4620      	mov	r0, r4
printf("Send crc-32: %08X\n\r",crc32);USART1_txint_send();USART1_txint_send();

	// Return msg with crc
	p->dlc = 8;
	p->cd.ui[1] = crc32;
	p->cd.uc[0] = LDR_CRC;
 8000a7a:	2303      	movs	r3, #3
	/* Compute the crc and place in msg to be returned. */
	crc32 = rc_crc32((unsigned char*)pstart, count );
printf("Send crc-32: %08X\n\r",crc32);USART1_txint_send();USART1_txint_send();

	// Return msg with crc
	p->dlc = 8;
 8000a7c:	6067      	str	r7, [r4, #4]
	p->cd.ui[1] = crc32;
 8000a7e:	60e5      	str	r5, [r4, #12]
	p->cd.uc[0] = LDR_CRC;
 8000a80:	7223      	strb	r3, [r4, #8]
	can_msg_put(p);		// Place in CAN output buffer

	return;
}
 8000a82:	b003      	add	sp, #12
 8000a84:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}

	// Return msg with crc
	p->dlc = 8;
	p->cd.ui[1] = crc32;
	p->cd.uc[0] = LDR_CRC;
	can_msg_put(p);		// Place in CAN output buffer
 8000a88:	e5b0      	b.n	80005ec <can_msg_put>
 8000a8a:	bf00      	nop
 8000a8c:	08003ac0 	.word	0x08003ac0
 8000a90:	08005000 	.word	0x08005000
 8000a94:	20000860 	.word	0x20000860
 8000a98:	08003adb 	.word	0x08003adb
 8000a9c:	08003fff 	.word	0x08003fff
 8000aa0:	08003b12 	.word	0x08003b12
 8000aa4:	08003b39 	.word	0x08003b39
 8000aa8:	08003b54 	.word	0x08003b54

08000aac <do_set_addr>:
 * void do_set_addr(struct CANRCVBUF* p);
 * @brief	: Check payload and send response as two bytes (command + ACK/NACK)
 * @param	: Point to message buffer holding the precious command
 * ************************************************************************************** */
void do_set_addr(struct CANRCVBUF* p)
{
 8000aac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u8* ptmp;

	if ((p->dlc & 0x0f) == 5) // Payload size: cmd byte + 4 byte address
 8000aae:	6843      	ldr	r3, [r0, #4]
 * void do_set_addr(struct CANRCVBUF* p);
 * @brief	: Check payload and send response as two bytes (command + ACK/NACK)
 * @param	: Point to message buffer holding the precious command
 * ************************************************************************************** */
void do_set_addr(struct CANRCVBUF* p)
{
 8000ab0:	4604      	mov	r4, r0
	u8* ptmp;

	if ((p->dlc & 0x0f) == 5) // Payload size: cmd byte + 4 byte address
 8000ab2:	f003 030f 	and.w	r3, r3, #15
 8000ab6:	2b05      	cmp	r3, #5
 8000ab8:	4d15      	ldr	r5, [pc, #84]	; (8000b10 <do_set_addr+0x64>)
 8000aba:	d11d      	bne.n	8000af8 <do_set_addr+0x4c>
	{ // 
ldr_phase |= 0x1; // Stop ldr.c from jumping to the app.
 8000abc:	f8d5 3860 	ldr.w	r3, [r5, #2144]	; 0x860
		ptmp = (u8*)mv4(&p->cd.uc[1]);	// Extract address from payload
 8000ac0:	3009      	adds	r0, #9
{
	u8* ptmp;

	if ((p->dlc & 0x0f) == 5) // Payload size: cmd byte + 4 byte address
	{ // 
ldr_phase |= 0x1; // Stop ldr.c from jumping to the app.
 8000ac2:	f043 0301 	orr.w	r3, r3, #1
 8000ac6:	f8c5 3860 	str.w	r3, [r5, #2144]	; 0x860
		ptmp = (u8*)mv4(&p->cd.uc[1]);	// Extract address from payload
 8000aca:	f7ff fe56 	bl	800077a <mv4>
 8000ace:	4601      	mov	r1, r0
		if (addressOK(ptmp) == 0)	// Valid STM32 address?
 8000ad0:	f7ff fe6e 	bl	80007b0 <addressOK>
 8000ad4:	4606      	mov	r6, r0
 8000ad6:	b968      	cbnz	r0, 8000af4 <do_set_addr+0x48>
		{ // Here, yes.  It shouldn't cause a memory fault
			p->cd.uc[1] = LDR_ACK;	// Show it passed all checks
 8000ad8:	2704      	movs	r7, #4
			padd = ptmp;		// Save working pointer
			padd_start = padd;	// Save start
			sw_padd = 1;		// Show it was "recently set"			
 8000ada:	2301      	movs	r3, #1
	{ // 
ldr_phase |= 0x1; // Stop ldr.c from jumping to the app.
		ptmp = (u8*)mv4(&p->cd.uc[1]);	// Extract address from payload
		if (addressOK(ptmp) == 0)	// Valid STM32 address?
		{ // Here, yes.  It shouldn't cause a memory fault
			p->cd.uc[1] = LDR_ACK;	// Show it passed all checks
 8000adc:	7267      	strb	r7, [r4, #9]
			padd = ptmp;		// Save working pointer
 8000ade:	6029      	str	r1, [r5, #0]
			padd_start = padd;	// Save start
 8000ae0:	f8c5 1864 	str.w	r1, [r5, #2148]	; 0x864
			sw_padd = 1;		// Show it was "recently set"			
 8000ae4:	f8c5 3858 	str.w	r3, [r5, #2136]	; 0x858
			flashblockinit();	//Load block that padd points to into RAM.
 8000ae8:	f7ff fd5c 	bl	80005a4 <flashblockinit>
			p->cd.uc[1] = LDR_ACK;
 8000aec:	7267      	strb	r7, [r4, #9]
debugPctr = 0;
 8000aee:	f8c5 6818 	str.w	r6, [r5, #2072]	; 0x818
 8000af2:	e006      	b.n	8000b02 <do_set_addr+0x56>
		}
		else
			p->cd.uc[1] = LDR_ADDR_OOB; // Failed the address check					
 8000af4:	230c      	movs	r3, #12
 8000af6:	e003      	b.n	8000b00 <do_set_addr+0x54>
	}
	else
	{ // Here, dlc size wrong
		sw_padd = 0;	// Don't be storing stuff in bogus addresses
 8000af8:	2300      	movs	r3, #0
 8000afa:	f8c5 3858 	str.w	r3, [r5, #2136]	; 0x858
		p->cd.uc[1] = LDR_DLC_ERR;			
 8000afe:	230d      	movs	r3, #13
 8000b00:	7263      	strb	r3, [r4, #9]
	}
	/* Send response */
	p->dlc = 2;
 8000b02:	2302      	movs	r3, #2
 8000b04:	6063      	str	r3, [r4, #4]
	can_msg_put(p);	// Place in CAN output buffer
 8000b06:	4620      	mov	r0, r4
	return;
}
 8000b08:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		sw_padd = 0;	// Don't be storing stuff in bogus addresses
		p->cd.uc[1] = LDR_DLC_ERR;			
	}
	/* Send response */
	p->dlc = 2;
	can_msg_put(p);	// Place in CAN output buffer
 8000b0c:	e56e      	b.n	80005ec <can_msg_put>
 8000b0e:	bf00      	nop
 8000b10:	20000860 	.word	0x20000860

08000b14 <do_flashsize>:
 * void do_flashsize(struct CANRCVBUF* p);
 * @brief	: Send flashsize
 * @param	: Point to message buffer holding the imperial command
 * ************************************************************************************** */
void do_flashsize(struct CANRCVBUF* p)
{
 8000b14:	b513      	push	{r0, r1, r4, lr}
 8000b16:	4604      	mov	r4, r0
	p->dlc = 3;	// Command plus short
 8000b18:	2303      	movs	r3, #3
 8000b1a:	6043      	str	r3, [r0, #4]
	p->cd.uc[1] = flashblocksize;	
 8000b1c:	4b09      	ldr	r3, [pc, #36]	; (8000b44 <do_flashsize+0x30>)
	p->cd.uc[2] = flashblocksize >> 8;
printf("X: flashblocksize: %X %X %X %X\n\r",flashblocksize, p->cd.uc[0],p->cd.uc[1],p->cd.uc[2]);USART1_txint_send();
 8000b1e:	7a02      	ldrb	r2, [r0, #8]
 * @param	: Point to message buffer holding the imperial command
 * ************************************************************************************** */
void do_flashsize(struct CANRCVBUF* p)
{
	p->dlc = 3;	// Command plus short
	p->cd.uc[1] = flashblocksize;	
 8000b20:	6819      	ldr	r1, [r3, #0]
	p->cd.uc[2] = flashblocksize >> 8;
 8000b22:	0a0b      	lsrs	r3, r1, #8
 8000b24:	7283      	strb	r3, [r0, #10]
printf("X: flashblocksize: %X %X %X %X\n\r",flashblocksize, p->cd.uc[0],p->cd.uc[1],p->cd.uc[2]);USART1_txint_send();
 8000b26:	b2db      	uxtb	r3, r3
 * @param	: Point to message buffer holding the imperial command
 * ************************************************************************************** */
void do_flashsize(struct CANRCVBUF* p)
{
	p->dlc = 3;	// Command plus short
	p->cd.uc[1] = flashblocksize;	
 8000b28:	7241      	strb	r1, [r0, #9]
	p->cd.uc[2] = flashblocksize >> 8;
printf("X: flashblocksize: %X %X %X %X\n\r",flashblocksize, p->cd.uc[0],p->cd.uc[1],p->cd.uc[2]);USART1_txint_send();
 8000b2a:	9300      	str	r3, [sp, #0]
 8000b2c:	4806      	ldr	r0, [pc, #24]	; (8000b48 <do_flashsize+0x34>)
 8000b2e:	b2cb      	uxtb	r3, r1
 8000b30:	f000 ffc8 	bl	8001ac4 <tfp_printf>
 8000b34:	f001 f8ba 	bl	8001cac <USART1_txint_send>
	can_msg_put(p);	// Place in CAN output buffer
 8000b38:	4620      	mov	r0, r4
	return;
}
 8000b3a:	b002      	add	sp, #8
 8000b3c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
{
	p->dlc = 3;	// Command plus short
	p->cd.uc[1] = flashblocksize;	
	p->cd.uc[2] = flashblocksize >> 8;
printf("X: flashblocksize: %X %X %X %X\n\r",flashblocksize, p->cd.uc[0],p->cd.uc[1],p->cd.uc[2]);USART1_txint_send();
	can_msg_put(p);	// Place in CAN output buffer
 8000b40:	e554      	b.n	80005ec <can_msg_put>
 8000b42:	bf00      	nop
 8000b44:	20000004 	.word	0x20000004
 8000b48:	08003b68 	.word	0x08003b68

08000b4c <do_rd4>:
 * void do_rd4(struct CANRCVBUF* p);
 * @brief	: Send 4 bytes from starting address contained in payload
 * @param	: Point to message buffer holding the imperial command
 * ************************************************************************************** */
void do_rd4(struct CANRCVBUF* p)
{
 8000b4c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 8000b4e:	4604      	mov	r4, r0
	u8* rdaddr = (u8*)mv4(&p->cd.uc[1]); // Get bytes 1-4 into a word
 8000b50:	3009      	adds	r0, #9
 8000b52:	f7ff fe12 	bl	800077a <mv4>
	p->dlc = 5;	// Command plus char*
	p->cd.uc[1] = *rdaddr++;
	p->cd.uc[2] = *rdaddr++;
	p->cd.uc[3] = *rdaddr++;
	p->cd.uc[4] = *rdaddr;
 8000b56:	4601      	mov	r1, r0
 * @param	: Point to message buffer holding the imperial command
 * ************************************************************************************** */
void do_rd4(struct CANRCVBUF* p)
{
	u8* rdaddr = (u8*)mv4(&p->cd.uc[1]); // Get bytes 1-4 into a word
	p->dlc = 5;	// Command plus char*
 8000b58:	2305      	movs	r3, #5
 8000b5a:	6063      	str	r3, [r4, #4]
	p->cd.uc[1] = *rdaddr++;
 8000b5c:	7803      	ldrb	r3, [r0, #0]
	p->cd.uc[2] = *rdaddr++;
	p->cd.uc[3] = *rdaddr++;
	p->cd.uc[4] = *rdaddr;
printf("R4: read addr: %X %X %X %X %X %X\n\r",(u32)rdaddr, p->cd.uc[0],p->cd.uc[1],p->cd.uc[2],p->cd.uc[3],p->cd.uc[4]);USART1_txint_send();
 8000b5e:	7a22      	ldrb	r2, [r4, #8]
 * ************************************************************************************** */
void do_rd4(struct CANRCVBUF* p)
{
	u8* rdaddr = (u8*)mv4(&p->cd.uc[1]); // Get bytes 1-4 into a word
	p->dlc = 5;	// Command plus char*
	p->cd.uc[1] = *rdaddr++;
 8000b60:	7263      	strb	r3, [r4, #9]
	p->cd.uc[2] = *rdaddr++;
 8000b62:	7845      	ldrb	r5, [r0, #1]
 8000b64:	72a5      	strb	r5, [r4, #10]
	p->cd.uc[3] = *rdaddr++;
 8000b66:	7886      	ldrb	r6, [r0, #2]
 8000b68:	72e6      	strb	r6, [r4, #11]
	p->cd.uc[4] = *rdaddr;
 8000b6a:	f811 0f03 	ldrb.w	r0, [r1, #3]!
printf("R4: read addr: %X %X %X %X %X %X\n\r",(u32)rdaddr, p->cd.uc[0],p->cd.uc[1],p->cd.uc[2],p->cd.uc[3],p->cd.uc[4]);USART1_txint_send();
 8000b6e:	e88d 0060 	stmia.w	sp, {r5, r6}
	u8* rdaddr = (u8*)mv4(&p->cd.uc[1]); // Get bytes 1-4 into a word
	p->dlc = 5;	// Command plus char*
	p->cd.uc[1] = *rdaddr++;
	p->cd.uc[2] = *rdaddr++;
	p->cd.uc[3] = *rdaddr++;
	p->cd.uc[4] = *rdaddr;
 8000b72:	7320      	strb	r0, [r4, #12]
printf("R4: read addr: %X %X %X %X %X %X\n\r",(u32)rdaddr, p->cd.uc[0],p->cd.uc[1],p->cd.uc[2],p->cd.uc[3],p->cd.uc[4]);USART1_txint_send();
 8000b74:	9002      	str	r0, [sp, #8]
 8000b76:	4805      	ldr	r0, [pc, #20]	; (8000b8c <do_rd4+0x40>)
 8000b78:	f000 ffa4 	bl	8001ac4 <tfp_printf>
 8000b7c:	f001 f896 	bl	8001cac <USART1_txint_send>
	can_msg_put(p);	// Place in CAN output buffer
 8000b80:	4620      	mov	r0, r4
	return;
}
 8000b82:	b004      	add	sp, #16
 8000b84:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	p->cd.uc[1] = *rdaddr++;
	p->cd.uc[2] = *rdaddr++;
	p->cd.uc[3] = *rdaddr++;
	p->cd.uc[4] = *rdaddr;
printf("R4: read addr: %X %X %X %X %X %X\n\r",(u32)rdaddr, p->cd.uc[0],p->cd.uc[1],p->cd.uc[2],p->cd.uc[3],p->cd.uc[4]);USART1_txint_send();
	can_msg_put(p);	// Place in CAN output buffer
 8000b88:	e530      	b.n	80005ec <can_msg_put>
 8000b8a:	bf00      	nop
 8000b8c:	08003b89 	.word	0x08003b89

08000b90 <do_getfromdaddress>:
 * @brief	: Return msg with 4 bytes in payload uc[1-4] from address d
 * @param	: p = pointer to message buffer holding the imperial command
 * @param	: rdaddr = address to use 
 * ************************************************************************************** */
void do_getfromdaddress(struct CANRCVBUF* p, u8* rdaddr)
{
 8000b90:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8000b92:	4604      	mov	r4, r0
	if (addressOK(rdaddr) != 0)
 8000b94:	4608      	mov	r0, r1
 8000b96:	f7ff fe0b 	bl	80007b0 <addressOK>
 8000b9a:	b138      	cbz	r0, 8000bac <do_getfromdaddress+0x1c>
	{printf("do_getfromdaddress: addr not OK: %08X\n\r",rdaddr);USART1_txint_send(); return;}
 8000b9c:	480f      	ldr	r0, [pc, #60]	; (8000bdc <do_getfromdaddress+0x4c>)
 8000b9e:	f000 ff91 	bl	8001ac4 <tfp_printf>
	p->cd.uc[3] = *rdaddr++;
	p->cd.uc[4] = *rdaddr;
printf("GETADDR: read addr: %X %X %X %X %X\n\r", p->cd.uc[0],p->cd.uc[1],p->cd.uc[2],p->cd.uc[3],p->cd.uc[4]);USART1_txint_send();
	can_msg_put(p);	// Place in CAN output buffer
	return;
}
 8000ba2:	b003      	add	sp, #12
 8000ba4:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 * @param	: rdaddr = address to use 
 * ************************************************************************************** */
void do_getfromdaddress(struct CANRCVBUF* p, u8* rdaddr)
{
	if (addressOK(rdaddr) != 0)
	{printf("do_getfromdaddress: addr not OK: %08X\n\r",rdaddr);USART1_txint_send(); return;}
 8000ba8:	f001 b880 	b.w	8001cac <USART1_txint_send>

	p->dlc = 5;	// Command plus addr
 8000bac:	2305      	movs	r3, #5
 8000bae:	6063      	str	r3, [r4, #4]
	p->cd.uc[1] = *rdaddr++;
 8000bb0:	780a      	ldrb	r2, [r1, #0]
 8000bb2:	7262      	strb	r2, [r4, #9]
	p->cd.uc[2] = *rdaddr++;
 8000bb4:	784b      	ldrb	r3, [r1, #1]
 8000bb6:	72a3      	strb	r3, [r4, #10]
	p->cd.uc[3] = *rdaddr++;
 8000bb8:	7888      	ldrb	r0, [r1, #2]
 8000bba:	72e0      	strb	r0, [r4, #11]
	p->cd.uc[4] = *rdaddr;
 8000bbc:	78cd      	ldrb	r5, [r1, #3]
printf("GETADDR: read addr: %X %X %X %X %X\n\r", p->cd.uc[0],p->cd.uc[1],p->cd.uc[2],p->cd.uc[3],p->cd.uc[4]);USART1_txint_send();
 8000bbe:	7a21      	ldrb	r1, [r4, #8]
 8000bc0:	e88d 0021 	stmia.w	sp, {r0, r5}

	p->dlc = 5;	// Command plus addr
	p->cd.uc[1] = *rdaddr++;
	p->cd.uc[2] = *rdaddr++;
	p->cd.uc[3] = *rdaddr++;
	p->cd.uc[4] = *rdaddr;
 8000bc4:	7325      	strb	r5, [r4, #12]
printf("GETADDR: read addr: %X %X %X %X %X\n\r", p->cd.uc[0],p->cd.uc[1],p->cd.uc[2],p->cd.uc[3],p->cd.uc[4]);USART1_txint_send();
 8000bc6:	4806      	ldr	r0, [pc, #24]	; (8000be0 <do_getfromdaddress+0x50>)
 8000bc8:	f000 ff7c 	bl	8001ac4 <tfp_printf>
 8000bcc:	f001 f86e 	bl	8001cac <USART1_txint_send>
	can_msg_put(p);	// Place in CAN output buffer
 8000bd0:	4620      	mov	r0, r4
	return;
}
 8000bd2:	b003      	add	sp, #12
 8000bd4:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	p->cd.uc[1] = *rdaddr++;
	p->cd.uc[2] = *rdaddr++;
	p->cd.uc[3] = *rdaddr++;
	p->cd.uc[4] = *rdaddr;
printf("GETADDR: read addr: %X %X %X %X %X\n\r", p->cd.uc[0],p->cd.uc[1],p->cd.uc[2],p->cd.uc[3],p->cd.uc[4]);USART1_txint_send();
	can_msg_put(p);	// Place in CAN output buffer
 8000bd8:	e508      	b.n	80005ec <can_msg_put>
 8000bda:	bf00      	nop
 8000bdc:	08003bac 	.word	0x08003bac
 8000be0:	08003bd4 	.word	0x08003bd4

08000be4 <do_send4>:
 * @brief	: Send 4 bytes
 * @param	: Point to message buffer holding the imperial command
 * @param	: n = 4 byte number
 * ************************************************************************************** */
void do_send4(struct CANRCVBUF* p, u32 n)
{
 8000be4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 8000be6:	4604      	mov	r4, r0
	p->dlc = 5;	// Command plus char*
 8000be8:	2205      	movs	r2, #5
 8000bea:	6042      	str	r2, [r0, #4]
	p->cd.uc[1] = n;
	p->cd.uc[2] = n >> 8;
	p->cd.uc[3] = n >> 16;
 8000bec:	0c0d      	lsrs	r5, r1, #16
 * ************************************************************************************** */
void do_send4(struct CANRCVBUF* p, u32 n)
{
	p->dlc = 5;	// Command plus char*
	p->cd.uc[1] = n;
	p->cd.uc[2] = n >> 8;
 8000bee:	0a08      	lsrs	r0, r1, #8
	p->cd.uc[3] = n >> 16;
	p->cd.uc[4] = n >> 24;
 8000bf0:	0e0e      	lsrs	r6, r1, #24
 * ************************************************************************************** */
void do_send4(struct CANRCVBUF* p, u32 n)
{
	p->dlc = 5;	// Command plus char*
	p->cd.uc[1] = n;
	p->cd.uc[2] = n >> 8;
 8000bf2:	72a0      	strb	r0, [r4, #10]
	p->cd.uc[3] = n >> 16;
 8000bf4:	72e5      	strb	r5, [r4, #11]
	p->cd.uc[4] = n >> 24;
printf("send4: %X %X %X %X %X %X\n\r", n, p->cd.uc[0],p->cd.uc[1],p->cd.uc[2],p->cd.uc[3],p->cd.uc[4]);USART1_txint_send();
 8000bf6:	b2c0      	uxtb	r0, r0
 8000bf8:	b2ed      	uxtb	r5, r5
 * @param	: n = 4 byte number
 * ************************************************************************************** */
void do_send4(struct CANRCVBUF* p, u32 n)
{
	p->dlc = 5;	// Command plus char*
	p->cd.uc[1] = n;
 8000bfa:	7261      	strb	r1, [r4, #9]
	p->cd.uc[2] = n >> 8;
	p->cd.uc[3] = n >> 16;
	p->cd.uc[4] = n >> 24;
printf("send4: %X %X %X %X %X %X\n\r", n, p->cd.uc[0],p->cd.uc[1],p->cd.uc[2],p->cd.uc[3],p->cd.uc[4]);USART1_txint_send();
 8000bfc:	7a22      	ldrb	r2, [r4, #8]
 8000bfe:	9000      	str	r0, [sp, #0]
 8000c00:	b2cb      	uxtb	r3, r1
 8000c02:	4806      	ldr	r0, [pc, #24]	; (8000c1c <do_send4+0x38>)
{
	p->dlc = 5;	// Command plus char*
	p->cd.uc[1] = n;
	p->cd.uc[2] = n >> 8;
	p->cd.uc[3] = n >> 16;
	p->cd.uc[4] = n >> 24;
 8000c04:	7326      	strb	r6, [r4, #12]
printf("send4: %X %X %X %X %X %X\n\r", n, p->cd.uc[0],p->cd.uc[1],p->cd.uc[2],p->cd.uc[3],p->cd.uc[4]);USART1_txint_send();
 8000c06:	9602      	str	r6, [sp, #8]
 8000c08:	9501      	str	r5, [sp, #4]
 8000c0a:	f000 ff5b 	bl	8001ac4 <tfp_printf>
 8000c0e:	f001 f84d 	bl	8001cac <USART1_txint_send>
	can_msg_put(p);	// Place in CAN output buffer
 8000c12:	4620      	mov	r0, r4
	return;
}
 8000c14:	b004      	add	sp, #16
 8000c16:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	p->cd.uc[1] = n;
	p->cd.uc[2] = n >> 8;
	p->cd.uc[3] = n >> 16;
	p->cd.uc[4] = n >> 24;
printf("send4: %X %X %X %X %X %X\n\r", n, p->cd.uc[0],p->cd.uc[1],p->cd.uc[2],p->cd.uc[3],p->cd.uc[4]);USART1_txint_send();
	can_msg_put(p);	// Place in CAN output buffer
 8000c1a:	e4e7      	b.n	80005ec <can_msg_put>
 8000c1c:	08003bf9 	.word	0x08003bf9

08000c20 <do_getflashpaddr>:
extern u8* __highflashp;
extern u8* __highflashlayout;

void do_getflashpaddr(struct CANRCVBUF* p)
{
	p->dlc = 8;	// Command plus addr
 8000c20:	2308      	movs	r3, #8
extern u8* __appoffset;
extern u8* __highflashp;
extern u8* __highflashlayout;

void do_getflashpaddr(struct CANRCVBUF* p)
{
 8000c22:	b570      	push	{r4, r5, r6, lr}
	p->dlc = 8;	// Command plus addr
 8000c24:	6043      	str	r3, [r0, #4]

	extern void* __appjump;	// Defined in ldr.ld file
	u32* ppflashp = (u32*)((u32)((u8*)*&__appjump + 7 + 0));	// Points to "size"
 8000c26:	4b13      	ldr	r3, [pc, #76]	; (8000c74 <do_getflashpaddr+0x54>)
extern u8* __appoffset;
extern u8* __highflashp;
extern u8* __highflashlayout;

void do_getflashpaddr(struct CANRCVBUF* p)
{
 8000c28:	4604      	mov	r4, r0
	p->dlc = 8;	// Command plus addr

	extern void* __appjump;	// Defined in ldr.ld file
	u32* ppflashp = (u32*)((u32)((u8*)*&__appjump + 7 + 0));	// Points to "size"
 8000c2a:	681a      	ldr	r2, [r3, #0]

	if (size > 0x000fffff) size = 0x000fffff; // Only 3 bytes allowed for size (and < 1 MB)

	/* Payload [0] = cmd code; [1] - [3] = size; [4] - [7] = FLASHP address */
	u8 tmp = p->cd.uc[0];
	p->cd.ui[0] = (size << 8);	
 8000c2c:	4b12      	ldr	r3, [pc, #72]	; (8000c78 <do_getflashpaddr+0x58>)
	p->dlc = 8;	// Command plus addr

	extern void* __appjump;	// Defined in ldr.ld file
	u32* ppflashp = (u32*)((u32)((u8*)*&__appjump + 7 + 0));	// Points to "size"
	
	u32 size = *ppflashp;		// Get size
 8000c2e:	f8d2 0007 	ldr.w	r0, [r2, #7]
	u32 pflashp = *(ppflashp + 1);	// Get pointer to FLASHP and beginning of app struct

	if (size > 0x000fffff) size = 0x000fffff; // Only 3 bytes allowed for size (and < 1 MB)

	/* Payload [0] = cmd code; [1] - [3] = size; [4] - [7] = FLASHP address */
	u8 tmp = p->cd.uc[0];
 8000c32:	7a21      	ldrb	r1, [r4, #8]
	p->cd.ui[0] = (size << 8);	
 8000c34:	4283      	cmp	r3, r0
 8000c36:	bf28      	it	cs
 8000c38:	4603      	movcs	r3, r0

	extern void* __appjump;	// Defined in ldr.ld file
	u32* ppflashp = (u32*)((u32)((u8*)*&__appjump + 7 + 0));	// Points to "size"
	
	u32 size = *ppflashp;		// Get size
	u32 pflashp = *(ppflashp + 1);	// Get pointer to FLASHP and beginning of app struct
 8000c3a:	f8d2 200b 	ldr.w	r2, [r2, #11]

	if (size > 0x000fffff) size = 0x000fffff; // Only 3 bytes allowed for size (and < 1 MB)

	/* Payload [0] = cmd code; [1] - [3] = size; [4] - [7] = FLASHP address */
	u8 tmp = p->cd.uc[0];
	p->cd.ui[0] = (size << 8);	
 8000c3e:	021b      	lsls	r3, r3, #8
 8000c40:	60a3      	str	r3, [r4, #8]
	p->cd.uc[0] = tmp;
	p->cd.ui[1] = pflashp;
 8000c42:	60e2      	str	r2, [r4, #12]
	if (size > 0x000fffff) size = 0x000fffff; // Only 3 bytes allowed for size (and < 1 MB)

	/* Payload [0] = cmd code; [1] - [3] = size; [4] - [7] = FLASHP address */
	u8 tmp = p->cd.uc[0];
	p->cd.ui[0] = (size << 8);	
	p->cd.uc[0] = tmp;
 8000c44:	7221      	strb	r1, [r4, #8]
	p->cd.ui[1] = pflashp;

int i;printf("GET FLASHP addr ");
 8000c46:	480d      	ldr	r0, [pc, #52]	; (8000c7c <do_getflashpaddr+0x5c>)
 8000c48:	f000 ff3c 	bl	8001ac4 <tfp_printf>
 8000c4c:	1de5      	adds	r5, r4, #7
 8000c4e:	f104 060f 	add.w	r6, r4, #15
for (i = 0; i < 8; i++) printf(" %X",p->cd.uc[i]); 
 8000c52:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8000c56:	480a      	ldr	r0, [pc, #40]	; (8000c80 <do_getflashpaddr+0x60>)
 8000c58:	f000 ff34 	bl	8001ac4 <tfp_printf>
 8000c5c:	42b5      	cmp	r5, r6
 8000c5e:	d1f8      	bne.n	8000c52 <do_getflashpaddr+0x32>
printf("\n\r"); USART1_txint_send();
 8000c60:	4808      	ldr	r0, [pc, #32]	; (8000c84 <do_getflashpaddr+0x64>)
 8000c62:	f000 ff2f 	bl	8001ac4 <tfp_printf>
 8000c66:	f001 f821 	bl	8001cac <USART1_txint_send>

	can_msg_put(p);	// Place in CAN output buffer
 8000c6a:	4620      	mov	r0, r4
	return;
}
 8000c6c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

int i;printf("GET FLASHP addr ");
for (i = 0; i < 8; i++) printf(" %X",p->cd.uc[i]); 
printf("\n\r"); USART1_txint_send();

	can_msg_put(p);	// Place in CAN output buffer
 8000c70:	e4bc      	b.n	80005ec <can_msg_put>
 8000c72:	bf00      	nop
 8000c74:	08005004 	.word	0x08005004
 8000c78:	000fffff 	.word	0x000fffff
 8000c7c:	08003c14 	.word	0x08003c14
 8000c80:	08003c25 	.word	0x08003c25
 8000c84:	0800376a 	.word	0x0800376a

08000c88 <do_cmd_cmd>:
 * void do_cmd_cmd(struct CANRCVBUF* p);
 * @brief	: Do something!
 * @param	: p = pointer to message buffer
 * ************************************************************************************** */
void do_cmd_cmd(struct CANRCVBUF* p)
{
 8000c88:	b507      	push	{r0, r1, r2, lr}
	#define LDR_WRVAL_AI	22	// 8 Write: 2=memory area; 3-4=index; 5-8=one 4 byte value

*/
//printf("Q: %02X\n\r",p->cd.uc[0]); USART1_txint_send(); // Debug: Display command codes coming in
	/* Here, we have a command in the ID field. */
	switch (p->cd.uc[0])	// Command code
 8000c8a:	7a01      	ldrb	r1, [r0, #8]
 8000c8c:	1e4b      	subs	r3, r1, #1
 8000c8e:	2b14      	cmp	r3, #20
 8000c90:	d85e      	bhi.n	8000d50 <do_cmd_cmd+0xc8>
 8000c92:	e8df f003 	tbb	[pc, r3]
 8000c96:	5d0b      	.short	0x5d0b
 8000c98:	10717126 	.word	0x10717126
 8000c9c:	7171201b 	.word	0x7171201b
 8000ca0:	305d5d2b 	.word	0x305d5d2b
 8000ca4:	433d3b36 	.word	0x433d3b36
 8000ca8:	5d5d      	.short	0x5d5d
 8000caa:	48          	.byte	0x48
 8000cab:	00          	.byte	0x00
		err_bogus_cmds_cmds += 1;
printf("BOGUS CMD CODE: %X %08X %X  %08X %08X\n\r",p->cd.uc[0], p->id, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
		break;
	}
	return;
}
 8000cac:	b003      	add	sp, #12
 8000cae:	f85d eb04 	ldr.w	lr, [sp], #4
//printf("Q: %02X\n\r",p->cd.uc[0]); USART1_txint_send(); // Debug: Display command codes coming in
	/* Here, we have a command in the ID field. */
	switch (p->cd.uc[0])	// Command code
	{
	case LDR_SET_ADDR: // Set address pointer (bytes 2-5):  Respond with last written address.
		do_set_addr(p);
 8000cb2:	f7ff befb 	b.w	8000aac <do_set_addr>
static int do_jump(struct CANRCVBUF* p)
{
	u32 appjump;

	/* Check for correct number of bytes in payload. */
	if (p->dlc != 4) return -1;
 8000cb6:	6843      	ldr	r3, [r0, #4]
 8000cb8:	2b04      	cmp	r3, #4
 8000cba:	d15d      	bne.n	8000d78 <do_cmd_cmd+0xf0>

	/* Convert byte array to 4 byte unsigned int */
	 appjump = mv4(&p->cd.u8[0]); 
 8000cbc:	3008      	adds	r0, #8
 8000cbe:	f7ff fd5c 	bl	800077a <mv4>

	(*(  (void (**)(void))appjump)  )();	// Indirect jump via vector address
 8000cc2:	6803      	ldr	r3, [r0, #0]
		err_bogus_cmds_cmds += 1;
printf("BOGUS CMD CODE: %X %08X %X  %08X %08X\n\r",p->cd.uc[0], p->id, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
		break;
	}
	return;
}
 8000cc4:	b003      	add	sp, #12
 8000cc6:	f85d eb04 	ldr.w	lr, [sp], #4
	if (p->dlc != 4) return -1;

	/* Convert byte array to 4 byte unsigned int */
	 appjump = mv4(&p->cd.u8[0]); 

	(*(  (void (**)(void))appjump)  )();	// Indirect jump via vector address
 8000cca:	4718      	bx	r3
		err_bogus_cmds_cmds += 1;
printf("BOGUS CMD CODE: %X %08X %X  %08X %08X\n\r",p->cd.uc[0], p->id, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
		break;
	}
	return;
}
 8000ccc:	b003      	add	sp, #12
 8000cce:	f85d eb04 	ldr.w	lr, [sp], #4
	case LDR_JMP:		// Jump: to address supplied
		do_jump(p);
		break;

	case LDR_WRBLK:		// Done with block: write block with whatever you have..
		do_wrblk(p);
 8000cd2:	f7ff be75 	b.w	80009c0 <do_wrblk>
		break;

	case LDR_RESET:		// RESET: Execute a software forced RESET for this unit only.
		SCB_AIRCR  |= (0x5FA << 16) | SCB_AIRCR_SYSRESETREQ;	// Cause a RESET
 8000cd6:	4a2a      	ldr	r2, [pc, #168]	; (8000d80 <do_cmd_cmd+0xf8>)
 8000cd8:	4b2a      	ldr	r3, [pc, #168]	; (8000d84 <do_cmd_cmd+0xfc>)
 8000cda:	6811      	ldr	r1, [r2, #0]
 8000cdc:	430b      	orrs	r3, r1
 8000cde:	6013      	str	r3, [r2, #0]
		break;
 8000ce0:	e04a      	b.n	8000d78 <do_cmd_cmd+0xf0>
		err_bogus_cmds_cmds += 1;
printf("BOGUS CMD CODE: %X %08X %X  %08X %08X\n\r",p->cd.uc[0], p->id, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
		break;
	}
	return;
}
 8000ce2:	b003      	add	sp, #12
 8000ce4:	f85d eb04 	ldr.w	lr, [sp], #4
	case LDR_RESET:		// RESET: Execute a software forced RESET for this unit only.
		SCB_AIRCR  |= (0x5FA << 16) | SCB_AIRCR_SYSRESETREQ;	// Cause a RESET
		break;

	case LDR_CRC:		// Get CRC: given count | start address, compute CRC and respond with it.
		do_crc(p);
 8000ce8:	f7ff be7c 	b.w	80009e4 <do_crc>
		err_bogus_cmds_cmds += 1;
printf("BOGUS CMD CODE: %X %08X %X  %08X %08X\n\r",p->cd.uc[0], p->id, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
		break;
	}
	return;
}
 8000cec:	b003      	add	sp, #12
 8000cee:	f85d eb04 	ldr.w	lr, [sp], #4

	case LDR_XOFF:		// Stop sending: response to our sending LDR_XOFF msg.
		break;

	case LDR_FLASHSIZE:	// Send flash size
		do_flashsize(p);
 8000cf2:	f7ff bf0f 	b.w	8000b14 <do_flashsize>
		break;

	case LDR_FIXEDADDR:	// Send address ahead of fixed address block
		do_getfromdaddress(p, (u8*)0x08000004);
 8000cf6:	4924      	ldr	r1, [pc, #144]	; (8000d88 <do_cmd_cmd+0x100>)
		err_bogus_cmds_cmds += 1;
printf("BOGUS CMD CODE: %X %08X %X  %08X %08X\n\r",p->cd.uc[0], p->id, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
		break;
	}
	return;
}
 8000cf8:	b003      	add	sp, #12
 8000cfa:	f85d eb04 	ldr.w	lr, [sp], #4
	case LDR_FLASHSIZE:	// Send flash size
		do_flashsize(p);
		break;

	case LDR_FIXEDADDR:	// Send address ahead of fixed address block
		do_getfromdaddress(p, (u8*)0x08000004);
 8000cfe:	f7ff bf47 	b.w	8000b90 <do_getfromdaddress>
		err_bogus_cmds_cmds += 1;
printf("BOGUS CMD CODE: %X %08X %X  %08X %08X\n\r",p->cd.uc[0], p->id, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
		break;
	}
	return;
}
 8000d02:	b003      	add	sp, #12
 8000d04:	f85d eb04 	ldr.w	lr, [sp], #4
	case LDR_FIXEDADDR:	// Send address ahead of fixed address block
		do_getfromdaddress(p, (u8*)0x08000004);
		break;

	case LDR_RD4:		// Send address of fixed param flash area
		do_rd4(p);
 8000d08:	f7ff bf20 	b.w	8000b4c <do_rd4>
		break;

	case LDR_APPOFFSET:	// Send address of where app loads
		do_send4(p, (u32)&__appoffset);
 8000d0c:	491f      	ldr	r1, [pc, #124]	; (8000d8c <do_cmd_cmd+0x104>)
 8000d0e:	e000      	b.n	8000d12 <do_cmd_cmd+0x8a>
		break;

	case LDR_HIGHFLASHH:	// Send address of high flash area
		do_send4(p, (u32)&__highflashlayout);
 8000d10:	491f      	ldr	r1, [pc, #124]	; (8000d90 <do_cmd_cmd+0x108>)
		err_bogus_cmds_cmds += 1;
printf("BOGUS CMD CODE: %X %08X %X  %08X %08X\n\r",p->cd.uc[0], p->id, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
		break;
	}
	return;
}
 8000d12:	b003      	add	sp, #12
 8000d14:	f85d eb04 	ldr.w	lr, [sp], #4
	case LDR_APPOFFSET:	// Send address of where app loads
		do_send4(p, (u32)&__appoffset);
		break;

	case LDR_HIGHFLASHH:	// Send address of high flash area
		do_send4(p, (u32)&__highflashlayout);
 8000d18:	f7ff bf64 	b.w	8000be4 <do_send4>
		err_bogus_cmds_cmds += 1;
printf("BOGUS CMD CODE: %X %08X %X  %08X %08X\n\r",p->cd.uc[0], p->id, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
		break;
	}
	return;
}
 8000d1c:	b003      	add	sp, #12
 8000d1e:	f85d eb04 	ldr.w	lr, [sp], #4
	case LDR_HIGHFLASHH:	// Send address of high flash area
		do_send4(p, (u32)&__highflashlayout);
		break;

	case LDR_HIGHFLASHP:	// Get address of beginning of crc check info for app
		do_getflashpaddr(p);
 8000d22:	f7ff bf7d 	b.w	8000c20 <do_getflashpaddr>
		break;

	case LDR_WRVAL_PTR:	// Write: 2-8=bytes to be written via address ptr previous set
		// Write data starting at payload[1], dlc holds byte ct: 1-7
		do_datawrite(&p->cd.uc[1], (0x7f & p->dlc) - 1, p);
 8000d26:	6841      	ldr	r1, [r0, #4]
 8000d28:	4602      	mov	r2, r0
 8000d2a:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8000d2e:	3901      	subs	r1, #1
 8000d30:	3009      	adds	r0, #9
 8000d32:	f7ff fd59 	bl	80007e8 <do_datawrite>
 * @param	: cmd = command code
 ******************************************************************************/
static void sendcanCMD(u8 cmd)
{
	
	can_msg_cmd.dlc = 1;
 8000d36:	4817      	ldr	r0, [pc, #92]	; (8000d94 <do_cmd_cmd+0x10c>)
 8000d38:	2301      	movs	r3, #1
 8000d3a:	f8c0 3824 	str.w	r3, [r0, #2084]	; 0x824
	can_msg_cmd.cd.uc[0] = cmd;
 8000d3e:	2304      	movs	r3, #4
 8000d40:	f880 3828 	strb.w	r3, [r0, #2088]	; 0x828
	can_msg_put(&can_msg_cmd);
 8000d44:	f500 6002 	add.w	r0, r0, #2080	; 0x820
		err_bogus_cmds_cmds += 1;
printf("BOGUS CMD CODE: %X %08X %X  %08X %08X\n\r",p->cd.uc[0], p->id, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
		break;
	}
	return;
}
 8000d48:	b003      	add	sp, #12
 8000d4a:	f85d eb04 	ldr.w	lr, [sp], #4
static void sendcanCMD(u8 cmd)
{
	
	can_msg_cmd.dlc = 1;
	can_msg_cmd.cd.uc[0] = cmd;
	can_msg_put(&can_msg_cmd);
 8000d4e:	e44d      	b.n	80005ec <can_msg_put>
		do_datawrite(&p->cd.uc[1], (0x7f & p->dlc) - 1, p);
		sendcanCMD(LDR_ACK);
		break;

	default:		// Not a defined command
		err_bogus_cmds_cmds += 1;
 8000d50:	4a10      	ldr	r2, [pc, #64]	; (8000d94 <do_cmd_cmd+0x10c>)
 8000d52:	f8d2 3868 	ldr.w	r3, [r2, #2152]	; 0x868
 8000d56:	3301      	adds	r3, #1
 8000d58:	f8c2 3868 	str.w	r3, [r2, #2152]	; 0x868
printf("BOGUS CMD CODE: %X %08X %X  %08X %08X\n\r",p->cd.uc[0], p->id, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
 8000d5c:	68c3      	ldr	r3, [r0, #12]
 8000d5e:	9301      	str	r3, [sp, #4]
 8000d60:	6883      	ldr	r3, [r0, #8]
 8000d62:	9300      	str	r3, [sp, #0]
 8000d64:	e890 000c 	ldmia.w	r0, {r2, r3}
 8000d68:	480b      	ldr	r0, [pc, #44]	; (8000d98 <do_cmd_cmd+0x110>)
 8000d6a:	f000 feab 	bl	8001ac4 <tfp_printf>
		break;
	}
	return;
}
 8000d6e:	b003      	add	sp, #12
 8000d70:	f85d eb04 	ldr.w	lr, [sp], #4
		sendcanCMD(LDR_ACK);
		break;

	default:		// Not a defined command
		err_bogus_cmds_cmds += 1;
printf("BOGUS CMD CODE: %X %08X %X  %08X %08X\n\r",p->cd.uc[0], p->id, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
 8000d74:	f000 bf9a 	b.w	8001cac <USART1_txint_send>
		break;
	}
	return;
}
 8000d78:	b003      	add	sp, #12
 8000d7a:	f85d fb04 	ldr.w	pc, [sp], #4
 8000d7e:	bf00      	nop
 8000d80:	e000ed0c 	.word	0xe000ed0c
 8000d84:	05fa0004 	.word	0x05fa0004
 8000d88:	08000004 	.word	0x08000004
 8000d8c:	08005000 	.word	0x08005000
 8000d90:	0807f800 	.word	0x0807f800
 8000d94:	20000860 	.word	0x20000860
 8000d98:	08003c29 	.word	0x08003c29

08000d9c <canwinch_ldrproto_poll>:
 * void canwinch_ldrproto_poll(void);
 * @param	: pctl = pointer control block for CAN module being used
 * @brief	: If msg is for this unit, then do something with it.
 * ************************************************************************************** */
void canwinch_ldrproto_poll(void)
{
 8000d9c:	b538      	push	{r3, r4, r5, lr}
	struct CANRCVBUF* pcan;

	/* Check incoming msgs. */
	while ((pcan = can_driver_peek0(pctl1)) != NULL) // RX0 have a msg?
 8000d9e:	4d0a      	ldr	r5, [pc, #40]	; (8000dc8 <canwinch_ldrproto_poll+0x2c>)
 8000da0:	6828      	ldr	r0, [r5, #0]
 8000da2:	f001 ff53 	bl	8002c4c <can_driver_peek0>
 8000da6:	4c08      	ldr	r4, [pc, #32]	; (8000dc8 <canwinch_ldrproto_poll+0x2c>)
 8000da8:	b118      	cbz	r0, 8000db2 <canwinch_ldrproto_poll+0x16>
		if ( (pcan->id & 0x0ffffffe) == fixedaddress.canid_ldr)
		{ // Here CAN ID is for this unit/loader
//printf ("X: %08X %d %08X %08X\n\r",pcan->id,pcan->dlc,pcan->cd.ui[0],pcan->cd.ui[1]);
//$			do_cmd_cmd(pcan);		// Execute command 
		}
		can_driver_toss0(pctl1);	// Release buffer block
 8000daa:	6828      	ldr	r0, [r5, #0]
 8000dac:	f001 ff4a 	bl	8002c44 <can_driver_toss0>
 8000db0:	e7f6      	b.n	8000da0 <canwinch_ldrproto_poll+0x4>
	}
	/* Dump FIFO1 msgs. */
	while ((can_driver_peek1(pctl1)) != NULL)	// RX1 have a msg?
 8000db2:	4625      	mov	r5, r4
 8000db4:	6820      	ldr	r0, [r4, #0]
 8000db6:	f001 ff51 	bl	8002c5c <can_driver_peek1>
 8000dba:	b118      	cbz	r0, 8000dc4 <canwinch_ldrproto_poll+0x28>
		can_driver_toss1(pctl1); 	// Release buffer block
 8000dbc:	6828      	ldr	r0, [r5, #0]
 8000dbe:	f001 ff43 	bl	8002c48 <can_driver_toss1>
 8000dc2:	e7f7      	b.n	8000db4 <canwinch_ldrproto_poll+0x18>
	return;
}
 8000dc4:	bd38      	pop	{r3, r4, r5, pc}
 8000dc6:	bf00      	nop
 8000dc8:	20000850 	.word	0x20000850

08000dcc <cleanup_glue>:
 8000dcc:	b538      	push	{r3, r4, r5, lr}
 8000dce:	460c      	mov	r4, r1
 8000dd0:	6809      	ldr	r1, [r1, #0]
 8000dd2:	4605      	mov	r5, r0
 8000dd4:	b109      	cbz	r1, 8000dda <cleanup_glue+0xe>
 8000dd6:	f7ff fff9 	bl	8000dcc <cleanup_glue>
 8000dda:	4621      	mov	r1, r4
 8000ddc:	4628      	mov	r0, r5
 8000dde:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8000de2:	f000 b893 	b.w	8000f0c <_free_r>
 8000de6:	bf00      	nop

08000de8 <_reclaim_reent>:
 8000de8:	4b20      	ldr	r3, [pc, #128]	; (8000e6c <_reclaim_reent+0x84>)
 8000dea:	681b      	ldr	r3, [r3, #0]
 8000dec:	4283      	cmp	r3, r0
 8000dee:	d03c      	beq.n	8000e6a <_reclaim_reent+0x82>
 8000df0:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8000df2:	b570      	push	{r4, r5, r6, lr}
 8000df4:	4605      	mov	r5, r0
 8000df6:	b18b      	cbz	r3, 8000e1c <_reclaim_reent+0x34>
 8000df8:	2600      	movs	r6, #0
 8000dfa:	5999      	ldr	r1, [r3, r6]
 8000dfc:	b139      	cbz	r1, 8000e0e <_reclaim_reent+0x26>
 8000dfe:	680c      	ldr	r4, [r1, #0]
 8000e00:	4628      	mov	r0, r5
 8000e02:	f000 f883 	bl	8000f0c <_free_r>
 8000e06:	4621      	mov	r1, r4
 8000e08:	2c00      	cmp	r4, #0
 8000e0a:	d1f8      	bne.n	8000dfe <_reclaim_reent+0x16>
 8000e0c:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
 8000e0e:	3604      	adds	r6, #4
 8000e10:	2e80      	cmp	r6, #128	; 0x80
 8000e12:	d1f2      	bne.n	8000dfa <_reclaim_reent+0x12>
 8000e14:	4619      	mov	r1, r3
 8000e16:	4628      	mov	r0, r5
 8000e18:	f000 f878 	bl	8000f0c <_free_r>
 8000e1c:	6c29      	ldr	r1, [r5, #64]	; 0x40
 8000e1e:	b111      	cbz	r1, 8000e26 <_reclaim_reent+0x3e>
 8000e20:	4628      	mov	r0, r5
 8000e22:	f000 f873 	bl	8000f0c <_free_r>
 8000e26:	f8d5 1148 	ldr.w	r1, [r5, #328]	; 0x148
 8000e2a:	b151      	cbz	r1, 8000e42 <_reclaim_reent+0x5a>
 8000e2c:	f505 76a6 	add.w	r6, r5, #332	; 0x14c
 8000e30:	42b1      	cmp	r1, r6
 8000e32:	d006      	beq.n	8000e42 <_reclaim_reent+0x5a>
 8000e34:	680c      	ldr	r4, [r1, #0]
 8000e36:	4628      	mov	r0, r5
 8000e38:	f000 f868 	bl	8000f0c <_free_r>
 8000e3c:	42a6      	cmp	r6, r4
 8000e3e:	4621      	mov	r1, r4
 8000e40:	d1f8      	bne.n	8000e34 <_reclaim_reent+0x4c>
 8000e42:	6d69      	ldr	r1, [r5, #84]	; 0x54
 8000e44:	b111      	cbz	r1, 8000e4c <_reclaim_reent+0x64>
 8000e46:	4628      	mov	r0, r5
 8000e48:	f000 f860 	bl	8000f0c <_free_r>
 8000e4c:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8000e4e:	b903      	cbnz	r3, 8000e52 <_reclaim_reent+0x6a>
 8000e50:	bd70      	pop	{r4, r5, r6, pc}
 8000e52:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8000e54:	4628      	mov	r0, r5
 8000e56:	4798      	blx	r3
 8000e58:	f8d5 12e0 	ldr.w	r1, [r5, #736]	; 0x2e0
 8000e5c:	2900      	cmp	r1, #0
 8000e5e:	d0f7      	beq.n	8000e50 <_reclaim_reent+0x68>
 8000e60:	4628      	mov	r0, r5
 8000e62:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8000e66:	f7ff bfb1 	b.w	8000dcc <cleanup_glue>
 8000e6a:	4770      	bx	lr
 8000e6c:	20000430 	.word	0x20000430

08000e70 <_malloc_trim_r>:
 8000e70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000e72:	460c      	mov	r4, r1
 8000e74:	4f22      	ldr	r7, [pc, #136]	; (8000f00 <_malloc_trim_r+0x90>)
 8000e76:	4606      	mov	r6, r0
 8000e78:	f000 fbdc 	bl	8001634 <__malloc_lock>
 8000e7c:	68bb      	ldr	r3, [r7, #8]
 8000e7e:	685d      	ldr	r5, [r3, #4]
 8000e80:	f025 0503 	bic.w	r5, r5, #3
 8000e84:	1b29      	subs	r1, r5, r4
 8000e86:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
 8000e8a:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
 8000e8e:	f021 010f 	bic.w	r1, r1, #15
 8000e92:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
 8000e96:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
 8000e9a:	db07      	blt.n	8000eac <_malloc_trim_r+0x3c>
 8000e9c:	2100      	movs	r1, #0
 8000e9e:	4630      	mov	r0, r6
 8000ea0:	f000 fbcc 	bl	800163c <_sbrk_r>
 8000ea4:	68bb      	ldr	r3, [r7, #8]
 8000ea6:	442b      	add	r3, r5
 8000ea8:	4298      	cmp	r0, r3
 8000eaa:	d004      	beq.n	8000eb6 <_malloc_trim_r+0x46>
 8000eac:	4630      	mov	r0, r6
 8000eae:	f000 fbc3 	bl	8001638 <__malloc_unlock>
 8000eb2:	2000      	movs	r0, #0
 8000eb4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000eb6:	4261      	negs	r1, r4
 8000eb8:	4630      	mov	r0, r6
 8000eba:	f000 fbbf 	bl	800163c <_sbrk_r>
 8000ebe:	3001      	adds	r0, #1
 8000ec0:	d00d      	beq.n	8000ede <_malloc_trim_r+0x6e>
 8000ec2:	4b10      	ldr	r3, [pc, #64]	; (8000f04 <_malloc_trim_r+0x94>)
 8000ec4:	68ba      	ldr	r2, [r7, #8]
 8000ec6:	6819      	ldr	r1, [r3, #0]
 8000ec8:	1b2d      	subs	r5, r5, r4
 8000eca:	f045 0501 	orr.w	r5, r5, #1
 8000ece:	4630      	mov	r0, r6
 8000ed0:	1b09      	subs	r1, r1, r4
 8000ed2:	6055      	str	r5, [r2, #4]
 8000ed4:	6019      	str	r1, [r3, #0]
 8000ed6:	f000 fbaf 	bl	8001638 <__malloc_unlock>
 8000eda:	2001      	movs	r0, #1
 8000edc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000ede:	2100      	movs	r1, #0
 8000ee0:	4630      	mov	r0, r6
 8000ee2:	f000 fbab 	bl	800163c <_sbrk_r>
 8000ee6:	68ba      	ldr	r2, [r7, #8]
 8000ee8:	1a83      	subs	r3, r0, r2
 8000eea:	2b0f      	cmp	r3, #15
 8000eec:	ddde      	ble.n	8000eac <_malloc_trim_r+0x3c>
 8000eee:	4c06      	ldr	r4, [pc, #24]	; (8000f08 <_malloc_trim_r+0x98>)
 8000ef0:	4904      	ldr	r1, [pc, #16]	; (8000f04 <_malloc_trim_r+0x94>)
 8000ef2:	6824      	ldr	r4, [r4, #0]
 8000ef4:	f043 0301 	orr.w	r3, r3, #1
 8000ef8:	1b00      	subs	r0, r0, r4
 8000efa:	6053      	str	r3, [r2, #4]
 8000efc:	6008      	str	r0, [r1, #0]
 8000efe:	e7d5      	b.n	8000eac <_malloc_trim_r+0x3c>
 8000f00:	20000434 	.word	0x20000434
 8000f04:	20002200 	.word	0x20002200
 8000f08:	20000840 	.word	0x20000840

08000f0c <_free_r>:
 8000f0c:	2900      	cmp	r1, #0
 8000f0e:	d045      	beq.n	8000f9c <_free_r+0x90>
 8000f10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000f14:	460d      	mov	r5, r1
 8000f16:	4680      	mov	r8, r0
 8000f18:	f000 fb8c 	bl	8001634 <__malloc_lock>
 8000f1c:	f855 7c04 	ldr.w	r7, [r5, #-4]
 8000f20:	496a      	ldr	r1, [pc, #424]	; (80010cc <_free_r+0x1c0>)
 8000f22:	f1a5 0408 	sub.w	r4, r5, #8
 8000f26:	f027 0301 	bic.w	r3, r7, #1
 8000f2a:	18e2      	adds	r2, r4, r3
 8000f2c:	688e      	ldr	r6, [r1, #8]
 8000f2e:	6850      	ldr	r0, [r2, #4]
 8000f30:	42b2      	cmp	r2, r6
 8000f32:	f020 0003 	bic.w	r0, r0, #3
 8000f36:	d062      	beq.n	8000ffe <_free_r+0xf2>
 8000f38:	07fe      	lsls	r6, r7, #31
 8000f3a:	6050      	str	r0, [r2, #4]
 8000f3c:	d40b      	bmi.n	8000f56 <_free_r+0x4a>
 8000f3e:	f855 7c08 	ldr.w	r7, [r5, #-8]
 8000f42:	f101 0e08 	add.w	lr, r1, #8
 8000f46:	1be4      	subs	r4, r4, r7
 8000f48:	68a5      	ldr	r5, [r4, #8]
 8000f4a:	443b      	add	r3, r7
 8000f4c:	4575      	cmp	r5, lr
 8000f4e:	d06f      	beq.n	8001030 <_free_r+0x124>
 8000f50:	68e7      	ldr	r7, [r4, #12]
 8000f52:	60ef      	str	r7, [r5, #12]
 8000f54:	60bd      	str	r5, [r7, #8]
 8000f56:	1815      	adds	r5, r2, r0
 8000f58:	686d      	ldr	r5, [r5, #4]
 8000f5a:	07ed      	lsls	r5, r5, #31
 8000f5c:	d542      	bpl.n	8000fe4 <_free_r+0xd8>
 8000f5e:	f043 0201 	orr.w	r2, r3, #1
 8000f62:	6062      	str	r2, [r4, #4]
 8000f64:	50e3      	str	r3, [r4, r3]
 8000f66:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8000f6a:	d218      	bcs.n	8000f9e <_free_r+0x92>
 8000f6c:	08db      	lsrs	r3, r3, #3
 8000f6e:	6848      	ldr	r0, [r1, #4]
 8000f70:	109d      	asrs	r5, r3, #2
 8000f72:	2201      	movs	r2, #1
 8000f74:	3301      	adds	r3, #1
 8000f76:	f851 7033 	ldr.w	r7, [r1, r3, lsl #3]
 8000f7a:	fa02 f505 	lsl.w	r5, r2, r5
 8000f7e:	eb01 02c3 	add.w	r2, r1, r3, lsl #3
 8000f82:	4328      	orrs	r0, r5
 8000f84:	3a08      	subs	r2, #8
 8000f86:	60e2      	str	r2, [r4, #12]
 8000f88:	60a7      	str	r7, [r4, #8]
 8000f8a:	6048      	str	r0, [r1, #4]
 8000f8c:	f841 4033 	str.w	r4, [r1, r3, lsl #3]
 8000f90:	60fc      	str	r4, [r7, #12]
 8000f92:	4640      	mov	r0, r8
 8000f94:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8000f98:	f000 bb4e 	b.w	8001638 <__malloc_unlock>
 8000f9c:	4770      	bx	lr
 8000f9e:	0a5a      	lsrs	r2, r3, #9
 8000fa0:	2a04      	cmp	r2, #4
 8000fa2:	d853      	bhi.n	800104c <_free_r+0x140>
 8000fa4:	099a      	lsrs	r2, r3, #6
 8000fa6:	f102 0739 	add.w	r7, r2, #57	; 0x39
 8000faa:	007f      	lsls	r7, r7, #1
 8000fac:	f102 0538 	add.w	r5, r2, #56	; 0x38
 8000fb0:	eb01 0087 	add.w	r0, r1, r7, lsl #2
 8000fb4:	f851 2027 	ldr.w	r2, [r1, r7, lsl #2]
 8000fb8:	3808      	subs	r0, #8
 8000fba:	4290      	cmp	r0, r2
 8000fbc:	4943      	ldr	r1, [pc, #268]	; (80010cc <_free_r+0x1c0>)
 8000fbe:	d04d      	beq.n	800105c <_free_r+0x150>
 8000fc0:	6851      	ldr	r1, [r2, #4]
 8000fc2:	f021 0103 	bic.w	r1, r1, #3
 8000fc6:	428b      	cmp	r3, r1
 8000fc8:	d202      	bcs.n	8000fd0 <_free_r+0xc4>
 8000fca:	6892      	ldr	r2, [r2, #8]
 8000fcc:	4290      	cmp	r0, r2
 8000fce:	d1f7      	bne.n	8000fc0 <_free_r+0xb4>
 8000fd0:	68d0      	ldr	r0, [r2, #12]
 8000fd2:	60e0      	str	r0, [r4, #12]
 8000fd4:	60a2      	str	r2, [r4, #8]
 8000fd6:	6084      	str	r4, [r0, #8]
 8000fd8:	60d4      	str	r4, [r2, #12]
 8000fda:	4640      	mov	r0, r8
 8000fdc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8000fe0:	f000 bb2a 	b.w	8001638 <__malloc_unlock>
 8000fe4:	6895      	ldr	r5, [r2, #8]
 8000fe6:	4f3a      	ldr	r7, [pc, #232]	; (80010d0 <_free_r+0x1c4>)
 8000fe8:	4403      	add	r3, r0
 8000fea:	42bd      	cmp	r5, r7
 8000fec:	d03f      	beq.n	800106e <_free_r+0x162>
 8000fee:	68d0      	ldr	r0, [r2, #12]
 8000ff0:	f043 0201 	orr.w	r2, r3, #1
 8000ff4:	60e8      	str	r0, [r5, #12]
 8000ff6:	6085      	str	r5, [r0, #8]
 8000ff8:	6062      	str	r2, [r4, #4]
 8000ffa:	50e3      	str	r3, [r4, r3]
 8000ffc:	e7b3      	b.n	8000f66 <_free_r+0x5a>
 8000ffe:	07ff      	lsls	r7, r7, #31
 8001000:	4403      	add	r3, r0
 8001002:	d407      	bmi.n	8001014 <_free_r+0x108>
 8001004:	f855 5c08 	ldr.w	r5, [r5, #-8]
 8001008:	1b64      	subs	r4, r4, r5
 800100a:	68e2      	ldr	r2, [r4, #12]
 800100c:	68a0      	ldr	r0, [r4, #8]
 800100e:	442b      	add	r3, r5
 8001010:	60c2      	str	r2, [r0, #12]
 8001012:	6090      	str	r0, [r2, #8]
 8001014:	4a2f      	ldr	r2, [pc, #188]	; (80010d4 <_free_r+0x1c8>)
 8001016:	f043 0001 	orr.w	r0, r3, #1
 800101a:	6812      	ldr	r2, [r2, #0]
 800101c:	6060      	str	r0, [r4, #4]
 800101e:	4293      	cmp	r3, r2
 8001020:	608c      	str	r4, [r1, #8]
 8001022:	d3b6      	bcc.n	8000f92 <_free_r+0x86>
 8001024:	4b2c      	ldr	r3, [pc, #176]	; (80010d8 <_free_r+0x1cc>)
 8001026:	4640      	mov	r0, r8
 8001028:	6819      	ldr	r1, [r3, #0]
 800102a:	f7ff ff21 	bl	8000e70 <_malloc_trim_r>
 800102e:	e7b0      	b.n	8000f92 <_free_r+0x86>
 8001030:	1811      	adds	r1, r2, r0
 8001032:	6849      	ldr	r1, [r1, #4]
 8001034:	07c9      	lsls	r1, r1, #31
 8001036:	d444      	bmi.n	80010c2 <_free_r+0x1b6>
 8001038:	6891      	ldr	r1, [r2, #8]
 800103a:	4403      	add	r3, r0
 800103c:	68d2      	ldr	r2, [r2, #12]
 800103e:	f043 0001 	orr.w	r0, r3, #1
 8001042:	60ca      	str	r2, [r1, #12]
 8001044:	6091      	str	r1, [r2, #8]
 8001046:	6060      	str	r0, [r4, #4]
 8001048:	50e3      	str	r3, [r4, r3]
 800104a:	e7a2      	b.n	8000f92 <_free_r+0x86>
 800104c:	2a14      	cmp	r2, #20
 800104e:	d817      	bhi.n	8001080 <_free_r+0x174>
 8001050:	f102 075c 	add.w	r7, r2, #92	; 0x5c
 8001054:	007f      	lsls	r7, r7, #1
 8001056:	f102 055b 	add.w	r5, r2, #91	; 0x5b
 800105a:	e7a9      	b.n	8000fb0 <_free_r+0xa4>
 800105c:	10aa      	asrs	r2, r5, #2
 800105e:	684b      	ldr	r3, [r1, #4]
 8001060:	2501      	movs	r5, #1
 8001062:	fa05 f202 	lsl.w	r2, r5, r2
 8001066:	4313      	orrs	r3, r2
 8001068:	604b      	str	r3, [r1, #4]
 800106a:	4602      	mov	r2, r0
 800106c:	e7b1      	b.n	8000fd2 <_free_r+0xc6>
 800106e:	f043 0201 	orr.w	r2, r3, #1
 8001072:	614c      	str	r4, [r1, #20]
 8001074:	610c      	str	r4, [r1, #16]
 8001076:	60e5      	str	r5, [r4, #12]
 8001078:	60a5      	str	r5, [r4, #8]
 800107a:	6062      	str	r2, [r4, #4]
 800107c:	50e3      	str	r3, [r4, r3]
 800107e:	e788      	b.n	8000f92 <_free_r+0x86>
 8001080:	2a54      	cmp	r2, #84	; 0x54
 8001082:	d806      	bhi.n	8001092 <_free_r+0x186>
 8001084:	0b1a      	lsrs	r2, r3, #12
 8001086:	f102 076f 	add.w	r7, r2, #111	; 0x6f
 800108a:	007f      	lsls	r7, r7, #1
 800108c:	f102 056e 	add.w	r5, r2, #110	; 0x6e
 8001090:	e78e      	b.n	8000fb0 <_free_r+0xa4>
 8001092:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 8001096:	d806      	bhi.n	80010a6 <_free_r+0x19a>
 8001098:	0bda      	lsrs	r2, r3, #15
 800109a:	f102 0778 	add.w	r7, r2, #120	; 0x78
 800109e:	007f      	lsls	r7, r7, #1
 80010a0:	f102 0577 	add.w	r5, r2, #119	; 0x77
 80010a4:	e784      	b.n	8000fb0 <_free_r+0xa4>
 80010a6:	f240 5054 	movw	r0, #1364	; 0x554
 80010aa:	4282      	cmp	r2, r0
 80010ac:	d806      	bhi.n	80010bc <_free_r+0x1b0>
 80010ae:	0c9a      	lsrs	r2, r3, #18
 80010b0:	f102 077d 	add.w	r7, r2, #125	; 0x7d
 80010b4:	007f      	lsls	r7, r7, #1
 80010b6:	f102 057c 	add.w	r5, r2, #124	; 0x7c
 80010ba:	e779      	b.n	8000fb0 <_free_r+0xa4>
 80010bc:	27fe      	movs	r7, #254	; 0xfe
 80010be:	257e      	movs	r5, #126	; 0x7e
 80010c0:	e776      	b.n	8000fb0 <_free_r+0xa4>
 80010c2:	f043 0201 	orr.w	r2, r3, #1
 80010c6:	6062      	str	r2, [r4, #4]
 80010c8:	50e3      	str	r3, [r4, r3]
 80010ca:	e762      	b.n	8000f92 <_free_r+0x86>
 80010cc:	20000434 	.word	0x20000434
 80010d0:	2000043c 	.word	0x2000043c
 80010d4:	2000083c 	.word	0x2000083c
 80010d8:	200021fc 	.word	0x200021fc

080010dc <_malloc_r>:
 80010dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80010e0:	f101 050b 	add.w	r5, r1, #11
 80010e4:	2d16      	cmp	r5, #22
 80010e6:	b083      	sub	sp, #12
 80010e8:	4606      	mov	r6, r0
 80010ea:	f240 80a0 	bls.w	800122e <_malloc_r+0x152>
 80010ee:	f035 0507 	bics.w	r5, r5, #7
 80010f2:	f100 80c0 	bmi.w	8001276 <_malloc_r+0x19a>
 80010f6:	42a9      	cmp	r1, r5
 80010f8:	f200 80bd 	bhi.w	8001276 <_malloc_r+0x19a>
 80010fc:	f000 fa9a 	bl	8001634 <__malloc_lock>
 8001100:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
 8001104:	f0c0 8290 	bcc.w	8001628 <_malloc_r+0x54c>
 8001108:	0a6b      	lsrs	r3, r5, #9
 800110a:	f000 80bb 	beq.w	8001284 <_malloc_r+0x1a8>
 800110e:	2b04      	cmp	r3, #4
 8001110:	f200 8177 	bhi.w	8001402 <_malloc_r+0x326>
 8001114:	09a8      	lsrs	r0, r5, #6
 8001116:	f100 0e39 	add.w	lr, r0, #57	; 0x39
 800111a:	ea4f 014e 	mov.w	r1, lr, lsl #1
 800111e:	3038      	adds	r0, #56	; 0x38
 8001120:	4fbe      	ldr	r7, [pc, #760]	; (800141c <_malloc_r+0x340>)
 8001122:	eb07 0181 	add.w	r1, r7, r1, lsl #2
 8001126:	684c      	ldr	r4, [r1, #4]
 8001128:	3908      	subs	r1, #8
 800112a:	42a1      	cmp	r1, r4
 800112c:	d107      	bne.n	800113e <_malloc_r+0x62>
 800112e:	e0ae      	b.n	800128e <_malloc_r+0x1b2>
 8001130:	2a00      	cmp	r2, #0
 8001132:	f280 80ae 	bge.w	8001292 <_malloc_r+0x1b6>
 8001136:	68e4      	ldr	r4, [r4, #12]
 8001138:	42a1      	cmp	r1, r4
 800113a:	f000 80a8 	beq.w	800128e <_malloc_r+0x1b2>
 800113e:	6863      	ldr	r3, [r4, #4]
 8001140:	f023 0303 	bic.w	r3, r3, #3
 8001144:	1b5a      	subs	r2, r3, r5
 8001146:	2a0f      	cmp	r2, #15
 8001148:	ddf2      	ble.n	8001130 <_malloc_r+0x54>
 800114a:	49b4      	ldr	r1, [pc, #720]	; (800141c <_malloc_r+0x340>)
 800114c:	693c      	ldr	r4, [r7, #16]
 800114e:	f101 0e08 	add.w	lr, r1, #8
 8001152:	4574      	cmp	r4, lr
 8001154:	f000 81a8 	beq.w	80014a8 <_malloc_r+0x3cc>
 8001158:	6863      	ldr	r3, [r4, #4]
 800115a:	f023 0303 	bic.w	r3, r3, #3
 800115e:	1b5a      	subs	r2, r3, r5
 8001160:	2a0f      	cmp	r2, #15
 8001162:	f300 818e 	bgt.w	8001482 <_malloc_r+0x3a6>
 8001166:	2a00      	cmp	r2, #0
 8001168:	f8c1 e014 	str.w	lr, [r1, #20]
 800116c:	f8c1 e010 	str.w	lr, [r1, #16]
 8001170:	f280 8093 	bge.w	800129a <_malloc_r+0x1be>
 8001174:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8001178:	f080 815c 	bcs.w	8001434 <_malloc_r+0x358>
 800117c:	08db      	lsrs	r3, r3, #3
 800117e:	684a      	ldr	r2, [r1, #4]
 8001180:	ea4f 09a3 	mov.w	r9, r3, asr #2
 8001184:	f04f 0c01 	mov.w	ip, #1
 8001188:	3301      	adds	r3, #1
 800118a:	f851 8033 	ldr.w	r8, [r1, r3, lsl #3]
 800118e:	fa0c f909 	lsl.w	r9, ip, r9
 8001192:	eb01 0cc3 	add.w	ip, r1, r3, lsl #3
 8001196:	ea49 0202 	orr.w	r2, r9, r2
 800119a:	f1ac 0c08 	sub.w	ip, ip, #8
 800119e:	f8c4 c00c 	str.w	ip, [r4, #12]
 80011a2:	f8c4 8008 	str.w	r8, [r4, #8]
 80011a6:	604a      	str	r2, [r1, #4]
 80011a8:	f841 4033 	str.w	r4, [r1, r3, lsl #3]
 80011ac:	f8c8 400c 	str.w	r4, [r8, #12]
 80011b0:	1083      	asrs	r3, r0, #2
 80011b2:	2401      	movs	r4, #1
 80011b4:	409c      	lsls	r4, r3
 80011b6:	4294      	cmp	r4, r2
 80011b8:	d87c      	bhi.n	80012b4 <_malloc_r+0x1d8>
 80011ba:	4214      	tst	r4, r2
 80011bc:	d106      	bne.n	80011cc <_malloc_r+0xf0>
 80011be:	f020 0003 	bic.w	r0, r0, #3
 80011c2:	0064      	lsls	r4, r4, #1
 80011c4:	4214      	tst	r4, r2
 80011c6:	f100 0004 	add.w	r0, r0, #4
 80011ca:	d0fa      	beq.n	80011c2 <_malloc_r+0xe6>
 80011cc:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
 80011d0:	46cc      	mov	ip, r9
 80011d2:	4680      	mov	r8, r0
 80011d4:	f8dc 100c 	ldr.w	r1, [ip, #12]
 80011d8:	458c      	cmp	ip, r1
 80011da:	d107      	bne.n	80011ec <_malloc_r+0x110>
 80011dc:	e166      	b.n	80014ac <_malloc_r+0x3d0>
 80011de:	2a00      	cmp	r2, #0
 80011e0:	f280 8174 	bge.w	80014cc <_malloc_r+0x3f0>
 80011e4:	68c9      	ldr	r1, [r1, #12]
 80011e6:	458c      	cmp	ip, r1
 80011e8:	f000 8160 	beq.w	80014ac <_malloc_r+0x3d0>
 80011ec:	684b      	ldr	r3, [r1, #4]
 80011ee:	f023 0303 	bic.w	r3, r3, #3
 80011f2:	1b5a      	subs	r2, r3, r5
 80011f4:	2a0f      	cmp	r2, #15
 80011f6:	ddf2      	ble.n	80011de <_malloc_r+0x102>
 80011f8:	460c      	mov	r4, r1
 80011fa:	68cb      	ldr	r3, [r1, #12]
 80011fc:	f854 cf08 	ldr.w	ip, [r4, #8]!
 8001200:	f045 0801 	orr.w	r8, r5, #1
 8001204:	f8c1 8004 	str.w	r8, [r1, #4]
 8001208:	440d      	add	r5, r1
 800120a:	f042 0101 	orr.w	r1, r2, #1
 800120e:	f8cc 300c 	str.w	r3, [ip, #12]
 8001212:	4630      	mov	r0, r6
 8001214:	f8c3 c008 	str.w	ip, [r3, #8]
 8001218:	617d      	str	r5, [r7, #20]
 800121a:	613d      	str	r5, [r7, #16]
 800121c:	f8c5 e00c 	str.w	lr, [r5, #12]
 8001220:	f8c5 e008 	str.w	lr, [r5, #8]
 8001224:	6069      	str	r1, [r5, #4]
 8001226:	50aa      	str	r2, [r5, r2]
 8001228:	f000 fa06 	bl	8001638 <__malloc_unlock>
 800122c:	e01f      	b.n	800126e <_malloc_r+0x192>
 800122e:	2910      	cmp	r1, #16
 8001230:	d821      	bhi.n	8001276 <_malloc_r+0x19a>
 8001232:	f000 f9ff 	bl	8001634 <__malloc_lock>
 8001236:	2510      	movs	r5, #16
 8001238:	2306      	movs	r3, #6
 800123a:	2002      	movs	r0, #2
 800123c:	4f77      	ldr	r7, [pc, #476]	; (800141c <_malloc_r+0x340>)
 800123e:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 8001242:	685c      	ldr	r4, [r3, #4]
 8001244:	f1a3 0208 	sub.w	r2, r3, #8
 8001248:	4294      	cmp	r4, r2
 800124a:	f000 8138 	beq.w	80014be <_malloc_r+0x3e2>
 800124e:	6863      	ldr	r3, [r4, #4]
 8001250:	68e1      	ldr	r1, [r4, #12]
 8001252:	f023 0303 	bic.w	r3, r3, #3
 8001256:	4423      	add	r3, r4
 8001258:	685a      	ldr	r2, [r3, #4]
 800125a:	68a5      	ldr	r5, [r4, #8]
 800125c:	f042 0201 	orr.w	r2, r2, #1
 8001260:	60e9      	str	r1, [r5, #12]
 8001262:	4630      	mov	r0, r6
 8001264:	608d      	str	r5, [r1, #8]
 8001266:	605a      	str	r2, [r3, #4]
 8001268:	f000 f9e6 	bl	8001638 <__malloc_unlock>
 800126c:	3408      	adds	r4, #8
 800126e:	4620      	mov	r0, r4
 8001270:	b003      	add	sp, #12
 8001272:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001276:	2400      	movs	r4, #0
 8001278:	4620      	mov	r0, r4
 800127a:	230c      	movs	r3, #12
 800127c:	6033      	str	r3, [r6, #0]
 800127e:	b003      	add	sp, #12
 8001280:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001284:	2180      	movs	r1, #128	; 0x80
 8001286:	f04f 0e40 	mov.w	lr, #64	; 0x40
 800128a:	203f      	movs	r0, #63	; 0x3f
 800128c:	e748      	b.n	8001120 <_malloc_r+0x44>
 800128e:	4670      	mov	r0, lr
 8001290:	e75b      	b.n	800114a <_malloc_r+0x6e>
 8001292:	4423      	add	r3, r4
 8001294:	685a      	ldr	r2, [r3, #4]
 8001296:	68e1      	ldr	r1, [r4, #12]
 8001298:	e7df      	b.n	800125a <_malloc_r+0x17e>
 800129a:	4423      	add	r3, r4
 800129c:	685a      	ldr	r2, [r3, #4]
 800129e:	4630      	mov	r0, r6
 80012a0:	f042 0201 	orr.w	r2, r2, #1
 80012a4:	605a      	str	r2, [r3, #4]
 80012a6:	3408      	adds	r4, #8
 80012a8:	f000 f9c6 	bl	8001638 <__malloc_unlock>
 80012ac:	4620      	mov	r0, r4
 80012ae:	b003      	add	sp, #12
 80012b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80012b4:	68bc      	ldr	r4, [r7, #8]
 80012b6:	6863      	ldr	r3, [r4, #4]
 80012b8:	f023 0803 	bic.w	r8, r3, #3
 80012bc:	45a8      	cmp	r8, r5
 80012be:	d304      	bcc.n	80012ca <_malloc_r+0x1ee>
 80012c0:	ebc5 0308 	rsb	r3, r5, r8
 80012c4:	2b0f      	cmp	r3, #15
 80012c6:	f300 808c 	bgt.w	80013e2 <_malloc_r+0x306>
 80012ca:	4b55      	ldr	r3, [pc, #340]	; (8001420 <_malloc_r+0x344>)
 80012cc:	f8df 9160 	ldr.w	r9, [pc, #352]	; 8001430 <_malloc_r+0x354>
 80012d0:	681a      	ldr	r2, [r3, #0]
 80012d2:	f8d9 3000 	ldr.w	r3, [r9]
 80012d6:	442a      	add	r2, r5
 80012d8:	3301      	adds	r3, #1
 80012da:	eb04 0a08 	add.w	sl, r4, r8
 80012de:	f000 8160 	beq.w	80015a2 <_malloc_r+0x4c6>
 80012e2:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 80012e6:	320f      	adds	r2, #15
 80012e8:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
 80012ec:	f022 020f 	bic.w	r2, r2, #15
 80012f0:	4611      	mov	r1, r2
 80012f2:	4630      	mov	r0, r6
 80012f4:	9201      	str	r2, [sp, #4]
 80012f6:	f000 f9a1 	bl	800163c <_sbrk_r>
 80012fa:	f1b0 3fff 	cmp.w	r0, #4294967295
 80012fe:	4683      	mov	fp, r0
 8001300:	9a01      	ldr	r2, [sp, #4]
 8001302:	f000 8158 	beq.w	80015b6 <_malloc_r+0x4da>
 8001306:	4582      	cmp	sl, r0
 8001308:	f200 80fc 	bhi.w	8001504 <_malloc_r+0x428>
 800130c:	4b45      	ldr	r3, [pc, #276]	; (8001424 <_malloc_r+0x348>)
 800130e:	45da      	cmp	sl, fp
 8001310:	6819      	ldr	r1, [r3, #0]
 8001312:	4411      	add	r1, r2
 8001314:	6019      	str	r1, [r3, #0]
 8001316:	f000 8153 	beq.w	80015c0 <_malloc_r+0x4e4>
 800131a:	f8d9 0000 	ldr.w	r0, [r9]
 800131e:	f8df e110 	ldr.w	lr, [pc, #272]	; 8001430 <_malloc_r+0x354>
 8001322:	3001      	adds	r0, #1
 8001324:	bf1b      	ittet	ne
 8001326:	ebca 0a0b 	rsbne	sl, sl, fp
 800132a:	4451      	addne	r1, sl
 800132c:	f8ce b000 	streq.w	fp, [lr]
 8001330:	6019      	strne	r1, [r3, #0]
 8001332:	f01b 0107 	ands.w	r1, fp, #7
 8001336:	f000 8117 	beq.w	8001568 <_malloc_r+0x48c>
 800133a:	f1c1 0008 	rsb	r0, r1, #8
 800133e:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
 8001342:	4483      	add	fp, r0
 8001344:	3108      	adds	r1, #8
 8001346:	445a      	add	r2, fp
 8001348:	f3c2 020b 	ubfx	r2, r2, #0, #12
 800134c:	ebc2 0901 	rsb	r9, r2, r1
 8001350:	4649      	mov	r1, r9
 8001352:	4630      	mov	r0, r6
 8001354:	9301      	str	r3, [sp, #4]
 8001356:	f000 f971 	bl	800163c <_sbrk_r>
 800135a:	1c43      	adds	r3, r0, #1
 800135c:	9b01      	ldr	r3, [sp, #4]
 800135e:	f000 813f 	beq.w	80015e0 <_malloc_r+0x504>
 8001362:	ebcb 0200 	rsb	r2, fp, r0
 8001366:	444a      	add	r2, r9
 8001368:	f042 0201 	orr.w	r2, r2, #1
 800136c:	6819      	ldr	r1, [r3, #0]
 800136e:	42bc      	cmp	r4, r7
 8001370:	4449      	add	r1, r9
 8001372:	f8c7 b008 	str.w	fp, [r7, #8]
 8001376:	6019      	str	r1, [r3, #0]
 8001378:	f8cb 2004 	str.w	r2, [fp, #4]
 800137c:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 8001424 <_malloc_r+0x348>
 8001380:	d016      	beq.n	80013b0 <_malloc_r+0x2d4>
 8001382:	f1b8 0f0f 	cmp.w	r8, #15
 8001386:	f240 80fd 	bls.w	8001584 <_malloc_r+0x4a8>
 800138a:	6862      	ldr	r2, [r4, #4]
 800138c:	f1a8 030c 	sub.w	r3, r8, #12
 8001390:	f023 0307 	bic.w	r3, r3, #7
 8001394:	f002 0201 	and.w	r2, r2, #1
 8001398:	18e0      	adds	r0, r4, r3
 800139a:	f04f 0e05 	mov.w	lr, #5
 800139e:	431a      	orrs	r2, r3
 80013a0:	2b0f      	cmp	r3, #15
 80013a2:	6062      	str	r2, [r4, #4]
 80013a4:	f8c0 e004 	str.w	lr, [r0, #4]
 80013a8:	f8c0 e008 	str.w	lr, [r0, #8]
 80013ac:	f200 811c 	bhi.w	80015e8 <_malloc_r+0x50c>
 80013b0:	4b1d      	ldr	r3, [pc, #116]	; (8001428 <_malloc_r+0x34c>)
 80013b2:	68bc      	ldr	r4, [r7, #8]
 80013b4:	681a      	ldr	r2, [r3, #0]
 80013b6:	4291      	cmp	r1, r2
 80013b8:	bf88      	it	hi
 80013ba:	6019      	strhi	r1, [r3, #0]
 80013bc:	4b1b      	ldr	r3, [pc, #108]	; (800142c <_malloc_r+0x350>)
 80013be:	681a      	ldr	r2, [r3, #0]
 80013c0:	4291      	cmp	r1, r2
 80013c2:	6862      	ldr	r2, [r4, #4]
 80013c4:	bf88      	it	hi
 80013c6:	6019      	strhi	r1, [r3, #0]
 80013c8:	f022 0203 	bic.w	r2, r2, #3
 80013cc:	4295      	cmp	r5, r2
 80013ce:	eba2 0305 	sub.w	r3, r2, r5
 80013d2:	d801      	bhi.n	80013d8 <_malloc_r+0x2fc>
 80013d4:	2b0f      	cmp	r3, #15
 80013d6:	dc04      	bgt.n	80013e2 <_malloc_r+0x306>
 80013d8:	4630      	mov	r0, r6
 80013da:	f000 f92d 	bl	8001638 <__malloc_unlock>
 80013de:	2400      	movs	r4, #0
 80013e0:	e745      	b.n	800126e <_malloc_r+0x192>
 80013e2:	f045 0201 	orr.w	r2, r5, #1
 80013e6:	f043 0301 	orr.w	r3, r3, #1
 80013ea:	4425      	add	r5, r4
 80013ec:	6062      	str	r2, [r4, #4]
 80013ee:	4630      	mov	r0, r6
 80013f0:	60bd      	str	r5, [r7, #8]
 80013f2:	3408      	adds	r4, #8
 80013f4:	606b      	str	r3, [r5, #4]
 80013f6:	f000 f91f 	bl	8001638 <__malloc_unlock>
 80013fa:	4620      	mov	r0, r4
 80013fc:	b003      	add	sp, #12
 80013fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001402:	2b14      	cmp	r3, #20
 8001404:	d971      	bls.n	80014ea <_malloc_r+0x40e>
 8001406:	2b54      	cmp	r3, #84	; 0x54
 8001408:	f200 80a4 	bhi.w	8001554 <_malloc_r+0x478>
 800140c:	0b28      	lsrs	r0, r5, #12
 800140e:	f100 0e6f 	add.w	lr, r0, #111	; 0x6f
 8001412:	ea4f 014e 	mov.w	r1, lr, lsl #1
 8001416:	306e      	adds	r0, #110	; 0x6e
 8001418:	e682      	b.n	8001120 <_malloc_r+0x44>
 800141a:	bf00      	nop
 800141c:	20000434 	.word	0x20000434
 8001420:	200021fc 	.word	0x200021fc
 8001424:	20002200 	.word	0x20002200
 8001428:	200021f8 	.word	0x200021f8
 800142c:	200021f4 	.word	0x200021f4
 8001430:	20000840 	.word	0x20000840
 8001434:	0a5a      	lsrs	r2, r3, #9
 8001436:	2a04      	cmp	r2, #4
 8001438:	d95e      	bls.n	80014f8 <_malloc_r+0x41c>
 800143a:	2a14      	cmp	r2, #20
 800143c:	f200 80b3 	bhi.w	80015a6 <_malloc_r+0x4ca>
 8001440:	f102 015c 	add.w	r1, r2, #92	; 0x5c
 8001444:	0049      	lsls	r1, r1, #1
 8001446:	325b      	adds	r2, #91	; 0x5b
 8001448:	eb07 0c81 	add.w	ip, r7, r1, lsl #2
 800144c:	f857 1021 	ldr.w	r1, [r7, r1, lsl #2]
 8001450:	f1ac 0c08 	sub.w	ip, ip, #8
 8001454:	458c      	cmp	ip, r1
 8001456:	f8df 81d8 	ldr.w	r8, [pc, #472]	; 8001630 <_malloc_r+0x554>
 800145a:	f000 8088 	beq.w	800156e <_malloc_r+0x492>
 800145e:	684a      	ldr	r2, [r1, #4]
 8001460:	f022 0203 	bic.w	r2, r2, #3
 8001464:	4293      	cmp	r3, r2
 8001466:	d202      	bcs.n	800146e <_malloc_r+0x392>
 8001468:	6889      	ldr	r1, [r1, #8]
 800146a:	458c      	cmp	ip, r1
 800146c:	d1f7      	bne.n	800145e <_malloc_r+0x382>
 800146e:	f8d1 c00c 	ldr.w	ip, [r1, #12]
 8001472:	687a      	ldr	r2, [r7, #4]
 8001474:	f8c4 c00c 	str.w	ip, [r4, #12]
 8001478:	60a1      	str	r1, [r4, #8]
 800147a:	f8cc 4008 	str.w	r4, [ip, #8]
 800147e:	60cc      	str	r4, [r1, #12]
 8001480:	e696      	b.n	80011b0 <_malloc_r+0xd4>
 8001482:	f045 0701 	orr.w	r7, r5, #1
 8001486:	f042 0301 	orr.w	r3, r2, #1
 800148a:	4425      	add	r5, r4
 800148c:	6067      	str	r7, [r4, #4]
 800148e:	4630      	mov	r0, r6
 8001490:	614d      	str	r5, [r1, #20]
 8001492:	610d      	str	r5, [r1, #16]
 8001494:	f8c5 e00c 	str.w	lr, [r5, #12]
 8001498:	f8c5 e008 	str.w	lr, [r5, #8]
 800149c:	606b      	str	r3, [r5, #4]
 800149e:	50aa      	str	r2, [r5, r2]
 80014a0:	3408      	adds	r4, #8
 80014a2:	f000 f8c9 	bl	8001638 <__malloc_unlock>
 80014a6:	e6e2      	b.n	800126e <_malloc_r+0x192>
 80014a8:	684a      	ldr	r2, [r1, #4]
 80014aa:	e681      	b.n	80011b0 <_malloc_r+0xd4>
 80014ac:	f108 0801 	add.w	r8, r8, #1
 80014b0:	f018 0f03 	tst.w	r8, #3
 80014b4:	f10c 0c08 	add.w	ip, ip, #8
 80014b8:	f47f ae8c 	bne.w	80011d4 <_malloc_r+0xf8>
 80014bc:	e030      	b.n	8001520 <_malloc_r+0x444>
 80014be:	68dc      	ldr	r4, [r3, #12]
 80014c0:	42a3      	cmp	r3, r4
 80014c2:	bf08      	it	eq
 80014c4:	3002      	addeq	r0, #2
 80014c6:	f43f ae40 	beq.w	800114a <_malloc_r+0x6e>
 80014ca:	e6c0      	b.n	800124e <_malloc_r+0x172>
 80014cc:	460c      	mov	r4, r1
 80014ce:	440b      	add	r3, r1
 80014d0:	685a      	ldr	r2, [r3, #4]
 80014d2:	68c9      	ldr	r1, [r1, #12]
 80014d4:	f854 5f08 	ldr.w	r5, [r4, #8]!
 80014d8:	f042 0201 	orr.w	r2, r2, #1
 80014dc:	605a      	str	r2, [r3, #4]
 80014de:	4630      	mov	r0, r6
 80014e0:	60e9      	str	r1, [r5, #12]
 80014e2:	608d      	str	r5, [r1, #8]
 80014e4:	f000 f8a8 	bl	8001638 <__malloc_unlock>
 80014e8:	e6c1      	b.n	800126e <_malloc_r+0x192>
 80014ea:	f103 0e5c 	add.w	lr, r3, #92	; 0x5c
 80014ee:	f103 005b 	add.w	r0, r3, #91	; 0x5b
 80014f2:	ea4f 014e 	mov.w	r1, lr, lsl #1
 80014f6:	e613      	b.n	8001120 <_malloc_r+0x44>
 80014f8:	099a      	lsrs	r2, r3, #6
 80014fa:	f102 0139 	add.w	r1, r2, #57	; 0x39
 80014fe:	0049      	lsls	r1, r1, #1
 8001500:	3238      	adds	r2, #56	; 0x38
 8001502:	e7a1      	b.n	8001448 <_malloc_r+0x36c>
 8001504:	42bc      	cmp	r4, r7
 8001506:	4b4a      	ldr	r3, [pc, #296]	; (8001630 <_malloc_r+0x554>)
 8001508:	f43f af00 	beq.w	800130c <_malloc_r+0x230>
 800150c:	689c      	ldr	r4, [r3, #8]
 800150e:	6862      	ldr	r2, [r4, #4]
 8001510:	f022 0203 	bic.w	r2, r2, #3
 8001514:	e75a      	b.n	80013cc <_malloc_r+0x2f0>
 8001516:	f859 3908 	ldr.w	r3, [r9], #-8
 800151a:	4599      	cmp	r9, r3
 800151c:	f040 8082 	bne.w	8001624 <_malloc_r+0x548>
 8001520:	f010 0f03 	tst.w	r0, #3
 8001524:	f100 30ff 	add.w	r0, r0, #4294967295
 8001528:	d1f5      	bne.n	8001516 <_malloc_r+0x43a>
 800152a:	687b      	ldr	r3, [r7, #4]
 800152c:	ea23 0304 	bic.w	r3, r3, r4
 8001530:	607b      	str	r3, [r7, #4]
 8001532:	0064      	lsls	r4, r4, #1
 8001534:	429c      	cmp	r4, r3
 8001536:	f63f aebd 	bhi.w	80012b4 <_malloc_r+0x1d8>
 800153a:	2c00      	cmp	r4, #0
 800153c:	f43f aeba 	beq.w	80012b4 <_malloc_r+0x1d8>
 8001540:	421c      	tst	r4, r3
 8001542:	4640      	mov	r0, r8
 8001544:	f47f ae42 	bne.w	80011cc <_malloc_r+0xf0>
 8001548:	0064      	lsls	r4, r4, #1
 800154a:	421c      	tst	r4, r3
 800154c:	f100 0004 	add.w	r0, r0, #4
 8001550:	d0fa      	beq.n	8001548 <_malloc_r+0x46c>
 8001552:	e63b      	b.n	80011cc <_malloc_r+0xf0>
 8001554:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 8001558:	d818      	bhi.n	800158c <_malloc_r+0x4b0>
 800155a:	0be8      	lsrs	r0, r5, #15
 800155c:	f100 0e78 	add.w	lr, r0, #120	; 0x78
 8001560:	ea4f 014e 	mov.w	r1, lr, lsl #1
 8001564:	3077      	adds	r0, #119	; 0x77
 8001566:	e5db      	b.n	8001120 <_malloc_r+0x44>
 8001568:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800156c:	e6eb      	b.n	8001346 <_malloc_r+0x26a>
 800156e:	2101      	movs	r1, #1
 8001570:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8001574:	1092      	asrs	r2, r2, #2
 8001576:	fa01 f202 	lsl.w	r2, r1, r2
 800157a:	431a      	orrs	r2, r3
 800157c:	f8c8 2004 	str.w	r2, [r8, #4]
 8001580:	4661      	mov	r1, ip
 8001582:	e777      	b.n	8001474 <_malloc_r+0x398>
 8001584:	2301      	movs	r3, #1
 8001586:	f8cb 3004 	str.w	r3, [fp, #4]
 800158a:	e725      	b.n	80013d8 <_malloc_r+0x2fc>
 800158c:	f240 5254 	movw	r2, #1364	; 0x554
 8001590:	4293      	cmp	r3, r2
 8001592:	d820      	bhi.n	80015d6 <_malloc_r+0x4fa>
 8001594:	0ca8      	lsrs	r0, r5, #18
 8001596:	f100 0e7d 	add.w	lr, r0, #125	; 0x7d
 800159a:	ea4f 014e 	mov.w	r1, lr, lsl #1
 800159e:	307c      	adds	r0, #124	; 0x7c
 80015a0:	e5be      	b.n	8001120 <_malloc_r+0x44>
 80015a2:	3210      	adds	r2, #16
 80015a4:	e6a4      	b.n	80012f0 <_malloc_r+0x214>
 80015a6:	2a54      	cmp	r2, #84	; 0x54
 80015a8:	d826      	bhi.n	80015f8 <_malloc_r+0x51c>
 80015aa:	0b1a      	lsrs	r2, r3, #12
 80015ac:	f102 016f 	add.w	r1, r2, #111	; 0x6f
 80015b0:	0049      	lsls	r1, r1, #1
 80015b2:	326e      	adds	r2, #110	; 0x6e
 80015b4:	e748      	b.n	8001448 <_malloc_r+0x36c>
 80015b6:	68bc      	ldr	r4, [r7, #8]
 80015b8:	6862      	ldr	r2, [r4, #4]
 80015ba:	f022 0203 	bic.w	r2, r2, #3
 80015be:	e705      	b.n	80013cc <_malloc_r+0x2f0>
 80015c0:	f3ca 000b 	ubfx	r0, sl, #0, #12
 80015c4:	2800      	cmp	r0, #0
 80015c6:	f47f aea8 	bne.w	800131a <_malloc_r+0x23e>
 80015ca:	4442      	add	r2, r8
 80015cc:	68bb      	ldr	r3, [r7, #8]
 80015ce:	f042 0201 	orr.w	r2, r2, #1
 80015d2:	605a      	str	r2, [r3, #4]
 80015d4:	e6ec      	b.n	80013b0 <_malloc_r+0x2d4>
 80015d6:	21fe      	movs	r1, #254	; 0xfe
 80015d8:	f04f 0e7f 	mov.w	lr, #127	; 0x7f
 80015dc:	207e      	movs	r0, #126	; 0x7e
 80015de:	e59f      	b.n	8001120 <_malloc_r+0x44>
 80015e0:	2201      	movs	r2, #1
 80015e2:	f04f 0900 	mov.w	r9, #0
 80015e6:	e6c1      	b.n	800136c <_malloc_r+0x290>
 80015e8:	f104 0108 	add.w	r1, r4, #8
 80015ec:	4630      	mov	r0, r6
 80015ee:	f7ff fc8d 	bl	8000f0c <_free_r>
 80015f2:	f8d9 1000 	ldr.w	r1, [r9]
 80015f6:	e6db      	b.n	80013b0 <_malloc_r+0x2d4>
 80015f8:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 80015fc:	d805      	bhi.n	800160a <_malloc_r+0x52e>
 80015fe:	0bda      	lsrs	r2, r3, #15
 8001600:	f102 0178 	add.w	r1, r2, #120	; 0x78
 8001604:	0049      	lsls	r1, r1, #1
 8001606:	3277      	adds	r2, #119	; 0x77
 8001608:	e71e      	b.n	8001448 <_malloc_r+0x36c>
 800160a:	f240 5154 	movw	r1, #1364	; 0x554
 800160e:	428a      	cmp	r2, r1
 8001610:	d805      	bhi.n	800161e <_malloc_r+0x542>
 8001612:	0c9a      	lsrs	r2, r3, #18
 8001614:	f102 017d 	add.w	r1, r2, #125	; 0x7d
 8001618:	0049      	lsls	r1, r1, #1
 800161a:	327c      	adds	r2, #124	; 0x7c
 800161c:	e714      	b.n	8001448 <_malloc_r+0x36c>
 800161e:	21fe      	movs	r1, #254	; 0xfe
 8001620:	227e      	movs	r2, #126	; 0x7e
 8001622:	e711      	b.n	8001448 <_malloc_r+0x36c>
 8001624:	687b      	ldr	r3, [r7, #4]
 8001626:	e784      	b.n	8001532 <_malloc_r+0x456>
 8001628:	08e8      	lsrs	r0, r5, #3
 800162a:	1c43      	adds	r3, r0, #1
 800162c:	005b      	lsls	r3, r3, #1
 800162e:	e605      	b.n	800123c <_malloc_r+0x160>
 8001630:	20000434 	.word	0x20000434

08001634 <__malloc_lock>:
 8001634:	4770      	bx	lr
 8001636:	bf00      	nop

08001638 <__malloc_unlock>:
 8001638:	4770      	bx	lr
 800163a:	bf00      	nop

0800163c <_sbrk_r>:
 800163c:	b538      	push	{r3, r4, r5, lr}
 800163e:	4c07      	ldr	r4, [pc, #28]	; (800165c <_sbrk_r+0x20>)
 8001640:	2300      	movs	r3, #0
 8001642:	4605      	mov	r5, r0
 8001644:	4608      	mov	r0, r1
 8001646:	6023      	str	r3, [r4, #0]
 8001648:	f7fe ff3e 	bl	80004c8 <_sbrk>
 800164c:	1c43      	adds	r3, r0, #1
 800164e:	d000      	beq.n	8001652 <_sbrk_r+0x16>
 8001650:	bd38      	pop	{r3, r4, r5, pc}
 8001652:	6823      	ldr	r3, [r4, #0]
 8001654:	2b00      	cmp	r3, #0
 8001656:	d0fb      	beq.n	8001650 <_sbrk_r+0x14>
 8001658:	602b      	str	r3, [r5, #0]
 800165a:	bd38      	pop	{r3, r4, r5, pc}
 800165c:	20002228 	.word	0x20002228

08001660 <convert>:
	pclk2_freq  =   hclk_freq/convert(clocks->apb2);	// APB2 driven from AHB
 	return;                                           
}
/* Convert 0,4,5,6,7 input to 1,2,4,8,16 */
unsigned int convert(unsigned int ucX)
{	
 8001660:	2301      	movs	r3, #1
	return (ucX == 0)?:(1 << (ucX-3) );
 8001662:	b118      	cbz	r0, 800166c <convert+0xc>
 8001664:	3803      	subs	r0, #3
 8001666:	fa03 f000 	lsl.w	r0, r3, r0
 800166a:	4770      	bx	lr
 800166c:	4618      	mov	r0, r3
//	if (ucX == 0) return 1;
//	return (1 << (ucX-3));	
}
 800166e:	4770      	bx	lr

08001670 <clockspecifysetup>:
 * @brief	: Setup the clocks & bus freq dividers
 * @param	: chase: 0 = use HSI (internal 8 MHz RC osc), 1 = use HSE (external Xtal osc)
 * @return	: static variables are set from input paramaters passed in struct
 ******************************************************************************/
void clockspecifysetup(struct CLOCKS *clocks)
{
 8001670:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	unsigned short usSW;

	RCC_CFGR = 0; 	// JIC we entered with clocks all ready set 
 8001672:	4d59      	ldr	r5, [pc, #356]	; (80017d8 <clockspecifysetup+0x168>)
 8001674:	2300      	movs	r3, #0
 8001676:	602b      	str	r3, [r5, #0]

	/* See Ref manual page 84 (115 for connecitivity line) for diagram of clocks, PLLs, etc. */
	/* Note: Out of reset, the HSI (internal rc osc) is selected and ready. */
	/* Clock control register (Ref manual, page 121)	*/
	switch (clocks->hso)	// Select high speed oscillator source
 8001678:	7803      	ldrb	r3, [r0, #0]
 * @brief	: Setup the clocks & bus freq dividers
 * @param	: chase: 0 = use HSI (internal 8 MHz RC osc), 1 = use HSE (external Xtal osc)
 * @return	: static variables are set from input paramaters passed in struct
 ******************************************************************************/
void clockspecifysetup(struct CLOCKS *clocks)
{
 800167a:	4601      	mov	r1, r0
	RCC_CFGR = 0; 	// JIC we entered with clocks all ready set 

	/* See Ref manual page 84 (115 for connecitivity line) for diagram of clocks, PLLs, etc. */
	/* Note: Out of reset, the HSI (internal rc osc) is selected and ready. */
	/* Clock control register (Ref manual, page 121)	*/
	switch (clocks->hso)	// Select high speed oscillator source
 800167c:	2b04      	cmp	r3, #4
 800167e:	d834      	bhi.n	80016ea <clockspecifysetup+0x7a>
 8001680:	e8df f003 	tbb	[pc, r3]
 8001684:	160b0334 	.word	0x160b0334
 8001688:	23          	.byte	0x23
 8001689:	00          	.byte	0x00
		/* No action needed needed since HSI is already running and ready.  
			This osc as system clock is what got us to this point! */
		usSW = 0x00;				// SWS = HSI as system clock
		break;
	case 1: // Use external xtal controlled osc
		RCC_CR = RCC_CR_HSEON;			// Start hi-speed external oscillator
 800168a:	4b54      	ldr	r3, [pc, #336]	; (80017dc <clockspecifysetup+0x16c>)
 800168c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8001690:	601a      	str	r2, [r3, #0]
		while ((RCC_CR & (RCC_CR_HSERDY)) == 0);// Wait to become ready
 8001692:	681a      	ldr	r2, [r3, #0]
 8001694:	0397      	lsls	r7, r2, #14
 8001696:	d5fc      	bpl.n	8001692 <clockspecifysetup+0x22>
 8001698:	e091      	b.n	80017be <clockspecifysetup+0x14e>
		usSW = 0x01;				// SWS = HSE as system clock
//RCC_CR &= ~RCC_CR_HSION;	// Turn off HSI osc
		break;
	case 2: // Use external signal input
		RCC_CR = RCC_CR_HSEBYP;			// By-pass external osc and use external signal
 800169a:	4b50      	ldr	r3, [pc, #320]	; (80017dc <clockspecifysetup+0x16c>)
 800169c:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 80016a0:	601a      	str	r2, [r3, #0]
		RCC_CR = RCC_CR_HSEON;			// Start hi-speed external clock
 80016a2:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 80016a6:	601a      	str	r2, [r3, #0]
		while ((RCC_CR & (RCC_CR_HSERDY)) == 0);// Wait to become ready
 80016a8:	681a      	ldr	r2, [r3, #0]
 80016aa:	0396      	lsls	r6, r2, #14
 80016ac:	d5fc      	bpl.n	80016a8 <clockspecifysetup+0x38>
 80016ae:	e086      	b.n	80017be <clockspecifysetup+0x14e>
		usSW = 0x01;				// SWS = HSE as system clock
		break;
	case 3: // Use remapped external osc xtal
		AFIO_MAPR |= (1 << 15); 		// Bit 15 PD01_REMAP: Port D0/Port D1 mapping on OSC_IN/OSC_OUT		
 80016b0:	4a4b      	ldr	r2, [pc, #300]	; (80017e0 <clockspecifysetup+0x170>)
 80016b2:	6813      	ldr	r3, [r2, #0]
 80016b4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80016b8:	6013      	str	r3, [r2, #0]
		RCC_CR = RCC_CR_HSEON;			// Start oscillators hi-speed internal and external
 80016ba:	4b48      	ldr	r3, [pc, #288]	; (80017dc <clockspecifysetup+0x16c>)
 80016bc:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 80016c0:	601a      	str	r2, [r3, #0]
		while ((RCC_CR & (RCC_CR_HSERDY)) == 0);// Wait to become ready
 80016c2:	681a      	ldr	r2, [r3, #0]
 80016c4:	0394      	lsls	r4, r2, #14
 80016c6:	d5fc      	bpl.n	80016c2 <clockspecifysetup+0x52>
 80016c8:	e079      	b.n	80017be <clockspecifysetup+0x14e>
		usSW = 0x01;				// SWS = HSE as system clock
		break;
	case 4: // Use remapped external osc signal
		AFIO_MAPR |= (1 << 15); 		// Bit 15 PD01_REMAP: Port D0/Port D1 mapping on OSC_IN/OSC_OUT		
 80016ca:	4a45      	ldr	r2, [pc, #276]	; (80017e0 <clockspecifysetup+0x170>)
 80016cc:	6813      	ldr	r3, [r2, #0]
 80016ce:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80016d2:	6013      	str	r3, [r2, #0]
		RCC_CR = RCC_CR_HSEBYP;			// By-pass external osc and use external signal
 80016d4:	4b41      	ldr	r3, [pc, #260]	; (80017dc <clockspecifysetup+0x16c>)
 80016d6:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 80016da:	601a      	str	r2, [r3, #0]
		RCC_CR = RCC_CR_HSEON;			// Start hi-speed external clock
 80016dc:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 80016e0:	601a      	str	r2, [r3, #0]
		while ((RCC_CR & (RCC_CR_HSERDY)) == 0);// Wait to become ready
 80016e2:	681a      	ldr	r2, [r3, #0]
 80016e4:	0390      	lsls	r0, r2, #14
 80016e6:	d5fc      	bpl.n	80016e2 <clockspecifysetup+0x72>
 80016e8:	e069      	b.n	80017be <clockspecifysetup+0x14e>
 80016ea:	e7fe      	b.n	80016ea <clockspecifysetup+0x7a>
	default: // Oh oh. We are screwed!
		while (1==1);
	}

	/* Compute the SYSCLK freq */
	sysclk_freq = (clocks->freq *  pllmulxtbl[clocks->pllmul] ) / /* Numerator = multiplies of freq */\
 80016ec:	4b3d      	ldr	r3, [pc, #244]	; (80017e4 <clockspecifysetup+0x174>)
 80016ee:	7842      	ldrb	r2, [r0, #1]
 80016f0:	5c98      	ldrb	r0, [r3, r2]
 80016f2:	688b      	ldr	r3, [r1, #8]
 80016f4:	4343      	muls	r3, r0
 80016f6:	78c8      	ldrb	r0, [r1, #3]
 80016f8:	3001      	adds	r0, #1
 80016fa:	0040      	lsls	r0, r0, #1
 80016fc:	fbb3 f3f0 	udiv	r3, r3, r0
		      (2 * (clocks->pllxtpre + 1) );	// Note: '2 *' is because 6.5x comes in as 13
	if ( (clocks->hso == 0) && (clocks->pllmul > 0) )	
 8001700:	b91a      	cbnz	r2, 800170a <clockspecifysetup+0x9a>
	switch (clocks->hso)	// Select high speed oscillator source
	{
	case 0:	// Use internal 8 Mhz rc osc
		/* No action needed needed since HSI is already running and ready.  
			This osc as system clock is what got us to this point! */
		usSW = 0x00;				// SWS = HSI as system clock
 8001702:	4614      	mov	r4, r2
	default: // Oh oh. We are screwed!
		while (1==1);
	}

	/* Compute the SYSCLK freq */
	sysclk_freq = (clocks->freq *  pllmulxtbl[clocks->pllmul] ) / /* Numerator = multiplies of freq */\
 8001704:	4838      	ldr	r0, [pc, #224]	; (80017e8 <clockspecifysetup+0x178>)
 8001706:	6003      	str	r3, [r0, #0]
 8001708:	e003      	b.n	8001712 <clockspecifysetup+0xa2>
		      (2 * (clocks->pllxtpre + 1) );	// Note: '2 *' is because 6.5x comes in as 13
	if ( (clocks->hso == 0) && (clocks->pllmul > 0) )	
		sysclk_freq /= 2;	/* PLL with the HSI source gets an extra divide by 2 */
 800170a:	4837      	ldr	r0, [pc, #220]	; (80017e8 <clockspecifysetup+0x178>)
 800170c:	085b      	lsrs	r3, r3, #1
 800170e:	6003      	str	r3, [r0, #0]
	switch (clocks->hso)	// Select high speed oscillator source
	{
	case 0:	// Use internal 8 Mhz rc osc
		/* No action needed needed since HSI is already running and ready.  
			This osc as system clock is what got us to this point! */
		usSW = 0x00;				// SWS = HSI as system clock
 8001710:	2400      	movs	r4, #0
	

	/* Flash access control register (Ref manual, page 54) */
	// Determine flash wait states based on SYSCLKX frequency
	// Less 0 - 24 MHz use default of 0 wait 
	if (sysclk_freq > 24000000)		// 0-24 MHz
 8001712:	4b35      	ldr	r3, [pc, #212]	; (80017e8 <clockspecifysetup+0x178>)
 8001714:	4835      	ldr	r0, [pc, #212]	; (80017ec <clockspecifysetup+0x17c>)
 8001716:	681b      	ldr	r3, [r3, #0]
 8001718:	4283      	cmp	r3, r0
 800171a:	d906      	bls.n	800172a <clockspecifysetup+0xba>
	{
		if (sysclk_freq <= 48000000)	// 24-48MHz
 800171c:	4834      	ldr	r0, [pc, #208]	; (80017f0 <clockspecifysetup+0x180>)
 800171e:	4283      	cmp	r3, r0
 8001720:	4834      	ldr	r0, [pc, #208]	; (80017f4 <clockspecifysetup+0x184>)
			FLASH_ACR = 0x31;	// One wait + defaults
 8001722:	bf94      	ite	ls
 8001724:	2631      	movls	r6, #49	; 0x31
		else
			FLASH_ACR = 0x32;	// 48-72MHz, two waits + defaults
 8001726:	2632      	movhi	r6, #50	; 0x32
 8001728:	6006      	str	r6, [r0, #0]
	}

	/* Clock configuraton register (Ref manual, page 123)	*/
	// Setup up bus dividers
	RCC_CFGR = (clocks->apb2  << 11)  |	/* ABP2 prescaler bit code (max of 36 MHz)	*/ 
		   (clocks->apb1  <<  8)  |	/* APB1 prescaler bit code			*/ 
 800172a:	7908      	ldrb	r0, [r1, #4]
			FLASH_ACR = 0x32;	// 48-72MHz, two waits + defaults
	}

	/* Clock configuraton register (Ref manual, page 123)	*/
	// Setup up bus dividers
	RCC_CFGR = (clocks->apb2  << 11)  |	/* ABP2 prescaler bit code (max of 36 MHz)	*/ 
 800172c:	794e      	ldrb	r6, [r1, #5]
		   (clocks->apb1  <<  8)  |	/* APB1 prescaler bit code			*/ 
		   (clocks->ahb   <<  4)  ;	/* AHB  prescaler bit code			*/	
 800172e:	798f      	ldrb	r7, [r1, #6]
			FLASH_ACR = 0x32;	// 48-72MHz, two waits + defaults
	}

	/* Clock configuraton register (Ref manual, page 123)	*/
	// Setup up bus dividers
	RCC_CFGR = (clocks->apb2  << 11)  |	/* ABP2 prescaler bit code (max of 36 MHz)	*/ 
 8001730:	ea4f 2e00 	mov.w	lr, r0, lsl #8
 8001734:	ea4e 2ec6 	orr.w	lr, lr, r6, lsl #11
 8001738:	ea4e 1e07 	orr.w	lr, lr, r7, lsl #4
 800173c:	f8df c098 	ldr.w	ip, [pc, #152]	; 80017d8 <clockspecifysetup+0x168>
 8001740:	f8c5 e000 	str.w	lr, [r5]
		   (clocks->apb1  <<  8)  |	/* APB1 prescaler bit code			*/ 
		   (clocks->ahb   <<  4)  ;	/* AHB  prescaler bit code			*/	

	/* PLL(s) setup, if used */
	if (clocks->pllmul > 0)	// If PLL is zero, then that 
 8001744:	b1aa      	cbz	r2, 8001772 <clockspecifysetup+0x102>
	{	// See page 84, 93. Ref Manual
		RCC_CFGR |=     (clocks->pllmul   << 18)  | /* Multiplier code 	(0-15)		*/ 
 8001746:	78cc      	ldrb	r4, [r1, #3]
 8001748:	0492      	lsls	r2, r2, #18
 800174a:	ea42 4444 	orr.w	r4, r2, r4, lsl #17
 800174e:	788a      	ldrb	r2, [r1, #2]
 8001750:	f8dc e000 	ldr.w	lr, [ip]
 8001754:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
 8001758:	ea42 020e 	orr.w	r2, r2, lr
 800175c:	f8cc 2000 	str.w	r2, [ip]
				(clocks->pllxtpre << 17)  | /* HSE divider for PL source 	*/
			        (clocks->pllsrc   << 16)  ; /* PLL source: HSI or HSE	 	*/

		// Enable PLL
		RCC_CR |= (1<<24);			// PLLON:  Turn PLL on
 8001760:	4a1e      	ldr	r2, [pc, #120]	; (80017dc <clockspecifysetup+0x16c>)
 8001762:	6811      	ldr	r1, [r2, #0]
 8001764:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
 8001768:	6011      	str	r1, [r2, #0]
		while ((RCC_CR & (1<<25) ) == 0);	// PLLRDY: Wait for PLL to become ready
 800176a:	6811      	ldr	r1, [r2, #0]
 800176c:	0189      	lsls	r1, r1, #6
 800176e:	d5fc      	bpl.n	800176a <clockspecifysetup+0xfa>

		// Select PLL as system clock source 
		usSW = 0x02;				// SWS = PLL for system clock
 8001770:	2402      	movs	r4, #2
	}

	/* Switch the system clock source to the one specified */
	RCC_CFGR = (RCC_CFGR & ~0x03) | usSW;		// Set system clock source (it has been running on HSI (internal 8 MHz rc clock)
 8001772:	682a      	ldr	r2, [r5, #0]
 8001774:	f022 0203 	bic.w	r2, r2, #3
 8001778:	4322      	orrs	r2, r4
 800177a:	602a      	str	r2, [r5, #0]
	while ( (RCC_CFGR & 0x0c) != (unsigned short)(usSW << 2) );	// Wait until system is running on the clock source
 800177c:	00a4      	lsls	r4, r4, #2
 800177e:	682a      	ldr	r2, [r5, #0]
 8001780:	f002 020c 	and.w	r2, r2, #12
 8001784:	42a2      	cmp	r2, r4
 8001786:	d1fa      	bne.n	800177e <clockspecifysetup+0x10e>

	/* Enable all present GPIOx clocks.  These will be needed to turn on power regulators & switches (see p 103) */
	RCC_APB2ENR |= 0x7c;	// Enable IO ports A thru E
 8001788:	491b      	ldr	r1, [pc, #108]	; (80017f8 <clockspecifysetup+0x188>)
 800178a:	680a      	ldr	r2, [r1, #0]
 800178c:	f042 027c 	orr.w	r2, r2, #124	; 0x7c
 8001790:	600a      	str	r2, [r1, #0]

	/* Compute static variables that other routines will use to for their setup */
	hclk_freq   = sysclk_freq/ahbtbl[(clocks->ahb)];	// AHB bus freq = sysclck/ ahb bus divider
 8001792:	4a14      	ldr	r2, [pc, #80]	; (80017e4 <clockspecifysetup+0x174>)
 8001794:	eb02 0747 	add.w	r7, r2, r7, lsl #1
 8001798:	8a3a      	ldrh	r2, [r7, #16]
 800179a:	fbb3 f2f2 	udiv	r2, r3, r2
 800179e:	4b17      	ldr	r3, [pc, #92]	; (80017fc <clockspecifysetup+0x18c>)
 80017a0:	601a      	str	r2, [r3, #0]
	pclk1_freq  =   hclk_freq/convert(clocks->apb1);	// APB1 driven from AHB (must not exceed 36 MHz)
 80017a2:	f7ff ff5d 	bl	8001660 <convert>
 80017a6:	fbb2 f0f0 	udiv	r0, r2, r0
 80017aa:	4b15      	ldr	r3, [pc, #84]	; (8001800 <clockspecifysetup+0x190>)
 80017ac:	6018      	str	r0, [r3, #0]
	pclk2_freq  =   hclk_freq/convert(clocks->apb2);	// APB2 driven from AHB
 80017ae:	4630      	mov	r0, r6
 80017b0:	f7ff ff56 	bl	8001660 <convert>
 80017b4:	fbb2 f0f0 	udiv	r0, r2, r0
 80017b8:	4b12      	ldr	r3, [pc, #72]	; (8001804 <clockspecifysetup+0x194>)
 80017ba:	6018      	str	r0, [r3, #0]
 	return;                                           
 80017bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	default: // Oh oh. We are screwed!
		while (1==1);
	}

	/* Compute the SYSCLK freq */
	sysclk_freq = (clocks->freq *  pllmulxtbl[clocks->pllmul] ) / /* Numerator = multiplies of freq */\
 80017be:	4b09      	ldr	r3, [pc, #36]	; (80017e4 <clockspecifysetup+0x174>)
 80017c0:	784a      	ldrb	r2, [r1, #1]
		usSW = 0x00;				// SWS = HSI as system clock
		break;
	case 1: // Use external xtal controlled osc
		RCC_CR = RCC_CR_HSEON;			// Start hi-speed external oscillator
		while ((RCC_CR & (RCC_CR_HSERDY)) == 0);// Wait to become ready
		usSW = 0x01;				// SWS = HSE as system clock
 80017c2:	2401      	movs	r4, #1
	default: // Oh oh. We are screwed!
		while (1==1);
	}

	/* Compute the SYSCLK freq */
	sysclk_freq = (clocks->freq *  pllmulxtbl[clocks->pllmul] ) / /* Numerator = multiplies of freq */\
 80017c4:	5c98      	ldrb	r0, [r3, r2]
 80017c6:	688b      	ldr	r3, [r1, #8]
 80017c8:	4343      	muls	r3, r0
 80017ca:	78c8      	ldrb	r0, [r1, #3]
 80017cc:	3001      	adds	r0, #1
 80017ce:	0040      	lsls	r0, r0, #1
 80017d0:	fbb3 f3f0 	udiv	r3, r3, r0
 80017d4:	e796      	b.n	8001704 <clockspecifysetup+0x94>
 80017d6:	bf00      	nop
 80017d8:	40021004 	.word	0x40021004
 80017dc:	40021000 	.word	0x40021000
 80017e0:	40010004 	.word	0x40010004
 80017e4:	08003c88 	.word	0x08003c88
 80017e8:	200010d4 	.word	0x200010d4
 80017ec:	016e3600 	.word	0x016e3600
 80017f0:	02dc6c00 	.word	0x02dc6c00
 80017f4:	40022000 	.word	0x40022000
 80017f8:	40021018 	.word	0x40021018
 80017fc:	200010e0 	.word	0x200010e0
 8001800:	200010dc 	.word	0x200010dc
 8001804:	200010d8 	.word	0x200010d8

08001808 <DTW_counter_init>:
void DTW_counter_init(void)
{
/* Use DTW_CYCCNT counter for timing */
/* CYCCNT counter is in the Cortex-M-series core.  See the following for details 
http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0337g/BABJFFGJ.html */
	*(volatile unsigned int*)0xE000EDFC |= 0x01000000; // SCB_DEMCR = 0x01000000;
 8001808:	4a05      	ldr	r2, [pc, #20]	; (8001820 <DTW_counter_init+0x18>)
 800180a:	6813      	ldr	r3, [r2, #0]
 800180c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8001810:	6013      	str	r3, [r2, #0]
	*(volatile unsigned int*)0xE0001000 |= 0x1;	// Enable DTW_CYCCNT (Data Watch cycle counter)
 8001812:	4a04      	ldr	r2, [pc, #16]	; (8001824 <DTW_counter_init+0x1c>)
 8001814:	6813      	ldr	r3, [r2, #0]
 8001816:	f043 0301 	orr.w	r3, r3, #1
 800181a:	6013      	str	r3, [r2, #0]
 800181c:	4770      	bx	lr
 800181e:	bf00      	nop
 8001820:	e000edfc 	.word	0xe000edfc
 8001824:	e0001000 	.word	0xe0001000

08001828 <uli2a>:

#define PRINTF_LONG_SUPPORT
#ifdef PRINTF_LONG_SUPPORT

static void uli2a(unsigned long int num, unsigned int base, int uc,char * bf)
	{
 8001828:	b5f0      	push	{r4, r5, r6, r7, lr}
	int n=0;
	unsigned int d=1;
 800182a:	2401      	movs	r4, #1
	while (num/d >= base)
 800182c:	fbb0 f5f4 	udiv	r5, r0, r4
 8001830:	428d      	cmp	r5, r1
 8001832:	d301      	bcc.n	8001838 <uli2a+0x10>
		d*=base;		 
 8001834:	434c      	muls	r4, r1
 8001836:	e7f9      	b.n	800182c <uli2a+0x4>
 8001838:	2600      	movs	r6, #0
	while (d!=0) {
 800183a:	b1cc      	cbz	r4, 8001870 <uli2a+0x48>
		int dgt = num / d;
 800183c:	fbb0 f5f4 	udiv	r5, r0, r4
		num%=d;
 8001840:	fb04 0015 	mls	r0, r4, r5, r0
		d/=base;
 8001844:	fbb4 f4f1 	udiv	r4, r4, r1
		if (n || dgt>0|| d==0) {
 8001848:	b91e      	cbnz	r6, 8001852 <uli2a+0x2a>
 800184a:	2d00      	cmp	r5, #0
 800184c:	dc01      	bgt.n	8001852 <uli2a+0x2a>
 800184e:	2c00      	cmp	r4, #0
 8001850:	d1f3      	bne.n	800183a <uli2a+0x12>
			*bf++ = dgt+(dgt<10 ? '0' : (uc ? 'A' : 'a')-10);
 8001852:	2d09      	cmp	r5, #9
 8001854:	f103 0e01 	add.w	lr, r3, #1
 8001858:	dd04      	ble.n	8001864 <uli2a+0x3c>
 800185a:	2a00      	cmp	r2, #0
 800185c:	bf14      	ite	ne
 800185e:	2737      	movne	r7, #55	; 0x37
 8001860:	2757      	moveq	r7, #87	; 0x57
 8001862:	e000      	b.n	8001866 <uli2a+0x3e>
 8001864:	2730      	movs	r7, #48	; 0x30
 8001866:	443d      	add	r5, r7
 8001868:	701d      	strb	r5, [r3, #0]
			++n;
 800186a:	3601      	adds	r6, #1
	while (d!=0) {
		int dgt = num / d;
		num%=d;
		d/=base;
		if (n || dgt>0|| d==0) {
			*bf++ = dgt+(dgt<10 ? '0' : (uc ? 'A' : 'a')-10);
 800186c:	4673      	mov	r3, lr
 800186e:	e7e4      	b.n	800183a <uli2a+0x12>
			++n;
			}
		}
	*bf=0;
 8001870:	701c      	strb	r4, [r3, #0]
 8001872:	bdf0      	pop	{r4, r5, r6, r7, pc}

08001874 <ui2a>:
	}

#endif

static void ui2a(unsigned int num, unsigned int base, int uc,char * bf)
	{
 8001874:	b5f0      	push	{r4, r5, r6, r7, lr}
	int n=0;
	unsigned int d=1;
 8001876:	2401      	movs	r4, #1
	while (num/d >= base)
 8001878:	fbb0 f5f4 	udiv	r5, r0, r4
 800187c:	428d      	cmp	r5, r1
 800187e:	d301      	bcc.n	8001884 <ui2a+0x10>
		d*=base;		
 8001880:	434c      	muls	r4, r1
 8001882:	e7f9      	b.n	8001878 <ui2a+0x4>
 8001884:	2600      	movs	r6, #0
	while (d!=0) {
 8001886:	b1cc      	cbz	r4, 80018bc <ui2a+0x48>
		int dgt = num / d;
 8001888:	fbb0 f5f4 	udiv	r5, r0, r4
		num%= d;
 800188c:	fb04 0015 	mls	r0, r4, r5, r0
		d/=base;
 8001890:	fbb4 f4f1 	udiv	r4, r4, r1
		if (n || dgt>0 || d==0) {
 8001894:	b91e      	cbnz	r6, 800189e <ui2a+0x2a>
 8001896:	2d00      	cmp	r5, #0
 8001898:	dc01      	bgt.n	800189e <ui2a+0x2a>
 800189a:	2c00      	cmp	r4, #0
 800189c:	d1f3      	bne.n	8001886 <ui2a+0x12>
			*bf++ = dgt+(dgt<10 ? '0' : (uc ? 'A' : 'a')-10);
 800189e:	2d09      	cmp	r5, #9
 80018a0:	f103 0e01 	add.w	lr, r3, #1
 80018a4:	dd04      	ble.n	80018b0 <ui2a+0x3c>
 80018a6:	2a00      	cmp	r2, #0
 80018a8:	bf14      	ite	ne
 80018aa:	2737      	movne	r7, #55	; 0x37
 80018ac:	2757      	moveq	r7, #87	; 0x57
 80018ae:	e000      	b.n	80018b2 <ui2a+0x3e>
 80018b0:	2730      	movs	r7, #48	; 0x30
 80018b2:	443d      	add	r5, r7
 80018b4:	701d      	strb	r5, [r3, #0]
			++n;
 80018b6:	3601      	adds	r6, #1
	while (d!=0) {
		int dgt = num / d;
		num%= d;
		d/=base;
		if (n || dgt>0 || d==0) {
			*bf++ = dgt+(dgt<10 ? '0' : (uc ? 'A' : 'a')-10);
 80018b8:	4673      	mov	r3, lr
 80018ba:	e7e4      	b.n	8001886 <ui2a+0x12>
			++n;
			}
		}
	*bf=0;
 80018bc:	701c      	strb	r4, [r3, #0]
 80018be:	bdf0      	pop	{r4, r5, r6, r7, pc}

080018c0 <putchw>:
	*nump=num;
	return ch;
	}

static void putchw(void* putp,putcf putf,int n, char z, char* bf)
	{
 80018c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80018c4:	9d06      	ldr	r5, [sp, #24]
	char fc=z? '0' : ' ';
 80018c6:	2b00      	cmp	r3, #0
	*nump=num;
	return ch;
	}

static void putchw(void* putp,putcf putf,int n, char z, char* bf)
	{
 80018c8:	4606      	mov	r6, r0
 80018ca:	460f      	mov	r7, r1
	char fc=z? '0' : ' ';
	char ch;
	char* p=bf;
 80018cc:	462b      	mov	r3, r5
	return ch;
	}

static void putchw(void* putp,putcf putf,int n, char z, char* bf)
	{
	char fc=z? '0' : ' ';
 80018ce:	bf14      	ite	ne
 80018d0:	f04f 0830 	movne.w	r8, #48	; 0x30
 80018d4:	f04f 0820 	moveq.w	r8, #32
	char ch;
	char* p=bf;
	while (*p++ && n > 0)
 80018d8:	f813 1b01 	ldrb.w	r1, [r3], #1
 80018dc:	b909      	cbnz	r1, 80018e2 <putchw+0x22>
 80018de:	4614      	mov	r4, r2
 80018e0:	e003      	b.n	80018ea <putchw+0x2a>
 80018e2:	2a00      	cmp	r2, #0
 80018e4:	dd08      	ble.n	80018f8 <putchw+0x38>
		n--;
 80018e6:	3a01      	subs	r2, #1
 80018e8:	e7f6      	b.n	80018d8 <putchw+0x18>
	while (n-- > 0) 
 80018ea:	2c00      	cmp	r4, #0
 80018ec:	dd04      	ble.n	80018f8 <putchw+0x38>
		putf(putp,fc);
 80018ee:	4641      	mov	r1, r8
 80018f0:	4630      	mov	r0, r6
 80018f2:	47b8      	blx	r7
 80018f4:	3c01      	subs	r4, #1
 80018f6:	e7f8      	b.n	80018ea <putchw+0x2a>
	while ((ch= *bf++))
 80018f8:	f815 1b01 	ldrb.w	r1, [r5], #1
 80018fc:	b111      	cbz	r1, 8001904 <putchw+0x44>
		putf(putp,ch);
 80018fe:	4630      	mov	r0, r6
 8001900:	47b8      	blx	r7
 8001902:	e7f9      	b.n	80018f8 <putchw+0x38>
	}
 8001904:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08001908 <putcp>:
	va_end(va);
	}

static void putcp(void* p,char c)
	{
	*(*((char**)p))++ = c;
 8001908:	6803      	ldr	r3, [r0, #0]
 800190a:	1c5a      	adds	r2, r3, #1
 800190c:	6002      	str	r2, [r0, #0]
 800190e:	7019      	strb	r1, [r3, #0]
 8001910:	4770      	bx	lr

08001912 <tfp_format>:
	while ((ch= *bf++))
		putf(putp,ch);
	}

void tfp_format(void* putp,putcf putf,char *fmt, va_list va)
	{
 8001912:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001916:	4681      	mov	r9, r0
 8001918:	468a      	mov	sl, r1
 800191a:	4615      	mov	r5, r2
 800191c:	461c      	mov	r4, r3
 800191e:	b089      	sub	sp, #36	; 0x24
#ifdef 	PRINTF_LONG_SUPPORT
					if (lng)
						uli2a(va_arg(va, unsigned long int),10,0,bf);
					else
#endif
					ui2a(va_arg(va, unsigned int),10,0,bf);
 8001920:	af05      	add	r7, sp, #20
	char bf[12];
    
	char ch;


	while ((ch=*(fmt++))) {
 8001922:	7829      	ldrb	r1, [r5, #0]
 8001924:	2900      	cmp	r1, #0
 8001926:	f000 80c4 	beq.w	8001ab2 <tfp_format+0x1a0>
		if (ch!='%') 
 800192a:	2925      	cmp	r1, #37	; 0x25
 800192c:	d001      	beq.n	8001932 <tfp_format+0x20>
	char bf[12];
    
	char ch;


	while ((ch=*(fmt++))) {
 800192e:	3501      	adds	r5, #1
 8001930:	e081      	b.n	8001a36 <tfp_format+0x124>
			char lz=0;
#ifdef 	PRINTF_LONG_SUPPORT
			char lng=0;
#endif
			int w=0;
			ch=*(fmt++);
 8001932:	786a      	ldrb	r2, [r5, #1]
 8001934:	f04f 0800 	mov.w	r8, #0
			if (ch=='0') {
 8001938:	2a30      	cmp	r2, #48	; 0x30
				ch=*(fmt++);
 800193a:	bf0c      	ite	eq
 800193c:	78aa      	ldrbeq	r2, [r5, #2]
			char lz=0;
#ifdef 	PRINTF_LONG_SUPPORT
			char lng=0;
#endif
			int w=0;
			ch=*(fmt++);
 800193e:	1cae      	addne	r6, r5, #2
			if (ch=='0') {
				ch=*(fmt++);
				lz=1;
				}
			if (ch>='0' && ch<='9') {
 8001940:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30

	while ((ch=*(fmt++))) {
		if (ch!='%') 
			putf(putp,ch);
		else {
			char lz=0;
 8001944:	bf12      	itee	ne
 8001946:	f04f 0b00 	movne.w	fp, #0
			char lng=0;
#endif
			int w=0;
			ch=*(fmt++);
			if (ch=='0') {
				ch=*(fmt++);
 800194a:	1cee      	addeq	r6, r5, #3
				lz=1;
 800194c:	f04f 0b01 	moveq.w	fp, #1
				}
			if (ch>='0' && ch<='9') {
 8001950:	2b09      	cmp	r3, #9
 8001952:	d819      	bhi.n	8001988 <tfp_format+0x76>
	ui2a(num,10,0,bf);
	}

static int a2d(char ch)
	{
	if (ch>='0' && ch<='9') 
 8001954:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8001958:	b2d9      	uxtb	r1, r3
 800195a:	2909      	cmp	r1, #9
 800195c:	d805      	bhi.n	800196a <tfp_format+0x58>
	char* p= *src;
	int num=0;
	int digit;
	while ((digit=a2d(ch))>=0) {
		if (digit>base) break;
		num=num*base+digit;
 800195e:	220a      	movs	r2, #10
 8001960:	fb02 3808 	mla	r8, r2, r8, r3
		ch=*p++;
 8001964:	f816 2b01 	ldrb.w	r2, [r6], #1
 8001968:	e7f4      	b.n	8001954 <tfp_format+0x42>

static int a2d(char ch)
	{
	if (ch>='0' && ch<='9') 
		return ch-'0';
	else if (ch>='a' && ch<='f')
 800196a:	f1a2 0361 	sub.w	r3, r2, #97	; 0x61
 800196e:	2b05      	cmp	r3, #5
 8001970:	d802      	bhi.n	8001978 <tfp_format+0x66>
		return ch-'a'+10;
 8001972:	f1a2 0357 	sub.w	r3, r2, #87	; 0x57
 8001976:	e005      	b.n	8001984 <tfp_format+0x72>
	else if (ch>='A' && ch<='F')
 8001978:	f1a2 0341 	sub.w	r3, r2, #65	; 0x41
 800197c:	2b05      	cmp	r3, #5
 800197e:	d803      	bhi.n	8001988 <tfp_format+0x76>
		return ch-'A'+10;
 8001980:	f1a2 0337 	sub.w	r3, r2, #55	; 0x37
	{
	char* p= *src;
	int num=0;
	int digit;
	while ((digit=a2d(ch))>=0) {
		if (digit>base) break;
 8001984:	2b0a      	cmp	r3, #10
 8001986:	ddea      	ble.n	800195e <tfp_format+0x4c>
				}
			if (ch>='0' && ch<='9') {
				ch=a2i(ch,&fmt,10,&w);
				}
#ifdef 	PRINTF_LONG_SUPPORT
			if (ch=='l') {
 8001988:	2a6c      	cmp	r2, #108	; 0x6c
 800198a:	d139      	bne.n	8001a00 <tfp_format+0xee>
				ch=*(fmt++);
 800198c:	7832      	ldrb	r2, [r6, #0]
 800198e:	1c75      	adds	r5, r6, #1
				lng=1;
			}
#endif
			switch (ch) {
 8001990:	2a63      	cmp	r2, #99	; 0x63
 8001992:	d038      	beq.n	8001a06 <tfp_format+0xf4>
 8001994:	d806      	bhi.n	80019a4 <tfp_format+0x92>
 8001996:	2a25      	cmp	r2, #37	; 0x25
 8001998:	d04c      	beq.n	8001a34 <tfp_format+0x122>
 800199a:	2a58      	cmp	r2, #88	; 0x58
 800199c:	d00c      	beq.n	80019b8 <tfp_format+0xa6>
 800199e:	2a00      	cmp	r2, #0
 80019a0:	d1bf      	bne.n	8001922 <tfp_format+0x10>
 80019a2:	e086      	b.n	8001ab2 <tfp_format+0x1a0>
 80019a4:	2a73      	cmp	r2, #115	; 0x73
 80019a6:	d037      	beq.n	8001a18 <tfp_format+0x106>
 80019a8:	d802      	bhi.n	80019b0 <tfp_format+0x9e>
 80019aa:	2a64      	cmp	r2, #100	; 0x64
 80019ac:	d072      	beq.n	8001a94 <tfp_format+0x182>
 80019ae:	e7b8      	b.n	8001922 <tfp_format+0x10>
 80019b0:	2a75      	cmp	r2, #117	; 0x75
 80019b2:	d04f      	beq.n	8001a54 <tfp_format+0x142>
 80019b4:	2a78      	cmp	r2, #120	; 0x78
 80019b6:	d1b4      	bne.n	8001922 <tfp_format+0x10>
					break;
					}
				case 'x': case 'X' : 
#ifdef 	PRINTF_LONG_SUPPORT
					if (lng)
						uli2a(va_arg(va, unsigned long int),16,(ch=='X'),bf);
 80019b8:	463b      	mov	r3, r7
 80019ba:	f1a2 0058 	sub.w	r0, r2, #88	; 0x58
 80019be:	4242      	negs	r2, r0
 80019c0:	f104 0604 	add.w	r6, r4, #4
 80019c4:	4142      	adcs	r2, r0
 80019c6:	2110      	movs	r1, #16
 80019c8:	6820      	ldr	r0, [r4, #0]
 80019ca:	f7ff ff2d 	bl	8001828 <uli2a>
 80019ce:	4634      	mov	r4, r6
 80019d0:	e00e      	b.n	80019f0 <tfp_format+0xde>
			if (ch=='l') {
				ch=*(fmt++);
				lng=1;
			}
#endif
			switch (ch) {
 80019d2:	2a58      	cmp	r2, #88	; 0x58
 80019d4:	d132      	bne.n	8001a3c <tfp_format+0x12a>
#ifdef 	PRINTF_LONG_SUPPORT
					if (lng)
						uli2a(va_arg(va, unsigned long int),16,(ch=='X'),bf);
					else
#endif
					ui2a(va_arg(va, unsigned int),16,(ch=='X'),bf);
 80019d6:	f1a2 0158 	sub.w	r1, r2, #88	; 0x58
 80019da:	424a      	negs	r2, r1
 80019dc:	f104 0504 	add.w	r5, r4, #4
 80019e0:	414a      	adcs	r2, r1
 80019e2:	6820      	ldr	r0, [r4, #0]
 80019e4:	463b      	mov	r3, r7
 80019e6:	2110      	movs	r1, #16
 80019e8:	462c      	mov	r4, r5
 80019ea:	f7ff ff43 	bl	8001874 <ui2a>
 80019ee:	4635      	mov	r5, r6
					putchw(putp,putf,w,lz,bf);
 80019f0:	9700      	str	r7, [sp, #0]
 80019f2:	465b      	mov	r3, fp
 80019f4:	4642      	mov	r2, r8
 80019f6:	4651      	mov	r1, sl
 80019f8:	4648      	mov	r0, r9
 80019fa:	f7ff ff61 	bl	80018c0 <putchw>
					break;
 80019fe:	e790      	b.n	8001922 <tfp_format+0x10>
			if (ch=='l') {
				ch=*(fmt++);
				lng=1;
			}
#endif
			switch (ch) {
 8001a00:	2a63      	cmp	r2, #99	; 0x63
 8001a02:	d105      	bne.n	8001a10 <tfp_format+0xfe>
 8001a04:	4635      	mov	r5, r6
#endif
					ui2a(va_arg(va, unsigned int),16,(ch=='X'),bf);
					putchw(putp,putf,w,lz,bf);
					break;
				case 'c' : 
					putf(putp,(char)(va_arg(va, int)));
 8001a06:	7821      	ldrb	r1, [r4, #0]
 8001a08:	4648      	mov	r0, r9
 8001a0a:	1d26      	adds	r6, r4, #4
 8001a0c:	47d0      	blx	sl
 8001a0e:	e00c      	b.n	8001a2a <tfp_format+0x118>
			if (ch=='l') {
				ch=*(fmt++);
				lng=1;
			}
#endif
			switch (ch) {
 8001a10:	d90d      	bls.n	8001a2e <tfp_format+0x11c>
 8001a12:	2a73      	cmp	r2, #115	; 0x73
 8001a14:	d115      	bne.n	8001a42 <tfp_format+0x130>
 8001a16:	4635      	mov	r5, r6
					break;
				case 'c' : 
					putf(putp,(char)(va_arg(va, int)));
					break;
				case 's' : 
					putchw(putp,putf,w,0,va_arg(va, char*));
 8001a18:	6823      	ldr	r3, [r4, #0]
 8001a1a:	4642      	mov	r2, r8
 8001a1c:	9300      	str	r3, [sp, #0]
 8001a1e:	4651      	mov	r1, sl
 8001a20:	2300      	movs	r3, #0
 8001a22:	4648      	mov	r0, r9
 8001a24:	1d26      	adds	r6, r4, #4
 8001a26:	f7ff ff4b 	bl	80018c0 <putchw>
 8001a2a:	4634      	mov	r4, r6
					break;
 8001a2c:	e779      	b.n	8001922 <tfp_format+0x10>
			if (ch=='l') {
				ch=*(fmt++);
				lng=1;
			}
#endif
			switch (ch) {
 8001a2e:	2a25      	cmp	r2, #37	; 0x25
 8001a30:	d1cf      	bne.n	80019d2 <tfp_format+0xc0>
 8001a32:	4635      	mov	r5, r6
					break;
				case 's' : 
					putchw(putp,putf,w,0,va_arg(va, char*));
					break;
				case '%' :
					putf(putp,ch);
 8001a34:	2125      	movs	r1, #37	; 0x25
 8001a36:	4648      	mov	r0, r9
 8001a38:	47d0      	blx	sl
 8001a3a:	e772      	b.n	8001922 <tfp_format+0x10>
			if (ch=='l') {
				ch=*(fmt++);
				lng=1;
			}
#endif
			switch (ch) {
 8001a3c:	b3ca      	cbz	r2, 8001ab2 <tfp_format+0x1a0>
 8001a3e:	4635      	mov	r5, r6
 8001a40:	e76f      	b.n	8001922 <tfp_format+0x10>
 8001a42:	d802      	bhi.n	8001a4a <tfp_format+0x138>
 8001a44:	2a64      	cmp	r2, #100	; 0x64
 8001a46:	d015      	beq.n	8001a74 <tfp_format+0x162>
 8001a48:	e7f9      	b.n	8001a3e <tfp_format+0x12c>
 8001a4a:	2a75      	cmp	r2, #117	; 0x75
 8001a4c:	d007      	beq.n	8001a5e <tfp_format+0x14c>
 8001a4e:	2a78      	cmp	r2, #120	; 0x78
 8001a50:	d0c1      	beq.n	80019d6 <tfp_format+0xc4>
 8001a52:	e7f4      	b.n	8001a3e <tfp_format+0x12c>
				case 0: 
					goto abort;
				case 'u' : {
#ifdef 	PRINTF_LONG_SUPPORT
					if (lng)
						uli2a(va_arg(va, unsigned long int),10,0,bf);
 8001a54:	1d26      	adds	r6, r4, #4
 8001a56:	463b      	mov	r3, r7
 8001a58:	2200      	movs	r2, #0
 8001a5a:	210a      	movs	r1, #10
 8001a5c:	e7b4      	b.n	80019c8 <tfp_format+0xb6>
					else
#endif
					ui2a(va_arg(va, unsigned int),10,0,bf);
 8001a5e:	1d23      	adds	r3, r4, #4
 8001a60:	9303      	str	r3, [sp, #12]
 8001a62:	463b      	mov	r3, r7
 8001a64:	6820      	ldr	r0, [r4, #0]
 8001a66:	2200      	movs	r2, #0
 8001a68:	210a      	movs	r1, #10
 8001a6a:	f7ff ff03 	bl	8001874 <ui2a>
 8001a6e:	4635      	mov	r5, r6
 8001a70:	9c03      	ldr	r4, [sp, #12]
 8001a72:	e7bd      	b.n	80019f0 <tfp_format+0xde>
#ifdef 	PRINTF_LONG_SUPPORT
					if (lng)
						li2a(va_arg(va, unsigned long int),bf);
					else
#endif
					i2a(va_arg(va, int),bf);
 8001a74:	6820      	ldr	r0, [r4, #0]
 8001a76:	1d23      	adds	r3, r4, #4
	*bf=0;
	}

static void i2a (int num, char * bf)
	{
	if (num<0) {
 8001a78:	2800      	cmp	r0, #0
#ifdef 	PRINTF_LONG_SUPPORT
					if (lng)
						li2a(va_arg(va, unsigned long int),bf);
					else
#endif
					i2a(va_arg(va, int),bf);
 8001a7a:	9303      	str	r3, [sp, #12]
	*bf=0;
	}

static void i2a (int num, char * bf)
	{
	if (num<0) {
 8001a7c:	da08      	bge.n	8001a90 <tfp_format+0x17e>
		num=-num;
		*bf++ = '-';
 8001a7e:	232d      	movs	r3, #45	; 0x2d
 8001a80:	f88d 3014 	strb.w	r3, [sp, #20]
	}

static void i2a (int num, char * bf)
	{
	if (num<0) {
		num=-num;
 8001a84:	4240      	negs	r0, r0
		*bf++ = '-';
 8001a86:	f10d 0315 	add.w	r3, sp, #21
		}
	ui2a(num,10,0,bf);
 8001a8a:	2200      	movs	r2, #0
 8001a8c:	210a      	movs	r1, #10
 8001a8e:	e7ec      	b.n	8001a6a <tfp_format+0x158>
	*bf=0;
	}

static void i2a (int num, char * bf)
	{
	if (num<0) {
 8001a90:	463b      	mov	r3, r7
 8001a92:	e7fa      	b.n	8001a8a <tfp_format+0x178>
 8001a94:	6820      	ldr	r0, [r4, #0]
					break;
					}
				case 'd' :  {
#ifdef 	PRINTF_LONG_SUPPORT
					if (lng)
						li2a(va_arg(va, unsigned long int),bf);
 8001a96:	1d26      	adds	r6, r4, #4
	*bf=0;
	}

static void li2a (long num, char * bf)
	{
	if (num<0) {
 8001a98:	2800      	cmp	r0, #0
 8001a9a:	da08      	bge.n	8001aae <tfp_format+0x19c>
		num=-num;
		*bf++ = '-';
 8001a9c:	232d      	movs	r3, #45	; 0x2d
 8001a9e:	f88d 3014 	strb.w	r3, [sp, #20]
	}

static void li2a (long num, char * bf)
	{
	if (num<0) {
		num=-num;
 8001aa2:	4240      	negs	r0, r0
		*bf++ = '-';
 8001aa4:	f10d 0315 	add.w	r3, sp, #21
		}
	uli2a(num,10,0,bf);
 8001aa8:	2200      	movs	r2, #0
 8001aaa:	210a      	movs	r1, #10
 8001aac:	e78d      	b.n	80019ca <tfp_format+0xb8>
	*bf=0;
	}

static void li2a (long num, char * bf)
	{
	if (num<0) {
 8001aae:	463b      	mov	r3, r7
 8001ab0:	e7fa      	b.n	8001aa8 <tfp_format+0x196>
					break;
				}
			}
		}
	abort:;
	}
 8001ab2:	b009      	add	sp, #36	; 0x24
 8001ab4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08001ab8 <init_printf>:


void init_printf(void* putp,void (*putf) (void*,char))
	{
	stdout_putf=putf;
 8001ab8:	4b01      	ldr	r3, [pc, #4]	; (8001ac0 <init_printf+0x8>)
 8001aba:	6019      	str	r1, [r3, #0]
	stdout_putp=putp;
 8001abc:	6058      	str	r0, [r3, #4]
 8001abe:	4770      	bx	lr
 8001ac0:	200010ec 	.word	0x200010ec

08001ac4 <tfp_printf>:
	}

void tfp_printf(char *fmt, ...)
	{
 8001ac4:	b40f      	push	{r0, r1, r2, r3}
 8001ac6:	b507      	push	{r0, r1, r2, lr}
	va_list va;
	va_start(va,fmt);
	tfp_format(stdout_putp,stdout_putf,fmt,va);
 8001ac8:	4806      	ldr	r0, [pc, #24]	; (8001ae4 <tfp_printf+0x20>)
	stdout_putf=putf;
	stdout_putp=putp;
	}

void tfp_printf(char *fmt, ...)
	{
 8001aca:	ab04      	add	r3, sp, #16
 8001acc:	f853 2b04 	ldr.w	r2, [r3], #4
	va_list va;
	va_start(va,fmt);
	tfp_format(stdout_putp,stdout_putf,fmt,va);
 8001ad0:	6801      	ldr	r1, [r0, #0]
 8001ad2:	6840      	ldr	r0, [r0, #4]
	}

void tfp_printf(char *fmt, ...)
	{
	va_list va;
	va_start(va,fmt);
 8001ad4:	9301      	str	r3, [sp, #4]
	tfp_format(stdout_putp,stdout_putf,fmt,va);
 8001ad6:	f7ff ff1c 	bl	8001912 <tfp_format>
	va_end(va);
	}
 8001ada:	b003      	add	sp, #12
 8001adc:	f85d eb04 	ldr.w	lr, [sp], #4
 8001ae0:	b004      	add	sp, #16
 8001ae2:	4770      	bx	lr
 8001ae4:	200010ec 	.word	0x200010ec

08001ae8 <tfp_sprintf>:
	}



void tfp_sprintf(char* s,char *fmt, ...)
	{
 8001ae8:	b40e      	push	{r1, r2, r3}
 8001aea:	b50f      	push	{r0, r1, r2, r3, lr}
 8001aec:	ab05      	add	r3, sp, #20
 8001aee:	f853 2b04 	ldr.w	r2, [r3], #4
 8001af2:	9001      	str	r0, [sp, #4]
	va_list va;
	va_start(va,fmt);
	tfp_format(&s,putcp,fmt,va);
 8001af4:	4906      	ldr	r1, [pc, #24]	; (8001b10 <tfp_sprintf+0x28>)
 8001af6:	a801      	add	r0, sp, #4


void tfp_sprintf(char* s,char *fmt, ...)
	{
	va_list va;
	va_start(va,fmt);
 8001af8:	9303      	str	r3, [sp, #12]
	tfp_format(&s,putcp,fmt,va);
 8001afa:	f7ff ff0a 	bl	8001912 <tfp_format>
	va_end(va);
	}

static void putcp(void* p,char c)
	{
	*(*((char**)p))++ = c;
 8001afe:	9b01      	ldr	r3, [sp, #4]
 8001b00:	2200      	movs	r2, #0
 8001b02:	701a      	strb	r2, [r3, #0]
	va_list va;
	va_start(va,fmt);
	tfp_format(&s,putcp,fmt,va);
	putcp(&s,0);
	va_end(va);
	}
 8001b04:	b004      	add	sp, #16
 8001b06:	f85d eb04 	ldr.w	lr, [sp], #4
 8001b0a:	b003      	add	sp, #12
 8001b0c:	4770      	bx	lr
 8001b0e:	bf00      	nop
 8001b10:	08001909 	.word	0x08001909

08001b14 <Reset_Handler>:
extern int main(void);                /* Application's main function */
extern void SystemInit(void);         /* STM's system init? */


void Reset_Handler(void)
{
 8001b14:	b508      	push	{r3, lr}
 8001b16:	4a0a      	ldr	r2, [pc, #40]	; (8001b40 <Reset_Handler+0x2c>)
 8001b18:	4b0a      	ldr	r3, [pc, #40]	; (8001b44 <Reset_Handler+0x30>)

  /* Copy initial values for static variables (from flash to SRAM) */

  pX = &__data_image;		/* (from) Beginning of data image in ROM */
  pY = &__data_section_start; 	/*   (to) Beginning of data in RAM */
  while ( pY < &__data_image_end ) *pY++ = *pX++;
 8001b1a:	490b      	ldr	r1, [pc, #44]	; (8001b48 <Reset_Handler+0x34>)
 8001b1c:	428b      	cmp	r3, r1
 8001b1e:	d204      	bcs.n	8001b2a <Reset_Handler+0x16>
 8001b20:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 8001b24:	f803 0b01 	strb.w	r0, [r3], #1
 8001b28:	e7f8      	b.n	8001b1c <Reset_Handler+0x8>
 8001b2a:	4b08      	ldr	r3, [pc, #32]	; (8001b4c <Reset_Handler+0x38>)

  pX = &_start_of_bss;
  /* Zero fill the .bss section. */
  while ( pX < &_end_of_bss) *pX++ = 0;
 8001b2c:	4a08      	ldr	r2, [pc, #32]	; (8001b50 <Reset_Handler+0x3c>)
 8001b2e:	2100      	movs	r1, #0
 8001b30:	4293      	cmp	r3, r2
 8001b32:	d202      	bcs.n	8001b3a <Reset_Handler+0x26>
 8001b34:	f803 1b01 	strb.w	r1, [r3], #1
 8001b38:	e7fa      	b.n	8001b30 <Reset_Handler+0x1c>

  /* Call the application's entry point.*/
  main();
 8001b3a:	f7fe fb49 	bl	80001d0 <main>
 8001b3e:	e7fe      	b.n	8001b3e <Reset_Handler+0x2a>
 8001b40:	0800418b 	.word	0x0800418b
 8001b44:	20000000 	.word	0x20000000
 8001b48:	2000084c 	.word	0x2000084c
 8001b4c:	20000850 	.word	0x20000850
 8001b50:	2000222c 	.word	0x2000222c

08001b54 <USART1_rxinttxint_init>:
 * @param	: u16 XmtLineSize	- size of each line buffer 		(e.g. 80)
 * @param	: u16 NumberXmtLines	- number of xmt line buffers		(e.g. 2)
 * @return	: 0 = success; 1 = fail malloc; 2 = RcvLineSize zero; 3 = NumberRcvLines = 0; 
 *******************************************************************************/
u16 USART1_rxinttxint_init (u32 BaudRate,u16 RcvLineSize, u16 NumberRcvLines, u16 XmtLineSize, u16 NumberXmtLines)
{
 8001b54:	b570      	push	{r4, r5, r6, lr}
 8001b56:	4605      	mov	r5, r0
 8001b58:	4608      	mov	r0, r1
 8001b5a:	4611      	mov	r1, r2
	u16 temp;

	/* Setup GPIO pin for GPIO_USART1 tx (PA9) (See Ref manual, page 158) */
	GPIO_CRH(GPIOA) &= ~((0x000f ) << (4*1));	// Clear CNF reset bit 01 = Floating input (reset state)
 8001b5c:	4a19      	ldr	r2, [pc, #100]	; (8001bc4 <USART1_rxinttxint_init+0x70>)
 * @param	: u16 XmtLineSize	- size of each line buffer 		(e.g. 80)
 * @param	: u16 NumberXmtLines	- number of xmt line buffers		(e.g. 2)
 * @return	: 0 = success; 1 = fail malloc; 2 = RcvLineSize zero; 3 = NumberRcvLines = 0; 
 *******************************************************************************/
u16 USART1_rxinttxint_init (u32 BaudRate,u16 RcvLineSize, u16 NumberRcvLines, u16 XmtLineSize, u16 NumberXmtLines)
{
 8001b5e:	461e      	mov	r6, r3
	u16 temp;

	/* Setup GPIO pin for GPIO_USART1 tx (PA9) (See Ref manual, page 158) */
	GPIO_CRH(GPIOA) &= ~((0x000f ) << (4*1));	// Clear CNF reset bit 01 = Floating input (reset state)
 8001b60:	6814      	ldr	r4, [r2, #0]
	GPIO_CRH(GPIOA) |=  (( (GPIO_CNF_OUTPUT_ALTFN_PUSHPULL<<2) | (GPIO_MODE_OUTPUT_50_MHZ) ) << (4*1));
	
	// Enable clock for USART1.
	RCC_APB2ENR |= RCC_APB2ENR_USART1EN;
 8001b62:	4b19      	ldr	r3, [pc, #100]	; (8001bc8 <USART1_rxinttxint_init+0x74>)
u16 USART1_rxinttxint_init (u32 BaudRate,u16 RcvLineSize, u16 NumberRcvLines, u16 XmtLineSize, u16 NumberXmtLines)
{
	u16 temp;

	/* Setup GPIO pin for GPIO_USART1 tx (PA9) (See Ref manual, page 158) */
	GPIO_CRH(GPIOA) &= ~((0x000f ) << (4*1));	// Clear CNF reset bit 01 = Floating input (reset state)
 8001b64:	f024 04f0 	bic.w	r4, r4, #240	; 0xf0
 8001b68:	6014      	str	r4, [r2, #0]
	GPIO_CRH(GPIOA) |=  (( (GPIO_CNF_OUTPUT_ALTFN_PUSHPULL<<2) | (GPIO_MODE_OUTPUT_50_MHZ) ) << (4*1));
 8001b6a:	6814      	ldr	r4, [r2, #0]
 8001b6c:	f044 04b0 	orr.w	r4, r4, #176	; 0xb0
 8001b70:	6014      	str	r4, [r2, #0]
	
	// Enable clock for USART1.
	RCC_APB2ENR |= RCC_APB2ENR_USART1EN;
 8001b72:	681a      	ldr	r2, [r3, #0]
 8001b74:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001b78:	601a      	str	r2, [r3, #0]

	/* Allocate memory for buffers and setup pointers in control blocks for rcv and xmt */
	/* 'rxint' is the same as for 'rxinttxint'  Just the interrupt routine is different */
	if ( (temp = usartx_rxint_allocatebuffers(RcvLineSize,NumberRcvLines,&pUSARTcbr1)) != 0) return temp;
 8001b7a:	4a14      	ldr	r2, [pc, #80]	; (8001bcc <USART1_rxinttxint_init+0x78>)
 8001b7c:	f000 f974 	bl	8001e68 <usartx_rxint_allocatebuffers>
 8001b80:	b9f8      	cbnz	r0, 8001bc2 <USART1_rxinttxint_init+0x6e>
	/* 'txdma' uses the same tx buffer setup as 'txint' */
	if ( (temp = usartx_txdma_allocatebuffers(XmtLineSize,NumberXmtLines,&pUSARTcbt1)) != 0) return temp+2;
 8001b82:	4a13      	ldr	r2, [pc, #76]	; (8001bd0 <USART1_rxinttxint_init+0x7c>)
 8001b84:	f8bd 1010 	ldrh.w	r1, [sp, #16]
 8001b88:	4630      	mov	r0, r6
 8001b8a:	f000 f8cf 	bl	8001d2c <usartx_txdma_allocatebuffers>
 8001b8e:	4604      	mov	r4, r0
 8001b90:	b110      	cbz	r0, 8001b98 <USART1_rxinttxint_init+0x44>
 8001b92:	3402      	adds	r4, #2
 8001b94:	b2a0      	uxth	r0, r4
 8001b96:	bd70      	pop	{r4, r5, r6, pc}

	/* Set up usart and baudrate */
	/* 'txcir' sets up the usart Tx the same as needed here */
	usartx_txint_usart_init (USART1,BaudRate);// Tx enable
 8001b98:	4629      	mov	r1, r5
 8001b9a:	480e      	ldr	r0, [pc, #56]	; (8001bd4 <USART1_rxinttxint_init+0x80>)
 8001b9c:	f000 fa1d 	bl	8001fda <usartx_txint_usart_init>
	/* 'rxint' of course is the same except for the interrup routine */
	usartx_rxint_usart_init (USART1,BaudRate);// Rx enable and enable interrupt
 8001ba0:	480c      	ldr	r0, [pc, #48]	; (8001bd4 <USART1_rxinttxint_init+0x80>)
 8001ba2:	4629      	mov	r1, r5
 8001ba4:	f000 f98e 	bl	8001ec4 <usartx_rxint_usart_init>

	/* Set and enable interrupt controller USART */
	NVICIPR(NVIC_USART1_IRQ, USART_PRIORITY );	// Set interrupt priority
	NVICISER(NVIC_USART1_IRQ);			// Enable interrupt	
	return 0 ;	// Success	
 8001ba8:	4620      	mov	r0, r4
	usartx_txint_usart_init (USART1,BaudRate);// Tx enable
	/* 'rxint' of course is the same except for the interrup routine */
	usartx_rxint_usart_init (USART1,BaudRate);// Rx enable and enable interrupt

	/* Set and enable interrupt controller USART */
	NVICIPR(NVIC_USART1_IRQ, USART_PRIORITY );	// Set interrupt priority
 8001baa:	4a0b      	ldr	r2, [pc, #44]	; (8001bd8 <USART1_rxinttxint_init+0x84>)
 8001bac:	6813      	ldr	r3, [r2, #0]
	NVICISER(NVIC_USART1_IRQ);			// Enable interrupt	
 8001bae:	f5a2 7248 	sub.w	r2, r2, #800	; 0x320
	usartx_txint_usart_init (USART1,BaudRate);// Tx enable
	/* 'rxint' of course is the same except for the interrup routine */
	usartx_rxint_usart_init (USART1,BaudRate);// Rx enable and enable interrupt

	/* Set and enable interrupt controller USART */
	NVICIPR(NVIC_USART1_IRQ, USART_PRIORITY );	// Set interrupt priority
 8001bb2:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001bb6:	f8c2 3320 	str.w	r3, [r2, #800]	; 0x320
	NVICISER(NVIC_USART1_IRQ);			// Enable interrupt	
 8001bba:	6813      	ldr	r3, [r2, #0]
 8001bbc:	f043 0320 	orr.w	r3, r3, #32
 8001bc0:	6013      	str	r3, [r2, #0]
	return 0 ;	// Success	
}
 8001bc2:	bd70      	pop	{r4, r5, r6, pc}
 8001bc4:	40010804 	.word	0x40010804
 8001bc8:	40021018 	.word	0x40021018
 8001bcc:	200010f8 	.word	0x200010f8
 8001bd0:	200010f4 	.word	0x200010f4
 8001bd4:	40013800 	.word	0x40013800
 8001bd8:	e000e424 	.word	0xe000e424

08001bdc <USART1_IRQHandler>:
/*#######################################################################################
 * ISR routine
 *####################################################################################### */
void USART1_IRQHandler(void)
{
 8001bdc:	b538      	push	{r3, r4, r5, lr}
	/* Receive */
	if ( MEM_ADDR(BITBAND(USART1SR,RXFLAG)) != 0)	// Receive register loaded?
 8001bde:	4b14      	ldr	r3, [pc, #80]	; (8001c30 <USART1_IRQHandler+0x54>)
 8001be0:	681b      	ldr	r3, [r3, #0]
 8001be2:	b143      	cbz	r3, 8001bf6 <USART1_IRQHandler+0x1a>
	{  // Here, receive interrupt flag is on. 
		*pUSARTcbr1->prx_now_i = USART_DR(USART1);	// Read and store char
 8001be4:	4b13      	ldr	r3, [pc, #76]	; (8001c34 <USART1_IRQHandler+0x58>)
 8001be6:	4914      	ldr	r1, [pc, #80]	; (8001c38 <USART1_IRQHandler+0x5c>)
 8001be8:	681a      	ldr	r2, [r3, #0]
 8001bea:	6809      	ldr	r1, [r1, #0]
 8001bec:	6812      	ldr	r2, [r2, #0]
 8001bee:	7011      	strb	r1, [r2, #0]

		/* Advance pointers to line buffers and array of counts and reset when end reached */	
		usartx_rxint_rxisrptradv(pUSARTcbr1);	// Advance pointers common routine
 8001bf0:	6818      	ldr	r0, [r3, #0]
 8001bf2:	f000 f997 	bl	8001f24 <usartx_rxint_rxisrptradv>
	}

	/* Transmit */
	if (MEM_ADDR(BITBAND(USART1CR1,TXFLAG)) != 0)	// Are Tx interrupts enabled?
 8001bf6:	4c11      	ldr	r4, [pc, #68]	; (8001c3c <USART1_IRQHandler+0x60>)
 8001bf8:	6823      	ldr	r3, [r4, #0]
 8001bfa:	b1bb      	cbz	r3, 8001c2c <USART1_IRQHandler+0x50>
	{  // Here, yes.  Transmit interrupts are enabled so check if a tx interrupt
		if (MEM_ADDR(BITBAND(USART1SR,TXFLAG)) != 0)	// Transmit register empty?
 8001bfc:	4b10      	ldr	r3, [pc, #64]	; (8001c40 <USART1_IRQHandler+0x64>)
 8001bfe:	681b      	ldr	r3, [r3, #0]
 8001c00:	b1a3      	cbz	r3, 8001c2c <USART1_IRQHandler+0x50>
		{ // Here, yes.
			USART_DR(USART1) = *pUSARTcbt1->ptx_now_d++;	// Send next char, step pointer
 8001c02:	4d10      	ldr	r5, [pc, #64]	; (8001c44 <USART1_IRQHandler+0x68>)
 8001c04:	6828      	ldr	r0, [r5, #0]
 8001c06:	6883      	ldr	r3, [r0, #8]
 8001c08:	1c5a      	adds	r2, r3, #1
 8001c0a:	6082      	str	r2, [r0, #8]
 8001c0c:	781a      	ldrb	r2, [r3, #0]
 8001c0e:	4b0a      	ldr	r3, [pc, #40]	; (8001c38 <USART1_IRQHandler+0x5c>)
 8001c10:	601a      	str	r2, [r3, #0]
			*pUSARTcbt1->ptx_ctary_now_d -= 1;	// Count down number to send in the line buffer
 8001c12:	69c2      	ldr	r2, [r0, #28]
 8001c14:	8813      	ldrh	r3, [r2, #0]
 8001c16:	3b01      	subs	r3, #1
 8001c18:	b29b      	uxth	r3, r3
 8001c1a:	8013      	strh	r3, [r2, #0]
			if (*pUSARTcbt1->ptx_ctary_now_d == 0) 
 8001c1c:	b933      	cbnz	r3, 8001c2c <USART1_IRQHandler+0x50>
			{ // Here, last char to be sent from this line buffer has been loaded into the tx register
				/* Advance pointers to line buffers and array of counts and reset to beginning when end reached */	
				usartx_txisr_advlnptr(pUSARTcbt1);	// Advance pointer for interrupt pointer ('_d)
 8001c1e:	f000 f8dd 	bl	8001ddc <usartx_txisr_advlnptr>
				/* Are we caught up?  Check beginning of line buffer pointers, mainline versus interrupt  */	
//				if (pUSARTcbt1->ptx_begin_d == pUSARTcbt1->ptx_begin_m) // Interrupt versus Mainline pointers
				if (*pUSARTcbt1->ptx_ctary_now_d == 0)	// Is new line buffer ready?
 8001c22:	682b      	ldr	r3, [r5, #0]
 8001c24:	69db      	ldr	r3, [r3, #28]
 8001c26:	881b      	ldrh	r3, [r3, #0]
 8001c28:	b903      	cbnz	r3, 8001c2c <USART1_IRQHandler+0x50>
				{ // Here, we are caught up with the main (where chars are being added)
					MEM_ADDR(BITBAND(USART1CR1,TXFLAG)) = 0x00;	// Disable Tx interrupts
 8001c2a:	6023      	str	r3, [r4, #0]
 8001c2c:	bd38      	pop	{r3, r4, r5, pc}
 8001c2e:	bf00      	nop
 8001c30:	42270014 	.word	0x42270014
 8001c34:	200010f8 	.word	0x200010f8
 8001c38:	40013804 	.word	0x40013804
 8001c3c:	4227019c 	.word	0x4227019c
 8001c40:	4227001c 	.word	0x4227001c
 8001c44:	200010f4 	.word	0x200010f4

08001c48 <USART1_txint_putc>:
* @brief	: Put char.  Add a char to output buffer
* @param	: Char to be sent
* @return	: 0 = buffer did not overflow; 1 = overflow, chars could be lost
*******************************************************************************/
char USART1_txint_putc(char c)
{
 8001c48:	b510      	push	{r4, lr}
 8001c4a:	4604      	mov	r4, r0
	/* If we have filled all the line buffers, then we are screwed and must wait */
	while (USART1_txint_busy() == 1);	// Loop until buffer free
 8001c4c:	f000 f83c 	bl	8001cc8 <USART1_txint_busy>
 8001c50:	2801      	cmp	r0, #1
 8001c52:	d0fb      	beq.n	8001c4c <USART1_txint_putc+0x4>

 	*pUSARTcbt1->ptx_now_m++ = c;	// Store a char
 8001c54:	4b09      	ldr	r3, [pc, #36]	; (8001c7c <USART1_txint_putc+0x34>)
 8001c56:	6819      	ldr	r1, [r3, #0]
 8001c58:	680a      	ldr	r2, [r1, #0]
 8001c5a:	1c50      	adds	r0, r2, #1
 8001c5c:	6008      	str	r0, [r1, #0]
 8001c5e:	7014      	strb	r4, [r2, #0]

	/* Are we at the end of the buffer? */
	if (pUSARTcbt1->ptx_now_m >= (pUSARTcbt1->ptx_begin_m + pUSARTcbt1->tx_ln_sz) ) 
 8001c60:	681a      	ldr	r2, [r3, #0]
 8001c62:	8c93      	ldrh	r3, [r2, #36]	; 0x24
 8001c64:	6851      	ldr	r1, [r2, #4]
 8001c66:	6812      	ldr	r2, [r2, #0]
 8001c68:	440b      	add	r3, r1
 8001c6a:	429a      	cmp	r2, r3
 8001c6c:	d303      	bcc.n	8001c76 <USART1_txint_putc+0x2e>
	{ // Here we hit the end of the line buffer, so 
		USART1_txint_send();	// Step to next line buffer
 8001c6e:	f000 f81d 	bl	8001cac <USART1_txint_send>
		return 1;		// Show caller we hit the end
 8001c72:	2001      	movs	r0, #1
 8001c74:	bd10      	pop	{r4, pc}
	}
 	return 0;	
 8001c76:	2000      	movs	r0, #0
}
 8001c78:	bd10      	pop	{r4, pc}
 8001c7a:	bf00      	nop
 8001c7c:	200010f4 	.word	0x200010f4

08001c80 <USART1_txint_puts>:
* void USART1_txint_puts(char* p);
* @brief	: p: Pointer to zero terminated string
* @return	: 1 = all line buffers filled; 0 = free line buffer(s)
*******************************************************************************/
void USART1_txint_puts(char* p)
{
 8001c80:	b538      	push	{r3, r4, r5, lr}
 8001c82:	4604      	mov	r4, r0
// the DMA then we return the pointer to the mainline and the bozo writing that program can 
// wrestle with the problem of what to do.
	do 
	{
		/* Be sure we don't try to load into a buffer that is being sent, or to be sent */
		while (*(volatile char*)pUSARTcbt1->ptx_ctary_now_m != 0);	// Loop until a buffer is free
 8001c84:	4d08      	ldr	r5, [pc, #32]	; (8001ca8 <USART1_txint_puts+0x28>)
 8001c86:	6829      	ldr	r1, [r5, #0]
 8001c88:	698a      	ldr	r2, [r1, #24]
 8001c8a:	7813      	ldrb	r3, [r2, #0]
 8001c8c:	2b00      	cmp	r3, #0
 8001c8e:	d1fc      	bne.n	8001c8a <USART1_txint_puts+0xa>

		/* Move the string into the buffer quickly with this assembly program */
		p = usartx_putsS(p,&pUSARTcbt1->ptx_now_m,(pUSARTcbt1->ptx_begin_m + pUSARTcbt1->tx_ln_sz) );
 8001c90:	8c8b      	ldrh	r3, [r1, #36]	; 0x24
 8001c92:	684a      	ldr	r2, [r1, #4]
 8001c94:	4620      	mov	r0, r4
 8001c96:	441a      	add	r2, r3
 8001c98:	f000 f820 	bl	8001cdc <usartx_putsS>

		/* Step to the next buffer, and if buffer end was hit, start Tx if not already sending */
		if ( p != 0)
 8001c9c:	4604      	mov	r4, r0
 8001c9e:	b110      	cbz	r0, 8001ca6 <USART1_txint_puts+0x26>
			USART1_txint_send();
 8001ca0:	f000 f804 	bl	8001cac <USART1_txint_send>
 8001ca4:	e7ef      	b.n	8001c86 <USART1_txint_puts+0x6>
 8001ca6:	bd38      	pop	{r3, r4, r5, pc}
 8001ca8:	200010f4 	.word	0x200010f4

08001cac <USART1_txint_send>:
* void USART1_txint_send(void);
* @brief	: Step to next line tx line buffer; if DMA not sending, start it now.
* @return	: none
*******************************************************************************/
void USART1_txint_send(void)
{
 8001cac:	b508      	push	{r3, lr}
	/* Common to all three USARTS */
	if (usartx_txint_send(pUSARTcbt1) != 0) return;
 8001cae:	4b04      	ldr	r3, [pc, #16]	; (8001cc0 <USART1_txint_send+0x14>)
 8001cb0:	6818      	ldr	r0, [r3, #0]
 8001cb2:	f000 f957 	bl	8001f64 <usartx_txint_send>
 8001cb6:	b910      	cbnz	r0, 8001cbe <USART1_txint_send+0x12>
			
	MEM_ADDR(BITBAND(USART1CR1,TXFLAG)) = 0x01;	// Enable Tx interrupts
 8001cb8:	4b02      	ldr	r3, [pc, #8]	; (8001cc4 <USART1_txint_send+0x18>)
 8001cba:	2201      	movs	r2, #1
 8001cbc:	601a      	str	r2, [r3, #0]
 8001cbe:	bd08      	pop	{r3, pc}
 8001cc0:	200010f4 	.word	0x200010f4
 8001cc4:	4227019c 	.word	0x4227019c

08001cc8 <USART1_txint_busy>:
	   interrupt pointer, then main has filled all the line buffers, so none are free.  If the pointers are
	   the same, but we are not transmitting, then the all the line buffers are free, e.g. the initial
           conditions. 
	*/
//	if (  (MEM_ADDR(BITBAND(USART1CR1,TXFLAG)) == 1) && (pUSARTcbt1->ptx_begin_d == pUSARTcbt1->ptx_begin_m) )
	if (*pUSARTcbt1->ptx_ctary_now_m != 0)
 8001cc8:	4b03      	ldr	r3, [pc, #12]	; (8001cd8 <USART1_txint_busy+0x10>)
 8001cca:	681b      	ldr	r3, [r3, #0]
 8001ccc:	699b      	ldr	r3, [r3, #24]
 8001cce:	8818      	ldrh	r0, [r3, #0]
		return 1;	// Show that no line buffers are free
	return 0;		// Show we are good to go.
}
 8001cd0:	3000      	adds	r0, #0
 8001cd2:	bf18      	it	ne
 8001cd4:	2001      	movne	r0, #1
 8001cd6:	4770      	bx	lr
 8001cd8:	200010f4 	.word	0x200010f4

08001cdc <usartx_putsS>:
 8001cdc:	b418      	push	{r3, r4}
 8001cde:	680c      	ldr	r4, [r1, #0]

08001ce0 <loop>:
 8001ce0:	f810 3b01 	ldrb.w	r3, [r0], #1
 8001ce4:	b12b      	cbz	r3, 8001cf2 <endloop>
 8001ce6:	f804 3b01 	strb.w	r3, [r4], #1
 8001cea:	4294      	cmp	r4, r2
 8001cec:	d3f8      	bcc.n	8001ce0 <loop>
 8001cee:	f014 0f00 	tst.w	r4, #0

08001cf2 <endloop>:
 8001cf2:	bf18      	it	ne
 8001cf4:	2000      	movne	r0, #0
 8001cf6:	600c      	str	r4, [r1, #0]
 8001cf8:	bc18      	pop	{r3, r4}
 8001cfa:	4770      	bx	lr

08001cfc <USART1_txmin_init>:
 *******************************************************************************/
void USART1_txmin_init (u32 BaudRate)
{

	/* Setup GPIO pin for GPIO_USART1 tx (PA9) (See Ref manual, page 158) */
	GPIO_CRH(GPIOA) &= ~((0x000f ) << (4*1));	// Clear CNF reset bit 01 = Floating input (reset state)
 8001cfc:	4b08      	ldr	r3, [pc, #32]	; (8001d20 <USART1_txmin_init+0x24>)
	
	// Enable clock for USART1.
	RCC_APB2ENR |= RCC_APB2ENR_USART1EN;

	/* Set up usart and baudrate */
	usartx_txmin_init (USART1,BaudRate);
 8001cfe:	4601      	mov	r1, r0
 *******************************************************************************/
void USART1_txmin_init (u32 BaudRate)
{

	/* Setup GPIO pin for GPIO_USART1 tx (PA9) (See Ref manual, page 158) */
	GPIO_CRH(GPIOA) &= ~((0x000f ) << (4*1));	// Clear CNF reset bit 01 = Floating input (reset state)
 8001d00:	681a      	ldr	r2, [r3, #0]
	
	// Enable clock for USART1.
	RCC_APB2ENR |= RCC_APB2ENR_USART1EN;

	/* Set up usart and baudrate */
	usartx_txmin_init (USART1,BaudRate);
 8001d02:	4808      	ldr	r0, [pc, #32]	; (8001d24 <USART1_txmin_init+0x28>)
 *******************************************************************************/
void USART1_txmin_init (u32 BaudRate)
{

	/* Setup GPIO pin for GPIO_USART1 tx (PA9) (See Ref manual, page 158) */
	GPIO_CRH(GPIOA) &= ~((0x000f ) << (4*1));	// Clear CNF reset bit 01 = Floating input (reset state)
 8001d04:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8001d08:	601a      	str	r2, [r3, #0]
	GPIO_CRH(GPIOA) |=  (( (GPIO_CNF_OUTPUT_ALTFN_PUSHPULL<<2) | (GPIO_MODE_OUTPUT_50_MHZ) ) << (4*1));
 8001d0a:	681a      	ldr	r2, [r3, #0]
 8001d0c:	f042 02b0 	orr.w	r2, r2, #176	; 0xb0
 8001d10:	601a      	str	r2, [r3, #0]
	
	// Enable clock for USART1.
	RCC_APB2ENR |= RCC_APB2ENR_USART1EN;
 8001d12:	4a05      	ldr	r2, [pc, #20]	; (8001d28 <USART1_txmin_init+0x2c>)
 8001d14:	6813      	ldr	r3, [r2, #0]
 8001d16:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001d1a:	6013      	str	r3, [r2, #0]

	/* Set up usart and baudrate */
	usartx_txmin_init (USART1,BaudRate);
 8001d1c:	f000 b99e 	b.w	800205c <usartx_txmin_init>
 8001d20:	40010804 	.word	0x40010804
 8001d24:	40013800 	.word	0x40013800
 8001d28:	40021018 	.word	0x40021018

08001d2c <usartx_txdma_allocatebuffers>:
 * @param	: numberxmtlines is the number of receive line buffers (e.g. 4)
 * @param	: pUSARTcbtx points to pointer in static memory that points to control block
 * @return	: 0 = success;1 = fail mymallocl; 2 = zero xmtlinesize zero; 3 = numberxmtlinesize less than 2
******************************************************************************/
u16 usartx_txdma_allocatebuffers (u16 xmtlinesize,u16 numberxmtlines, struct USARTCBT** pUSARTcbtx)
{
 8001d2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001d2e:	460d      	mov	r5, r1
 8001d30:	4616      	mov	r6, r2
	u16 i;
	u32* ptr;
	struct USARTCBT* pUSARTcbtl; // Local pointer to control block setup on heap

	/* Zero buffer size would cause trouble */
	if (xmtlinesize == 0 ) return 2;
 8001d32:	4607      	mov	r7, r0
 8001d34:	2800      	cmp	r0, #0
 8001d36:	d02d      	beq.n	8001d94 <usartx_txdma_allocatebuffers+0x68>
	if (numberxmtlines < 2 ) return 3;
 8001d38:	2901      	cmp	r1, #1
 8001d3a:	d92d      	bls.n	8001d98 <usartx_txdma_allocatebuffers+0x6c>

	/* Allocate space and set pointer for the struct USARTcbtx */
	ptr = (u32*)mymalloc(sizeof (struct USARTCBT));
 8001d3c:	2028      	movs	r0, #40	; 0x28
 8001d3e:	f000 f957 	bl	8001ff0 <mymalloc>
	if  ( ptr  == 0)  return 1;
 8001d42:	4604      	mov	r4, r0
 8001d44:	b908      	cbnz	r0, 8001d4a <usartx_txdma_allocatebuffers+0x1e>
 8001d46:	2001      	movs	r0, #1
 8001d48:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	*pUSARTcbtx = (struct USARTCBT*)ptr;	// Initialize static variable used by others
 8001d4a:	6030      	str	r0, [r6, #0]
	 pUSARTcbtl = (struct USARTCBT*)ptr;	

	/* ---------------------------- transmit (dma) buffers and pointers -------------------------- */

	/* Allocate space and set pointer in USARTcbx for transmit line buffers */
	if ( (pUSARTcbtl->ptx_begin = (char*)mymalloc(xmtlinesize * numberxmtlines)) == 0 ) return 1;
 8001d4c:	fb05 f607 	mul.w	r6, r5, r7
 8001d50:	b2b0      	uxth	r0, r6
 8001d52:	f000 f94d 	bl	8001ff0 <mymalloc>
 8001d56:	6120      	str	r0, [r4, #16]
 8001d58:	2800      	cmp	r0, #0
 8001d5a:	d0f4      	beq.n	8001d46 <usartx_txdma_allocatebuffers+0x1a>

	/* These tx pointers start out on the same line buffer */	
	pUSARTcbtl->ptx_begin_m = pUSARTcbtl->ptx_begin;	// Beginning of line being filled (main)
 8001d5c:	6060      	str	r0, [r4, #4]
	pUSARTcbtl->ptx_begin_d = pUSARTcbtl->ptx_begin;	// Beginning of line being sent (dma)
 8001d5e:	60e0      	str	r0, [r4, #12]
	pUSARTcbtl->ptx_now_m   = pUSARTcbtl->ptx_begin;	// Pointer in line being filled (main)
 8001d60:	6020      	str	r0, [r4, #0]
	pUSARTcbtl->ptx_now_d   = pUSARTcbtl->ptx_begin;	// Pointer in line being filled (dma) [not used?]
 8001d62:	60a0      	str	r0, [r4, #8]

	/* Use this for testing for end of line buffers wraparound */
	pUSARTcbtl->ptx_end     = pUSARTcbtl->ptx_begin + (xmtlinesize * numberxmtlines); 
 8001d64:	4430      	add	r0, r6
 8001d66:	6160      	str	r0, [r4, #20]

	/* Save number of tx line buffers */
	pUSARTcbtl->tx_ln_ct = numberxmtlines;

	/* Setup an array with the dma transfer count for each tx line buffer */
	if ( (pUSARTcbtl->ptx_ctary_begin = (mymalloc(sizeof(u16) * numberxmtlines))) == 0 ) return 1;
 8001d68:	0068      	lsls	r0, r5, #1

	/* Use this for testing for end of line buffers wraparound */
	pUSARTcbtl->ptx_end     = pUSARTcbtl->ptx_begin + (xmtlinesize * numberxmtlines); 

	/* Save tx line buffer size */
	pUSARTcbtl->tx_ln_sz = xmtlinesize;
 8001d6a:	84a7      	strh	r7, [r4, #36]	; 0x24

	/* Save number of tx line buffers */
	pUSARTcbtl->tx_ln_ct = numberxmtlines;
 8001d6c:	84e5      	strh	r5, [r4, #38]	; 0x26

	/* Setup an array with the dma transfer count for each tx line buffer */
	if ( (pUSARTcbtl->ptx_ctary_begin = (mymalloc(sizeof(u16) * numberxmtlines))) == 0 ) return 1;
 8001d6e:	b280      	uxth	r0, r0
 8001d70:	f000 f93e 	bl	8001ff0 <mymalloc>
 8001d74:	6220      	str	r0, [r4, #32]
 8001d76:	2800      	cmp	r0, #0
 8001d78:	d0e5      	beq.n	8001d46 <usartx_txdma_allocatebuffers+0x1a>
	pUSARTcbtl->ptx_ctary_now_m = pUSARTcbtl->ptx_ctary_begin;	// Set working pointer, main
	pUSARTcbtl->ptx_ctary_now_d = pUSARTcbtl->ptx_ctary_begin;	// Set working pointer, dma
 8001d7a:	2300      	movs	r3, #0

	/* Set set array counts to zero (used in 'int) */
	for (i = 0; i <numberxmtlines; i++)
		*pUSARTcbtl->ptx_ctary_now_m++ = 0;
 8001d7c:	4619      	mov	r1, r3
	/* Save number of tx line buffers */
	pUSARTcbtl->tx_ln_ct = numberxmtlines;

	/* Setup an array with the dma transfer count for each tx line buffer */
	if ( (pUSARTcbtl->ptx_ctary_begin = (mymalloc(sizeof(u16) * numberxmtlines))) == 0 ) return 1;
	pUSARTcbtl->ptx_ctary_now_m = pUSARTcbtl->ptx_ctary_begin;	// Set working pointer, main
 8001d7e:	61a0      	str	r0, [r4, #24]
	pUSARTcbtl->ptx_ctary_now_d = pUSARTcbtl->ptx_ctary_begin;	// Set working pointer, dma
 8001d80:	61e0      	str	r0, [r4, #28]

	/* Set set array counts to zero (used in 'int) */
	for (i = 0; i <numberxmtlines; i++)
		*pUSARTcbtl->ptx_ctary_now_m++ = 0;
 8001d82:	f820 1013 	strh.w	r1, [r0, r3, lsl #1]
 8001d86:	3301      	adds	r3, #1
	if ( (pUSARTcbtl->ptx_ctary_begin = (mymalloc(sizeof(u16) * numberxmtlines))) == 0 ) return 1;
	pUSARTcbtl->ptx_ctary_now_m = pUSARTcbtl->ptx_ctary_begin;	// Set working pointer, main
	pUSARTcbtl->ptx_ctary_now_d = pUSARTcbtl->ptx_ctary_begin;	// Set working pointer, dma

	/* Set set array counts to zero (used in 'int) */
	for (i = 0; i <numberxmtlines; i++)
 8001d88:	b29a      	uxth	r2, r3
 8001d8a:	4295      	cmp	r5, r2
 8001d8c:	d8f9      	bhi.n	8001d82 <usartx_txdma_allocatebuffers+0x56>
		*pUSARTcbtl->ptx_ctary_now_m++ = 0;
	pUSARTcbtl->ptx_ctary_now_m = pUSARTcbtl->ptx_ctary_begin;	// Set working pointer, main
 8001d8e:	61a0      	str	r0, [r4, #24]

	return 0;
 8001d90:	2000      	movs	r0, #0
 8001d92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	u16 i;
	u32* ptr;
	struct USARTCBT* pUSARTcbtl; // Local pointer to control block setup on heap

	/* Zero buffer size would cause trouble */
	if (xmtlinesize == 0 ) return 2;
 8001d94:	2002      	movs	r0, #2
 8001d96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (numberxmtlines < 2 ) return 3;
 8001d98:	2003      	movs	r0, #3
	for (i = 0; i <numberxmtlines; i++)
		*pUSARTcbtl->ptx_ctary_now_m++ = 0;
	pUSARTcbtl->ptx_ctary_now_m = pUSARTcbtl->ptx_ctary_begin;	// Set working pointer, main

	return 0;
}
 8001d9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08001d9c <usartx_txdma_usart_init>:
 * void usartx_txdma_usart_init (u32 USARTx, u32 BaudRate);
 * @brief	: Setup USART baudrate, Tx for dma
 * @return	: none
******************************************************************************/
void usartx_txdma_usart_init (u32 USARTx, u32 BaudRate)
{
 8001d9c:	b510      	push	{r4, lr}
 8001d9e:	4604      	mov	r4, r0
	/* Set baud rate */
	usartx_setbaud(USARTx,BaudRate);	// Compute divider settings and load BRR
 8001da0:	f000 f938 	bl	8002014 <usartx_setbaud>

 	/* Setup CR2 ------------------------------------------------------------------- */
	/* After reset CR2 is 0x0000 and this is just fine */

	/* Set up CR1 (page 771) ------------------------------------------------------- */
	USART_CR1(USARTx) |= USART_UE | USART_TX_ENABLE;// Set Usart enable, Transmit enable
 8001da4:	68e3      	ldr	r3, [r4, #12]
 8001da6:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8001daa:	f043 0308 	orr.w	r3, r3, #8
 8001dae:	60e3      	str	r3, [r4, #12]
	
	/* Hook up usart tx to dma channel */
	USART_CR3(USARTx) |= USART_DMAT;			// CR3 setup
 8001db0:	6963      	ldr	r3, [r4, #20]
 8001db2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001db6:	6163      	str	r3, [r4, #20]
 8001db8:	bd10      	pop	{r4, pc}

08001dba <usartx_txmain_advlnptr>:
 * @brief	: Advance line buffer pointers for main
******************************************************************************/
void usartx_txmain_advlnptr (struct USARTCBT* pUSARTcbtx)
{
	/* Advance to next line buffer and companion array of char cts */
	pUSARTcbtx->ptx_begin_m     += pUSARTcbtx->tx_ln_sz;	// Line buffer
 8001dba:	6842      	ldr	r2, [r0, #4]
 8001dbc:	8c83      	ldrh	r3, [r0, #36]	; 0x24
 8001dbe:	4413      	add	r3, r2
	pUSARTcbtx->ptx_ctary_now_m += 1;	// Array of char cts
 8001dc0:	6982      	ldr	r2, [r0, #24]
 * @brief	: Advance line buffer pointers for main
******************************************************************************/
void usartx_txmain_advlnptr (struct USARTCBT* pUSARTcbtx)
{
	/* Advance to next line buffer and companion array of char cts */
	pUSARTcbtx->ptx_begin_m     += pUSARTcbtx->tx_ln_sz;	// Line buffer
 8001dc2:	6043      	str	r3, [r0, #4]
	pUSARTcbtx->ptx_ctary_now_m += 1;	// Array of char cts
 8001dc4:	3202      	adds	r2, #2
 8001dc6:	6182      	str	r2, [r0, #24]

	/* Check if at the end of all the line buffers */
	if (pUSARTcbtx->ptx_begin_m >= pUSARTcbtx->ptx_end)
 8001dc8:	6942      	ldr	r2, [r0, #20]
 8001dca:	4293      	cmp	r3, r2
	{ // Here, end of line buffers, reset pointers to beginning
		pUSARTcbtx->ptx_begin_m     = pUSARTcbtx->ptx_begin;	// Line buffer
 8001dcc:	bf21      	itttt	cs
 8001dce:	6903      	ldrcs	r3, [r0, #16]
 8001dd0:	6043      	strcs	r3, [r0, #4]
		pUSARTcbtx->ptx_ctary_now_m = pUSARTcbtx->ptx_ctary_begin;// Array of char cts
 8001dd2:	6a03      	ldrcs	r3, [r0, #32]
 8001dd4:	6183      	strcs	r3, [r0, #24]
	}
	pUSARTcbtx->ptx_now_m = pUSARTcbtx->ptx_begin_m;		// Set new working-within-line pointer
 8001dd6:	6843      	ldr	r3, [r0, #4]
 8001dd8:	6003      	str	r3, [r0, #0]
 8001dda:	4770      	bx	lr

08001ddc <usartx_txisr_advlnptr>:
 * @brief	: Advance line buffer pointers for isr
******************************************************************************/
void usartx_txisr_advlnptr (struct USARTCBT* pUSARTcbtx)
{
	/* Advance to next line buffer and companion array of char cts */
	pUSARTcbtx->ptx_begin_d     += pUSARTcbtx->tx_ln_sz;	// Line buffer
 8001ddc:	68c2      	ldr	r2, [r0, #12]
 8001dde:	8c83      	ldrh	r3, [r0, #36]	; 0x24
 8001de0:	4413      	add	r3, r2
	pUSARTcbtx->ptx_ctary_now_d += 1;		// Array of char cts
 8001de2:	69c2      	ldr	r2, [r0, #28]
 * @brief	: Advance line buffer pointers for isr
******************************************************************************/
void usartx_txisr_advlnptr (struct USARTCBT* pUSARTcbtx)
{
	/* Advance to next line buffer and companion array of char cts */
	pUSARTcbtx->ptx_begin_d     += pUSARTcbtx->tx_ln_sz;	// Line buffer
 8001de4:	60c3      	str	r3, [r0, #12]
	pUSARTcbtx->ptx_ctary_now_d += 1;		// Array of char cts
 8001de6:	3202      	adds	r2, #2
 8001de8:	61c2      	str	r2, [r0, #28]

	/* Check if at the end of all the line buffers */
	if (pUSARTcbtx->ptx_begin_d >= pUSARTcbtx->ptx_end)
 8001dea:	6942      	ldr	r2, [r0, #20]
 8001dec:	4293      	cmp	r3, r2
	{ // Here, end of line buffers, reset pointers to beginning
		pUSARTcbtx->ptx_begin_d     = pUSARTcbtx->ptx_begin;	// Line buffer
 8001dee:	bf21      	itttt	cs
 8001df0:	6903      	ldrcs	r3, [r0, #16]
 8001df2:	60c3      	strcs	r3, [r0, #12]
		pUSARTcbtx->ptx_ctary_now_d = pUSARTcbtx->ptx_ctary_begin;// Array of char cts
 8001df4:	6a03      	ldrcs	r3, [r0, #32]
 8001df6:	61c3      	strcs	r3, [r0, #28]
	}
	pUSARTcbtx->ptx_now_d = pUSARTcbtx->ptx_begin_d;		// Set new working-within-line pointer
 8001df8:	68c3      	ldr	r3, [r0, #12]
 8001dfa:	6083      	str	r3, [r0, #8]
 8001dfc:	4770      	bx	lr
	...

08001e00 <USART1_rxdma_init>:
control block and the buffers are allocated in the heap area via
mymalloc which is a one-time only allocation, i.e. no 'free' etc. */
struct USARTCBR* pUSARTcbr1;

u16 USART1_rxdma_init (u32 BaudRate,u16 RcvCircularSize, u16 GetLineSize)
{
 8001e00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001e02:	460e      	mov	r6, r1
	u16 temp;
	if ( (temp = usartx_rxdma_allocatebuffers(RcvCircularSize, GetLineSize, &pUSARTcbr1)) != 0) return temp;
 8001e04:	4d12      	ldr	r5, [pc, #72]	; (8001e50 <USART1_rxdma_init+0x50>)
control block and the buffers are allocated in the heap area via
mymalloc which is a one-time only allocation, i.e. no 'free' etc. */
struct USARTCBR* pUSARTcbr1;

u16 USART1_rxdma_init (u32 BaudRate,u16 RcvCircularSize, u16 GetLineSize)
{
 8001e06:	4611      	mov	r1, r2
 8001e08:	4607      	mov	r7, r0
	u16 temp;
	if ( (temp = usartx_rxdma_allocatebuffers(RcvCircularSize, GetLineSize, &pUSARTcbr1)) != 0) return temp;
 8001e0a:	462a      	mov	r2, r5
 8001e0c:	4630      	mov	r0, r6
 8001e0e:	f000 f930 	bl	8002072 <usartx_rxdma_allocatebuffers>
 8001e12:	4604      	mov	r4, r0
 8001e14:	b9d0      	cbnz	r0, 8001e4c <USART1_rxdma_init+0x4c>
		
	/* ---------------------- DMA and USART hardware setup --------------------- */	
	
	/* Enable clock for USART1. */
	RCC_APB2ENR |= RCC_APB2ENR_USART1EN;
 8001e16:	4a0f      	ldr	r2, [pc, #60]	; (8001e54 <USART1_rxdma_init+0x54>)

	/* DMA1 is used with all three buffered USART routines */
	RCC_AHBENR |= RCC_AHBENR_DMA1EN;

	/* Setup USART baudrate, rx non-interrupting, and connected to DMA */
	usartx_rxdma_usart_init (USART1, BaudRate);
 8001e18:	4639      	mov	r1, r7
	if ( (temp = usartx_rxdma_allocatebuffers(RcvCircularSize, GetLineSize, &pUSARTcbr1)) != 0) return temp;
		
	/* ---------------------- DMA and USART hardware setup --------------------- */	
	
	/* Enable clock for USART1. */
	RCC_APB2ENR |= RCC_APB2ENR_USART1EN;
 8001e1a:	6813      	ldr	r3, [r2, #0]

	/* DMA1 is used with all three buffered USART routines */
	RCC_AHBENR |= RCC_AHBENR_DMA1EN;

	/* Setup USART baudrate, rx non-interrupting, and connected to DMA */
	usartx_rxdma_usart_init (USART1, BaudRate);
 8001e1c:	480e      	ldr	r0, [pc, #56]	; (8001e58 <USART1_rxdma_init+0x58>)
	if ( (temp = usartx_rxdma_allocatebuffers(RcvCircularSize, GetLineSize, &pUSARTcbr1)) != 0) return temp;
		
	/* ---------------------- DMA and USART hardware setup --------------------- */	
	
	/* Enable clock for USART1. */
	RCC_APB2ENR |= RCC_APB2ENR_USART1EN;
 8001e1e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001e22:	6013      	str	r3, [r2, #0]

	/* DMA1 is used with all three buffered USART routines */
	RCC_AHBENR |= RCC_AHBENR_DMA1EN;
 8001e24:	f852 3c04 	ldr.w	r3, [r2, #-4]
 8001e28:	f043 0301 	orr.w	r3, r3, #1
 8001e2c:	f842 3c04 	str.w	r3, [r2, #-4]

	/* Setup USART baudrate, rx non-interrupting, and connected to DMA */
	usartx_rxdma_usart_init (USART1, BaudRate);
 8001e30:	f000 f947 	bl	80020c2 <usartx_rxdma_usart_init>

	/* Setup DMA for usart receive, circular buffering, no interrupts */
	DMA1_CNDTR5 = RcvCircularSize;			// Number of incoming chars before wrap-around
 8001e34:	4b09      	ldr	r3, [pc, #36]	; (8001e5c <USART1_rxdma_init+0x5c>)
 8001e36:	601e      	str	r6, [r3, #0]
	DMA1_CMAR5 = (u32)pUSARTcbr1->prx_begin;	// DMA chan 5 memory rx circular buffer start address
 8001e38:	682b      	ldr	r3, [r5, #0]
 8001e3a:	68da      	ldr	r2, [r3, #12]
 8001e3c:	4b08      	ldr	r3, [pc, #32]	; (8001e60 <USART1_rxdma_init+0x60>)
 8001e3e:	601a      	str	r2, [r3, #0]
	DMA1_CPAR5 = (u32)&USART1_DR;			// DMA chan 5 periperal usart rx address
 8001e40:	4a08      	ldr	r2, [pc, #32]	; (8001e64 <USART1_rxdma_init+0x64>)
 8001e42:	f843 2c04 	str.w	r2, [r3, #-4]
	DMA_CCR5(DMA1) = DMA_CCR5_MINC | DMA_CCR5_CIRC | DMA_CCR5_EN;   // Chan 5 Rx Mem increment, Circular, Enable
 8001e46:	22a1      	movs	r2, #161	; 0xa1
 8001e48:	f843 2c0c 	str.w	r2, [r3, #-12]

	return 0;	// Return 0 = success!
}
 8001e4c:	4620      	mov	r0, r4
 8001e4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001e50:	200010f8 	.word	0x200010f8
 8001e54:	40021018 	.word	0x40021018
 8001e58:	40013800 	.word	0x40013800
 8001e5c:	4002005c 	.word	0x4002005c
 8001e60:	40020064 	.word	0x40020064
 8001e64:	40013804 	.word	0x40013804

08001e68 <usartx_rxint_allocatebuffers>:
 * @param	: numberrcvlines is the number of receive line buffers (e.g. 4)
 * @param	: pUSARTcbrx points to pointer in static memory that points to control block
 * @return	: 0 = success; 1 = fail malloc; 2 = rcvlinesize zero; 3 = numberrcvlines = 0; 
******************************************************************************/
u16 usartx_rxint_allocatebuffers (u16 rcvlinesize, u16 numberrcvlines, struct USARTCBR** pUSARTcbrx)
{
 8001e68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001e6a:	460d      	mov	r5, r1
 8001e6c:	4616      	mov	r6, r2
	u32* ptr;
	struct USARTCBR* pUSARTcbrl; // Local pointer to control block setup on heap

	/* Bomb out just in case buffer size would be zero */
	if (rcvlinesize    == 0) return 2;
 8001e6e:	4607      	mov	r7, r0
 8001e70:	b320      	cbz	r0, 8001ebc <usartx_rxint_allocatebuffers+0x54>
	if (numberrcvlines == 0) return 3;
 8001e72:	b329      	cbz	r1, 8001ec0 <usartx_rxint_allocatebuffers+0x58>

	/* Allocate space and set pointer for the struct USARTcbrx */
	ptr = (u32*)mymalloc(sizeof (struct USARTCBR));
 8001e74:	2024      	movs	r0, #36	; 0x24
 8001e76:	f000 f8bb 	bl	8001ff0 <mymalloc>
	if  ( ptr  == 0)  return 1;
 8001e7a:	4604      	mov	r4, r0
 8001e7c:	b908      	cbnz	r0, 8001e82 <usartx_rxint_allocatebuffers+0x1a>
 8001e7e:	2001      	movs	r0, #1
 8001e80:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	*pUSARTcbrx = (struct USARTCBR*)ptr;	// Initialize static variable used by others
 8001e82:	6030      	str	r0, [r6, #0]
	 pUSARTcbrl = (struct USARTCBR*)ptr;	// Local pointer

	/* ---------------------------- receive buffers and pointers ------------------------------- */
	/* Allocate space and set pointer in USARTcbrx for receive line buffer(s) */
	if ( (pUSARTcbrl->prx_begin = (char*)mymalloc(rcvlinesize * numberrcvlines)) == 0 ) return 1;
 8001e84:	fb05 f607 	mul.w	r6, r5, r7
 8001e88:	b2b0      	uxth	r0, r6
 8001e8a:	f000 f8b1 	bl	8001ff0 <mymalloc>
 8001e8e:	60e0      	str	r0, [r4, #12]
 8001e90:	2800      	cmp	r0, #0
 8001e92:	d0f4      	beq.n	8001e7e <usartx_rxint_allocatebuffers+0x16>

	/* These rx pointers to start out on the same line buffer */	
	pUSARTcbrl->prx_begin_m = pUSARTcbrl->prx_begin;	// Beginning of line (main)
 8001e94:	6060      	str	r0, [r4, #4]
	pUSARTcbrl->prx_begin_i = pUSARTcbrl->prx_begin;	// Beginning of line being filled (interrupt)
 8001e96:	60a0      	str	r0, [r4, #8]
	pUSARTcbrl->prx_now_i   = pUSARTcbrl->prx_begin;	// Pointer within line being filled (interrupt)
 8001e98:	6020      	str	r0, [r4, #0]

	/* Use this for testing for end of line buffers wraparound */
	pUSARTcbrl->prx_end     = pUSARTcbrl->prx_begin + (rcvlinesize * numberrcvlines); 
 8001e9a:	4430      	add	r0, r6
 8001e9c:	6120      	str	r0, [r4, #16]

	/* Save number of rx line buffers */
	pUSARTcbrl->rx_ln_ct = numberrcvlines;

	/* Allocate space and set pointer in USARTcbrx for char count array */
	if ( (pUSARTcbrl->prx_ctary_begin = mymalloc(sizeof(u16) * numberrcvlines)) == 0 ) return 1;
 8001e9e:	0068      	lsls	r0, r5, #1

	/* Use this for testing for end of line buffers wraparound */
	pUSARTcbrl->prx_end     = pUSARTcbrl->prx_begin + (rcvlinesize * numberrcvlines); 

	/* Save rx line buffer size */
	pUSARTcbrl->rx_ln_sz = rcvlinesize;
 8001ea0:	8427      	strh	r7, [r4, #32]

	/* Save number of rx line buffers */
	pUSARTcbrl->rx_ln_ct = numberrcvlines;
 8001ea2:	8465      	strh	r5, [r4, #34]	; 0x22

	/* Allocate space and set pointer in USARTcbrx for char count array */
	if ( (pUSARTcbrl->prx_ctary_begin = mymalloc(sizeof(u16) * numberrcvlines)) == 0 ) return 1;
 8001ea4:	b280      	uxth	r0, r0
 8001ea6:	f000 f8a3 	bl	8001ff0 <mymalloc>
 8001eaa:	61e0      	str	r0, [r4, #28]
 8001eac:	2800      	cmp	r0, #0
 8001eae:	d0e6      	beq.n	8001e7e <usartx_rxint_allocatebuffers+0x16>
	 pUSARTcbrl->prx_ctary_now_m = pUSARTcbrl->prx_ctary_begin; 	// main pointer
	 pUSARTcbrl->prx_ctary_now_i = pUSARTcbrl->prx_ctary_begin; 	// isr pointer
	*pUSARTcbrl->prx_ctary_now_m = 0; 				// Show no chars in initial line buffer
 8001eb0:	2300      	movs	r3, #0
	/* Save number of rx line buffers */
	pUSARTcbrl->rx_ln_ct = numberrcvlines;

	/* Allocate space and set pointer in USARTcbrx for char count array */
	if ( (pUSARTcbrl->prx_ctary_begin = mymalloc(sizeof(u16) * numberrcvlines)) == 0 ) return 1;
	 pUSARTcbrl->prx_ctary_now_m = pUSARTcbrl->prx_ctary_begin; 	// main pointer
 8001eb2:	6160      	str	r0, [r4, #20]
	 pUSARTcbrl->prx_ctary_now_i = pUSARTcbrl->prx_ctary_begin; 	// isr pointer
 8001eb4:	61a0      	str	r0, [r4, #24]
	*pUSARTcbrl->prx_ctary_now_m = 0; 				// Show no chars in initial line buffer
 8001eb6:	8003      	strh	r3, [r0, #0]
	return 0;
 8001eb8:	4618      	mov	r0, r3
 8001eba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
{
	u32* ptr;
	struct USARTCBR* pUSARTcbrl; // Local pointer to control block setup on heap

	/* Bomb out just in case buffer size would be zero */
	if (rcvlinesize    == 0) return 2;
 8001ebc:	2002      	movs	r0, #2
 8001ebe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (numberrcvlines == 0) return 3;
 8001ec0:	2003      	movs	r0, #3
	if ( (pUSARTcbrl->prx_ctary_begin = mymalloc(sizeof(u16) * numberrcvlines)) == 0 ) return 1;
	 pUSARTcbrl->prx_ctary_now_m = pUSARTcbrl->prx_ctary_begin; 	// main pointer
	 pUSARTcbrl->prx_ctary_now_i = pUSARTcbrl->prx_ctary_begin; 	// isr pointer
	*pUSARTcbrl->prx_ctary_now_m = 0; 				// Show no chars in initial line buffer
	return 0;
}
 8001ec2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08001ec4 <usartx_rxint_usart_init>:
 * @brief	: Setup USART baudrate, Rx interrupting with line buffers
 * @param	: USARTx = USART1, USART2, or USART3 base address
 * @param	: u32 BaudRate is the baud rate.
******************************************************************************/
void usartx_rxint_usart_init (u32 USARTx, u32 BaudRate)
{
 8001ec4:	b510      	push	{r4, lr}
 8001ec6:	4604      	mov	r4, r0
	/* Set baud rate */
	usartx_setbaud (USARTx,BaudRate);	// Compute divider settings and load BRR
 8001ec8:	f000 f8a4 	bl	8002014 <usartx_setbaud>

 	/* Setup CR2 ------------------------------------------------------------------- */
	/* After reset CR2 is 0x0000 and this is just fine */
	/* Set up CR1 (page 771) ------------------------------------------------------- */
	USART_CR1(USARTx) |= USART_UE | USART_RXNE_INTERRUPT_ENABLE | USART_RX_ENABLE;// Set UE, RNEIE, RE 
 8001ecc:	68e3      	ldr	r3, [r4, #12]
 8001ece:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8001ed2:	f043 0324 	orr.w	r3, r3, #36	; 0x24
 8001ed6:	60e3      	str	r3, [r4, #12]
 8001ed8:	bd10      	pop	{r4, pc}

08001eda <usartx_rxint_rxmainadvptr>:
char* usartx_rxint_rxmainadvptr (struct USARTCBR* pUSARTcbrx)
{
	char* p;	// Temp 

	/* If no chars, then we are caught up with incoming lines */
	if (*pUSARTcbrx->prx_ctary_now_m == 0) return 0;
 8001eda:	6941      	ldr	r1, [r0, #20]
 * @brief	: Advance pointers for mainline
 * @param	: Receive control block
 * @return	: 0 = caught up, not zero = pointer to completed line buffer
******************************************************************************/
char* usartx_rxint_rxmainadvptr (struct USARTCBR* pUSARTcbrx)
{
 8001edc:	4602      	mov	r2, r0
	char* p;	// Temp 

	/* If no chars, then we are caught up with incoming lines */
	if (*pUSARTcbrx->prx_ctary_now_m == 0) return 0;
 8001ede:	880b      	ldrh	r3, [r1, #0]
 8001ee0:	b16b      	cbz	r3, 8001efe <usartx_rxint_rxmainadvptr+0x24>
	
	p = pUSARTcbrx->prx_begin_m;		// Save pointer for later return
 8001ee2:	6840      	ldr	r0, [r0, #4]

	/* Advance to next line buffer and companion array of char cts */
	pUSARTcbrx->prx_begin_m     += pUSARTcbrx->rx_ln_sz;	// Line buffer
	pUSARTcbrx->prx_ctary_now_m += 1;	// Array of char cts
 8001ee4:	3102      	adds	r1, #2
	if (*pUSARTcbrx->prx_ctary_now_m == 0) return 0;
	
	p = pUSARTcbrx->prx_begin_m;		// Save pointer for later return

	/* Advance to next line buffer and companion array of char cts */
	pUSARTcbrx->prx_begin_m     += pUSARTcbrx->rx_ln_sz;	// Line buffer
 8001ee6:	8c13      	ldrh	r3, [r2, #32]
	pUSARTcbrx->prx_ctary_now_m += 1;	// Array of char cts
 8001ee8:	6151      	str	r1, [r2, #20]

	/* Check if at the end of all the line buffers */
	if (pUSARTcbrx->prx_begin_m >= pUSARTcbrx->prx_end)
 8001eea:	6911      	ldr	r1, [r2, #16]
	if (*pUSARTcbrx->prx_ctary_now_m == 0) return 0;
	
	p = pUSARTcbrx->prx_begin_m;		// Save pointer for later return

	/* Advance to next line buffer and companion array of char cts */
	pUSARTcbrx->prx_begin_m     += pUSARTcbrx->rx_ln_sz;	// Line buffer
 8001eec:	4403      	add	r3, r0
	pUSARTcbrx->prx_ctary_now_m += 1;	// Array of char cts

	/* Check if at the end of all the line buffers */
	if (pUSARTcbrx->prx_begin_m >= pUSARTcbrx->prx_end)
 8001eee:	428b      	cmp	r3, r1
	if (*pUSARTcbrx->prx_ctary_now_m == 0) return 0;
	
	p = pUSARTcbrx->prx_begin_m;		// Save pointer for later return

	/* Advance to next line buffer and companion array of char cts */
	pUSARTcbrx->prx_begin_m     += pUSARTcbrx->rx_ln_sz;	// Line buffer
 8001ef0:	6053      	str	r3, [r2, #4]
	pUSARTcbrx->prx_ctary_now_m += 1;	// Array of char cts

	/* Check if at the end of all the line buffers */
	if (pUSARTcbrx->prx_begin_m >= pUSARTcbrx->prx_end)
 8001ef2:	d305      	bcc.n	8001f00 <usartx_rxint_rxmainadvptr+0x26>
	{ // Here, end of line buffers, reset pointers to beginning
		pUSARTcbrx->prx_begin_m     = pUSARTcbrx->prx_begin;	// Line buffer
 8001ef4:	68d3      	ldr	r3, [r2, #12]
 8001ef6:	6053      	str	r3, [r2, #4]
		pUSARTcbrx->prx_ctary_now_m = pUSARTcbrx->prx_ctary_begin;// Array of char cts
 8001ef8:	69d3      	ldr	r3, [r2, #28]
 8001efa:	6153      	str	r3, [r2, #20]
 8001efc:	4770      	bx	lr
char* usartx_rxint_rxmainadvptr (struct USARTCBR* pUSARTcbrx)
{
	char* p;	// Temp 

	/* If no chars, then we are caught up with incoming lines */
	if (*pUSARTcbrx->prx_ctary_now_m == 0) return 0;
 8001efe:	4618      	mov	r0, r3
	{ // Here, end of line buffers, reset pointers to beginning
		pUSARTcbrx->prx_begin_m     = pUSARTcbrx->prx_begin;	// Line buffer
		pUSARTcbrx->prx_ctary_now_m = pUSARTcbrx->prx_ctary_begin;// Array of char cts
	}
	return p;
}
 8001f00:	4770      	bx	lr

08001f02 <usartx_rxint_rxisrptradv2>:
 * void usartx_rxint_rxisrptradv2 (struct USARTCBR* pUSARTcbrx);
 * @brief	: Step pointers to next line buffer for rx isr routine
******************************************************************************/
void usartx_rxint_rxisrptradv2 (struct USARTCBR* pUSARTcbrx)
{
	pUSARTcbrx->prx_ctary_now_i += 1;			// Step to next char ct arrary position
 8001f02:	6983      	ldr	r3, [r0, #24]
	pUSARTcbrx->prx_begin_i     += pUSARTcbrx->rx_ln_sz;	// Step to next line buffer beginning
 8001f04:	6882      	ldr	r2, [r0, #8]
 * void usartx_rxint_rxisrptradv2 (struct USARTCBR* pUSARTcbrx);
 * @brief	: Step pointers to next line buffer for rx isr routine
******************************************************************************/
void usartx_rxint_rxisrptradv2 (struct USARTCBR* pUSARTcbrx)
{
	pUSARTcbrx->prx_ctary_now_i += 1;			// Step to next char ct arrary position
 8001f06:	3302      	adds	r3, #2
 8001f08:	6183      	str	r3, [r0, #24]
	pUSARTcbrx->prx_begin_i     += pUSARTcbrx->rx_ln_sz;	// Step to next line buffer beginning
 8001f0a:	8c03      	ldrh	r3, [r0, #32]
 8001f0c:	4413      	add	r3, r2
	if (pUSARTcbrx->prx_begin_i >= pUSARTcbrx->prx_end)	// Are we at end of the line buffers?
 8001f0e:	6902      	ldr	r2, [r0, #16]
 * @brief	: Step pointers to next line buffer for rx isr routine
******************************************************************************/
void usartx_rxint_rxisrptradv2 (struct USARTCBR* pUSARTcbrx)
{
	pUSARTcbrx->prx_ctary_now_i += 1;			// Step to next char ct arrary position
	pUSARTcbrx->prx_begin_i     += pUSARTcbrx->rx_ln_sz;	// Step to next line buffer beginning
 8001f10:	6083      	str	r3, [r0, #8]
	if (pUSARTcbrx->prx_begin_i >= pUSARTcbrx->prx_end)	// Are we at end of the line buffers?
 8001f12:	4293      	cmp	r3, r2
	{ // Here, yes.  Reset pointers to beginning
		pUSARTcbrx->prx_ctary_now_i  = pUSARTcbrx->prx_ctary_begin;
 8001f14:	bf21      	itttt	cs
 8001f16:	69c3      	ldrcs	r3, [r0, #28]
 8001f18:	6183      	strcs	r3, [r0, #24]
		pUSARTcbrx->prx_begin_i      = pUSARTcbrx->prx_begin;			
 8001f1a:	68c3      	ldrcs	r3, [r0, #12]
 8001f1c:	6083      	strcs	r3, [r0, #8]
	}
	pUSARTcbrx->prx_now_i = pUSARTcbrx->prx_begin_i;	// Set working pointer.
 8001f1e:	6883      	ldr	r3, [r0, #8]
 8001f20:	6003      	str	r3, [r0, #0]
 8001f22:	4770      	bx	lr

08001f24 <usartx_rxint_rxisrptradv>:
/******************************************************************************
 * void usartx_rxint_rxisrptradv (struct USARTCBR* pUSARTcbrx);
 * @brief	: Check for EOL, advance pointers for rx isr routine
******************************************************************************/
void usartx_rxint_rxisrptradv (struct USARTCBR* pUSARTcbrx)
{	
 8001f24:	b430      	push	{r4, r5}
	/* Was the char just stored an END_OF_LINE? */
	if ( *pUSARTcbrx->prx_now_i++ == END_OF_LINE)	// Check for end of line, step to next location
 8001f26:	6804      	ldr	r4, [r0, #0]
/******************************************************************************
 * void usartx_rxint_rxisrptradv (struct USARTCBR* pUSARTcbrx);
 * @brief	: Check for EOL, advance pointers for rx isr routine
******************************************************************************/
void usartx_rxint_rxisrptradv (struct USARTCBR* pUSARTcbrx)
{	
 8001f28:	4603      	mov	r3, r0
	/* Was the char just stored an END_OF_LINE? */
	if ( *pUSARTcbrx->prx_now_i++ == END_OF_LINE)	// Check for end of line, step to next location
 8001f2a:	1c62      	adds	r2, r4, #1
 8001f2c:	6002      	str	r2, [r0, #0]
 8001f2e:	7821      	ldrb	r1, [r4, #0]
 8001f30:	290d      	cmp	r1, #13
 8001f32:	6881      	ldr	r1, [r0, #8]
 8001f34:	d10a      	bne.n	8001f4c <usartx_rxint_rxisrptradv+0x28>
	{ // Here, EOL, so move to next line buffer.
		/* Store number of chars in line just completed */
		*pUSARTcbrx->prx_ctary_now_i = (pUSARTcbrx->prx_now_i - pUSARTcbrx->prx_begin_i);
 8001f36:	6980      	ldr	r0, [r0, #24]
 8001f38:	1a55      	subs	r5, r2, r1
 8001f3a:	8005      	strh	r5, [r0, #0]
		/* Check if space to store zero string terminator */
		if (pUSARTcbrx->prx_now_i < (pUSARTcbrx->prx_begin_i + pUSARTcbrx->rx_ln_sz) )
 8001f3c:	8c18      	ldrh	r0, [r3, #32]
 8001f3e:	4401      	add	r1, r0
 8001f40:	428a      	cmp	r2, r1
		{ // Here, there is room for the zero
			*pUSARTcbrx->prx_now_i = 0; 	// Add zero for the string terminator			
 8001f42:	bf3c      	itt	cc
 8001f44:	2200      	movcc	r2, #0
 8001f46:	7062      	strbcc	r2, [r4, #1]
		}
		/* Step to next line buffer */
		usartx_rxint_rxisrptradv2 (pUSARTcbrx);
 8001f48:	4618      	mov	r0, r3
 8001f4a:	e006      	b.n	8001f5a <usartx_rxint_rxisrptradv+0x36>
	}
	else
	{ // Here, not EOL, so check if we are at end of the current line buffer.
		if (pUSARTcbrx->prx_now_i >= (pUSARTcbrx->prx_begin_i + pUSARTcbrx->rx_ln_sz) )
 8001f4c:	8c04      	ldrh	r4, [r0, #32]
 8001f4e:	440c      	add	r4, r1
 8001f50:	42a2      	cmp	r2, r4
 8001f52:	d305      	bcc.n	8001f60 <usartx_rxint_rxisrptradv+0x3c>
		{ // Here, we at end, so step to next line buffer
			/* Store number of chars in line just completed */
			*pUSARTcbrx->prx_ctary_now_i = (pUSARTcbrx->prx_now_i - pUSARTcbrx->prx_begin_i);
 8001f54:	6983      	ldr	r3, [r0, #24]
 8001f56:	1a52      	subs	r2, r2, r1
 8001f58:	801a      	strh	r2, [r3, #0]
			usartx_rxint_rxisrptradv2 (pUSARTcbrx);
		}
	}
	return;
}
 8001f5a:	bc30      	pop	{r4, r5}
	{ // Here, not EOL, so check if we are at end of the current line buffer.
		if (pUSARTcbrx->prx_now_i >= (pUSARTcbrx->prx_begin_i + pUSARTcbrx->rx_ln_sz) )
		{ // Here, we at end, so step to next line buffer
			/* Store number of chars in line just completed */
			*pUSARTcbrx->prx_ctary_now_i = (pUSARTcbrx->prx_now_i - pUSARTcbrx->prx_begin_i);
			usartx_rxint_rxisrptradv2 (pUSARTcbrx);
 8001f5c:	f7ff bfd1 	b.w	8001f02 <usartx_rxint_rxisrptradv2>
		}
	}
	return;
}
 8001f60:	bc30      	pop	{r4, r5}
 8001f62:	4770      	bx	lr

08001f64 <usartx_txint_send>:
* @brief	: Step to next line tx line buffer; if USART not sending, start it now.
* @param	: pUSARTcbtx	Pointer to struct--pUSARTcbid1,2,3
** @return	: 0 = OK; 1 = NG
*******************************************************************************/
char usartx_txint_send(struct USARTCBT* pUSARTcbtx)
{
 8001f64:	b508      	push	{r3, lr}

	/* Compute number of chars to send */ 
 	u16 temp = (pUSARTcbtx->ptx_now_m - pUSARTcbtx->ptx_begin_m);
 8001f66:	6841      	ldr	r1, [r0, #4]
 8001f68:	6803      	ldr	r3, [r0, #0]
 8001f6a:	1a5b      	subs	r3, r3, r1
 8001f6c:	b29b      	uxth	r3, r3

	/* A zero count would cause 65536 chars to sent, i.e. a full wrap around */
	/* So, zero would mean a bogus 'send' call was issued */
	if ( temp == 0 ) return 1; // Show no chars to send
 8001f6e:	b12b      	cbz	r3, 8001f7c <usartx_txint_send+0x18>
			
	/* Place count in array that holds the counts */
	*pUSARTcbtx->ptx_ctary_now_m = temp;	
 8001f70:	6982      	ldr	r2, [r0, #24]
 8001f72:	8013      	strh	r3, [r2, #0]

	/* Advance to next line buffer for 'main' pointer */
	usartx_txmain_advlnptr (pUSARTcbtx);
 8001f74:	f7ff ff21 	bl	8001dba <usartx_txmain_advlnptr>

	return 0; // Show chars were sent
 8001f78:	2000      	movs	r0, #0
 8001f7a:	bd08      	pop	{r3, pc}
	/* Compute number of chars to send */ 
 	u16 temp = (pUSARTcbtx->ptx_now_m - pUSARTcbtx->ptx_begin_m);

	/* A zero count would cause 65536 chars to sent, i.e. a full wrap around */
	/* So, zero would mean a bogus 'send' call was issued */
	if ( temp == 0 ) return 1; // Show no chars to send
 8001f7c:	2001      	movs	r0, #1

	/* Advance to next line buffer for 'main' pointer */
	usartx_txmain_advlnptr (pUSARTcbtx);

	return 0; // Show chars were sent
}
 8001f7e:	bd08      	pop	{r3, pc}

08001f80 <usartx_txint_allocatebuffers>:
 * @param	: numberxmtlines is the number of receive line buffers (e.g. 4)
 * @param	: pUSARTcbtx points to pointer in static memory that points to control block
 * @return	: 0 = success; 1 = fail malloc; 2 = rcvlinesize zero; 3 = numberrcvlines = 0; 
******************************************************************************/
u16 usartx_txint_allocatebuffers (u16 xmtlinesize,u16 numberxmtlines, struct USARTCBT** pUSARTcbtx)
{
 8001f80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001f82:	460d      	mov	r5, r1
 8001f84:	4616      	mov	r6, r2
	u32* ptr;
	struct USARTCBT* pUSARTcbtl; // Local pointer to control block setup on heap

	/* Bomb out just in case buffer size would be zero */
	if (xmtlinesize    == 0) return 2;
 8001f86:	4607      	mov	r7, r0
 8001f88:	b318      	cbz	r0, 8001fd2 <usartx_txint_allocatebuffers+0x52>
	if (numberxmtlines == 0) return 3;
 8001f8a:	b321      	cbz	r1, 8001fd6 <usartx_txint_allocatebuffers+0x56>

	/* Allocate space and set pointer for the struct USARTcbtx */
	ptr = (u32*)mymalloc(sizeof (struct USARTCBT));
 8001f8c:	2028      	movs	r0, #40	; 0x28
 8001f8e:	f000 f82f 	bl	8001ff0 <mymalloc>
	if  ( ptr  == 0)  return 1;
 8001f92:	4604      	mov	r4, r0
 8001f94:	b908      	cbnz	r0, 8001f9a <usartx_txint_allocatebuffers+0x1a>
 8001f96:	2001      	movs	r0, #1
 8001f98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	*pUSARTcbtx = (struct USARTCBT*)ptr;	// Initialize static variable used by others
 8001f9a:	6030      	str	r0, [r6, #0]
	 pUSARTcbtl = (struct USARTCBT*)ptr;	

	/* ---------------------------- transmit (dma) buffers and pointers -------------------------- */

	/* Allocate space and set pointer in USARTcbx for transmit line buffer(s) */
	if ( (pUSARTcbtl->ptx_begin = (char*)mymalloc(xmtlinesize * numberxmtlines)) == 0 ) return 1;
 8001f9c:	fb05 f607 	mul.w	r6, r5, r7
 8001fa0:	b2b0      	uxth	r0, r6
 8001fa2:	f000 f825 	bl	8001ff0 <mymalloc>
 8001fa6:	6120      	str	r0, [r4, #16]
 8001fa8:	2800      	cmp	r0, #0
 8001faa:	d0f4      	beq.n	8001f96 <usartx_txint_allocatebuffers+0x16>

	/* These tx pointers start out on the same line buffer */	
	pUSARTcbtl->ptx_begin_m = pUSARTcbtl->ptx_begin;	// Beginning of line being filled (main)
 8001fac:	6060      	str	r0, [r4, #4]
	pUSARTcbtl->ptx_begin_d = pUSARTcbtl->ptx_begin;	// Beginning of line being sent (int)
 8001fae:	60e0      	str	r0, [r4, #12]
	pUSARTcbtl->ptx_now_m   = pUSARTcbtl->ptx_begin;	// Pointer in line being filled (main)
 8001fb0:	6020      	str	r0, [r4, #0]
	pUSARTcbtl->ptx_now_d   = pUSARTcbtl->ptx_begin;	// Pointer in line being filled (int)
 8001fb2:	60a0      	str	r0, [r4, #8]

	/* Use this for testing for end of line buffers wraparound */
	pUSARTcbtl->ptx_end     = pUSARTcbtl->ptx_begin + (xmtlinesize * numberxmtlines); 
 8001fb4:	4430      	add	r0, r6
 8001fb6:	6160      	str	r0, [r4, #20]

	/* Save number of tx line buffers */
	pUSARTcbtl->tx_ln_ct = numberxmtlines;

	/* Setup an array with the line buffer transfer count for each tx line buffer */
	if ( (pUSARTcbtl->ptx_ctary_begin = mymalloc(sizeof(u16) * numberxmtlines)) == 0 ) return 1;
 8001fb8:	0068      	lsls	r0, r5, #1

	/* Use this for testing for end of line buffers wraparound */
	pUSARTcbtl->ptx_end     = pUSARTcbtl->ptx_begin + (xmtlinesize * numberxmtlines); 

	/* Save tx line buffer size */
	pUSARTcbtl->tx_ln_sz = xmtlinesize;
 8001fba:	84a7      	strh	r7, [r4, #36]	; 0x24

	/* Save number of tx line buffers */
	pUSARTcbtl->tx_ln_ct = numberxmtlines;
 8001fbc:	84e5      	strh	r5, [r4, #38]	; 0x26

	/* Setup an array with the line buffer transfer count for each tx line buffer */
	if ( (pUSARTcbtl->ptx_ctary_begin = mymalloc(sizeof(u16) * numberxmtlines)) == 0 ) return 1;
 8001fbe:	b280      	uxth	r0, r0
 8001fc0:	f000 f816 	bl	8001ff0 <mymalloc>
 8001fc4:	6220      	str	r0, [r4, #32]
 8001fc6:	2800      	cmp	r0, #0
 8001fc8:	d0e5      	beq.n	8001f96 <usartx_txint_allocatebuffers+0x16>
	pUSARTcbtl->ptx_ctary_now_m = pUSARTcbtl->ptx_ctary_begin;	// Set working pointer, (main)
 8001fca:	61a0      	str	r0, [r4, #24]
	pUSARTcbtl->ptx_ctary_now_d = pUSARTcbtl->ptx_ctary_begin;	// Set working pointer, (int)
 8001fcc:	61e0      	str	r0, [r4, #28]

	return 0;
 8001fce:	2000      	movs	r0, #0
 8001fd0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
{
	u32* ptr;
	struct USARTCBT* pUSARTcbtl; // Local pointer to control block setup on heap

	/* Bomb out just in case buffer size would be zero */
	if (xmtlinesize    == 0) return 2;
 8001fd2:	2002      	movs	r0, #2
 8001fd4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (numberxmtlines == 0) return 3;
 8001fd6:	2003      	movs	r0, #3
	if ( (pUSARTcbtl->ptx_ctary_begin = mymalloc(sizeof(u16) * numberxmtlines)) == 0 ) return 1;
	pUSARTcbtl->ptx_ctary_now_m = pUSARTcbtl->ptx_ctary_begin;	// Set working pointer, (main)
	pUSARTcbtl->ptx_ctary_now_d = pUSARTcbtl->ptx_ctary_begin;	// Set working pointer, (int)

	return 0;
}
 8001fd8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08001fda <usartx_txint_usart_init>:
/******************************************************************************
 * void usartx_txint_usart_init (u32 USARTx, u32 BaudRate);
 * @brief	: Setup USART baudrate, Tx for dma
******************************************************************************/
void usartx_txint_usart_init (u32 USARTx, u32 BaudRate)
{
 8001fda:	b510      	push	{r4, lr}
 8001fdc:	4604      	mov	r4, r0
	/* Set baud rate */
	usartx_setbaud (USARTx,BaudRate);	// Compute divider settings and load BRR
 8001fde:	f000 f819 	bl	8002014 <usartx_setbaud>

 	/* Setup CR2 ------------------------------------------------------------------- */
	/* After reset CR2 is 0x0000 and this is just fine */
	/* Set up CR1 (page 771) ------------------------------------------------------- */
	USART_CR1(USARTx) |= USART_UE | USART_TX_ENABLE;// Set UE, TE
 8001fe2:	68e3      	ldr	r3, [r4, #12]
 8001fe4:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8001fe8:	f043 0308 	orr.w	r3, r3, #8
 8001fec:	60e3      	str	r3, [r4, #12]
 8001fee:	bd10      	pop	{r4, pc}

08001ff0 <mymalloc>:

void* mymalloc(u16 size)
{
	unsigned char* prev_heap = myheap;

	prev_heap = myheap;
 8001ff0:	4a06      	ldr	r2, [pc, #24]	; (800200c <mymalloc+0x1c>)
	myheap += size;
	
	myheap += 3;
	myheap = (unsigned char*)((u32)myheap & ~0x03);	// Round upwards to align to full words
 8001ff2:	3003      	adds	r0, #3

void* mymalloc(u16 size)
{
	unsigned char* prev_heap = myheap;

	prev_heap = myheap;
 8001ff4:	6813      	ldr	r3, [r2, #0]
	myheap += size;
	
	myheap += 3;
	myheap = (unsigned char*)((u32)myheap & ~0x03);	// Round upwards to align to full words
 8001ff6:	4418      	add	r0, r3
 8001ff8:	f020 0003 	bic.w	r0, r0, #3
 8001ffc:	6010      	str	r0, [r2, #0]
// $	if (myheap >= &_MYHEAP_END)		// Are we out of space?
	if (myheap >= (&myheapblock[0] + MYHEAPBLOCKSIZE))	// Are we out of space?
		return 0;		// Here, yes.  Return zero (null)  

	return prev_heap;		// Return pointer to beginning of block
}
 8001ffe:	4a04      	ldr	r2, [pc, #16]	; (8002010 <mymalloc+0x20>)
 8002000:	4290      	cmp	r0, r2
 8002002:	bf34      	ite	cc
 8002004:	4618      	movcc	r0, r3
 8002006:	2000      	movcs	r0, #0
 8002008:	4770      	bx	lr
 800200a:	bf00      	nop
 800200c:	20000844 	.word	0x20000844
 8002010:	200018fc 	.word	0x200018fc

08002014 <usartx_setbaud>:
	u32 tmpreg = 0x00;
	u32 fractionaldivider = 0x00;
	u32 integerdivider = 0x00;

	/* USART1 is driven from a different clock, than USART2,3 */
	if ( usartx == USART1_BASE)	// Are doing USART1?
 8002014:	4b0e      	ldr	r3, [pc, #56]	; (8002050 <usartx_setbaud+0x3c>)
 * void usartx_setbaud (u32 usartx, u32 u32BaudRate);
 * @brief	: set baudrate register (BRR)
 * @param	: u32BaudRate is the baud rate.
******************************************************************************/
void usartx_setbaud (u32 usartx, u32 u32BaudRate)
{
 8002016:	b510      	push	{r4, lr}
	u32 tmpreg = 0x00;
	u32 fractionaldivider = 0x00;
	u32 integerdivider = 0x00;

	/* USART1 is driven from a different clock, than USART2,3 */
	if ( usartx == USART1_BASE)	// Are doing USART1?
 8002018:	4298      	cmp	r0, r3
	{  // Here, yes.
		apbclock = pclk2_freq;
 800201a:	bf0c      	ite	eq
 800201c:	4b0d      	ldreq	r3, [pc, #52]	; (8002054 <usartx_setbaud+0x40>)
	}
	else
	{ // Here, no.  It is presumed to be USART2, USART3, UART4, UART5
		apbclock = pclk1_freq;	
 800201e:	4b0e      	ldrne	r3, [pc, #56]	; (8002058 <usartx_setbaud+0x44>)
 8002020:	681a      	ldr	r2, [r3, #0]
	}

	/* Determine the integer part */
	integerdivider = ((0x19 * apbclock) / (0x04 * u32BaudRate));
 8002022:	2319      	movs	r3, #25
 8002024:	4353      	muls	r3, r2
 8002026:	008a      	lsls	r2, r1, #2
 8002028:	fbb3 f2f2 	udiv	r2, r3, r2
	tmpreg = (integerdivider / 0x64) << 0x04;
 800202c:	2364      	movs	r3, #100	; 0x64
 800202e:	fbb2 f1f3 	udiv	r1, r2, r3
 8002032:	0109      	lsls	r1, r1, #4

	/* Determine the fractional part */
	fractionaldivider = integerdivider - (0x64 * (tmpreg >> 0x04));
	tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) & ((u8)0x0F);
 8002034:	090c      	lsrs	r4, r1, #4
 8002036:	fb03 2214 	mls	r2, r3, r4, r2
 800203a:	0112      	lsls	r2, r2, #4
 800203c:	3232      	adds	r2, #50	; 0x32
 800203e:	fbb2 f3f3 	udiv	r3, r2, r3
 8002042:	f003 030f 	and.w	r3, r3, #15
 8002046:	430b      	orrs	r3, r1
 8002048:	b29b      	uxth	r3, r3

	/* Set USART BRR --------------------------------------------------------------- */
	  USART_BRR(usartx) = (u16)tmpreg;
 800204a:	6083      	str	r3, [r0, #8]
 800204c:	bd10      	pop	{r4, pc}
 800204e:	bf00      	nop
 8002050:	40013800 	.word	0x40013800
 8002054:	200010d8 	.word	0x200010d8
 8002058:	200010dc 	.word	0x200010dc

0800205c <usartx_txmin_init>:
 * @brief	: Initializes the USARTx to 8N1 and the baudrate 
 * @param	: u32 Baudrate		- baudrate 		(e.g. 115200)
 * @return	: none
******************************************************************************/
void usartx_txmin_init (u32 USARTx, u32 BaudRate)
{
 800205c:	b510      	push	{r4, lr}
 800205e:	4604      	mov	r4, r0
	/* Set baud rate */
	usartx_setbaud (USARTx,BaudRate);	// Compute divider settings and load BRR
 8002060:	f7ff ffd8 	bl	8002014 <usartx_setbaud>

	 	/* Setup CR2 ------------------------------------------------------------------- */
		/* After reset CR2 is 0x0000 and this is just fine */
		/* Set up CR1 (page 771) ------------------------------------------------------- */
		USART_CR1(USARTx) |= USART_UE | USART_TX_ENABLE;// Set UE, TE
 8002064:	68e3      	ldr	r3, [r4, #12]
 8002066:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800206a:	f043 0308 	orr.w	r3, r3, #8
 800206e:	60e3      	str	r3, [r4, #12]
 8002070:	bd10      	pop	{r4, pc}

08002072 <usartx_rxdma_allocatebuffers>:
 * @param	: numberrcvlines is the number of receive line buffers (e.g. 4)
 * @param	: pUSARTcbrx points to pointer in static memory that points to control block
 * @return	: 0 = success;1 = fail mymallocl; 2 = zero getlinesize zero; 3 = numbergetlinesize zero
******************************************************************************/
u16 usartx_rxdma_allocatebuffers (u16 rcvcircularsize, u16 getlinesize, struct USARTCBR** pUSARTcbrx)
{
 8002072:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002074:	4606      	mov	r6, r0
 8002076:	4617      	mov	r7, r2
	u32* ptr;
	struct USARTCBR* pUSARTcbrl; // Local pointer to control block setup on heap

	/* Zero buffer size would cause trouble */
	if (getlinesize     == 0 ) return 2;
 8002078:	460d      	mov	r5, r1
 800207a:	b1f1      	cbz	r1, 80020ba <usartx_rxdma_allocatebuffers+0x48>
	if (rcvcircularsize == 0 ) return 3;
 800207c:	b1f8      	cbz	r0, 80020be <usartx_rxdma_allocatebuffers+0x4c>

	/* Allocate space and set pointer for the struct USARTcbtx */
	ptr = (u32*)mymalloc(sizeof (struct USARTCBR));
 800207e:	2024      	movs	r0, #36	; 0x24
 8002080:	f7ff ffb6 	bl	8001ff0 <mymalloc>
	if  ( ptr  == 0)  return 1;
 8002084:	4604      	mov	r4, r0
 8002086:	b908      	cbnz	r0, 800208c <usartx_rxdma_allocatebuffers+0x1a>
 8002088:	2001      	movs	r0, #1
 800208a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	*pUSARTcbrx = (struct USARTCBR*)ptr;	// Initialize static variable used by others
 800208c:	6038      	str	r0, [r7, #0]
u16*	prx_ctary_begin;// Constant: --not used--
u16	rx_ln_sz;	// Constant: size of circular line buffer  
u16	rx_ln_ct;	// Constant: size of getline buffer
*/
	/* Allocate space and set pointer in USARTcbrx for receive circular buffer */
	if ( (pUSARTcbrl->prx_begin = (char*)mymalloc(rcvcircularsize)) == 0 ) return 1;
 800208e:	4630      	mov	r0, r6
 8002090:	f7ff ffae 	bl	8001ff0 <mymalloc>
 8002094:	60e0      	str	r0, [r4, #12]
 8002096:	2800      	cmp	r0, #0
 8002098:	d0f6      	beq.n	8002088 <usartx_rxdma_allocatebuffers+0x16>

	/* These tx pointers start out on the same line buffer */	
	pUSARTcbrl->prx_now_i = pUSARTcbrl->prx_begin;	// main's working pointer in circular rx buffer
 800209a:	6020      	str	r0, [r4, #0]

	/* Use this for testing for end of line buffers wraparound */
	pUSARTcbrl->prx_end     = pUSARTcbrl->prx_begin + rcvcircularsize;	// pointer to end 
 800209c:	4430      	add	r0, r6
 800209e:	6120      	str	r0, [r4, #16]

	/* Save rx circular buffer size */
	pUSARTcbrl->rx_ln_sz = rcvcircularsize;
 80020a0:	8426      	strh	r6, [r4, #32]

	/* Save rx line buffer size */
	pUSARTcbrl->rx_ln_ct = getlinesize;
 80020a2:	8465      	strh	r5, [r4, #34]	; 0x22

	/* Setup getline line buffer */
	if ( (pUSARTcbrl->prx_begin_i = (char*)(mymalloc(getlinesize))) == 0 ) return 1;
 80020a4:	4628      	mov	r0, r5
 80020a6:	f7ff ffa3 	bl	8001ff0 <mymalloc>
 80020aa:	60a0      	str	r0, [r4, #8]
 80020ac:	2800      	cmp	r0, #0
 80020ae:	d0eb      	beq.n	8002088 <usartx_rxdma_allocatebuffers+0x16>
	pUSARTcbrl->prx_begin_m = pUSARTcbrl->prx_begin_i;	// Set working pointer: main
	pUSARTcbrl->prx_ctary_now_i = (u16*)(pUSARTcbrl->prx_begin_i + getlinesize);	// Set constant: pointer end
 80020b0:	4405      	add	r5, r0
	/* Save rx line buffer size */
	pUSARTcbrl->rx_ln_ct = getlinesize;

	/* Setup getline line buffer */
	if ( (pUSARTcbrl->prx_begin_i = (char*)(mymalloc(getlinesize))) == 0 ) return 1;
	pUSARTcbrl->prx_begin_m = pUSARTcbrl->prx_begin_i;	// Set working pointer: main
 80020b2:	6060      	str	r0, [r4, #4]
	pUSARTcbrl->prx_ctary_now_i = (u16*)(pUSARTcbrl->prx_begin_i + getlinesize);	// Set constant: pointer end
 80020b4:	61a5      	str	r5, [r4, #24]

	return 0;
 80020b6:	2000      	movs	r0, #0
 80020b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
{
	u32* ptr;
	struct USARTCBR* pUSARTcbrl; // Local pointer to control block setup on heap

	/* Zero buffer size would cause trouble */
	if (getlinesize     == 0 ) return 2;
 80020ba:	2002      	movs	r0, #2
 80020bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (rcvcircularsize == 0 ) return 3;
 80020be:	2003      	movs	r0, #3
	if ( (pUSARTcbrl->prx_begin_i = (char*)(mymalloc(getlinesize))) == 0 ) return 1;
	pUSARTcbrl->prx_begin_m = pUSARTcbrl->prx_begin_i;	// Set working pointer: main
	pUSARTcbrl->prx_ctary_now_i = (u16*)(pUSARTcbrl->prx_begin_i + getlinesize);	// Set constant: pointer end

	return 0;
}
 80020c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080020c2 <usartx_rxdma_usart_init>:
 * void usartx_rxdma_usart_init (u32 USARTx, u32 BaudRate);
 * @brief	: Setup USART baudrate, rx for dma
 * @return	: none
******************************************************************************/
void usartx_rxdma_usart_init (u32 USARTx, u32 BaudRate)
{
 80020c2:	b510      	push	{r4, lr}
 80020c4:	4604      	mov	r4, r0
	/* Set baud rate */
	usartx_setbaud(USARTx,BaudRate);	// Compute divider settings and load BRR
 80020c6:	f7ff ffa5 	bl	8002014 <usartx_setbaud>

 	/* Setup CR2 ------------------------------------------------------------------- */
	/* After reset CR2 is 0x0000 and this is just fine */

	/* Set up CR1 (page 771) ------------------------------------------------------- */
	USART_CR1(USARTx) |= USART_UE | USART_RX_ENABLE;// Set Usart enable, receive enable
 80020ca:	68e3      	ldr	r3, [r4, #12]
 80020cc:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80020d0:	f043 0304 	orr.w	r3, r3, #4
 80020d4:	60e3      	str	r3, [r4, #12]
	
	/* Hook up usart rx to dma channel */
	USART_CR3(USARTx) |= USART_DMAR;			// CR3 setup
 80020d6:	6963      	ldr	r3, [r4, #20]
 80020d8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80020dc:	6163      	str	r3, [r4, #20]
 80020de:	bd10      	pop	{r4, pc}

080020e0 <rc_crc32>:
 * @param	: pData = pointer input bytes
 * @param	: len = byte count
 * @return	: crc
*******************************************************************************/
uint32_t rc_crc32(u8* buf, u32 len)
{
 80020e0:	b530      	push	{r4, r5, lr}
 	u32 crc = ~0;
	
	q = buf + len;
	for (p = buf; p < q; p++) {
		octet = *p;  /* Cast to unsigned octet. */
		crc = (crc >> 8) ^ crctable[(crc & 0xff) ^ octet];
 80020e2:	4c08      	ldr	r4, [pc, #32]	; (8002104 <rc_crc32+0x24>)
{
	u8 octet;
	u8 *p, *q;
 	u32 crc = ~0;
	
	q = buf + len;
 80020e4:	4401      	add	r1, r0
*******************************************************************************/
uint32_t rc_crc32(u8* buf, u32 len)
{
	u8 octet;
	u8 *p, *q;
 	u32 crc = ~0;
 80020e6:	f04f 33ff 	mov.w	r3, #4294967295
	
	q = buf + len;
	for (p = buf; p < q; p++) {
 80020ea:	4288      	cmp	r0, r1
 80020ec:	d208      	bcs.n	8002100 <rc_crc32+0x20>
		octet = *p;  /* Cast to unsigned octet. */
		crc = (crc >> 8) ^ crctable[(crc & 0xff) ^ octet];
 80020ee:	f810 2b01 	ldrb.w	r2, [r0], #1
 80020f2:	b2dd      	uxtb	r5, r3
 80020f4:	406a      	eors	r2, r5
 80020f6:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 80020fa:	ea82 2313 	eor.w	r3, r2, r3, lsr #8
 80020fe:	e7f4      	b.n	80020ea <rc_crc32+0xa>
	}
	return ~crc;
}
 8002100:	43d8      	mvns	r0, r3
 8002102:	bd30      	pop	{r4, r5, pc}
 8002104:	08003cb8 	.word	0x08003cb8

08002108 <can_nxp_setRS>:
 * @param	: rs: 0 = NORMAL mode; not-zero = SILENT mode 
 * @param	: board: 0 = POD, 1 = sensor RxT6 board
 * @return	: Nothing for now.
*******************************************************************************/
void can_nxp_setRS(int rs, int board)
{
 8002108:	b510      	push	{r4, lr}
 800210a:	4604      	mov	r4, r0
	/* RS (S) control PB7 (on sensor board) PD11 on pod board */
	// Floating input = resistor controls slope
	// Pin HI = standby;
	// Pin LO = high speed;
	if (board == 0)
 800210c:	b951      	cbnz	r1, 8002124 <can_nxp_setRS+0x1c>
	{
		configure_pin ((volatile u32 *)GPIOD, 11);	// configured for push-pull output
 800210e:	210b      	movs	r1, #11
 8002110:	480a      	ldr	r0, [pc, #40]	; (800213c <can_nxp_setRS+0x34>)
 8002112:	f000 f9d5 	bl	80024c0 <configure_pin>
 8002116:	f44f 6300 	mov.w	r3, #2048	; 0x800
		if (rs == 0)
 800211a:	b90c      	cbnz	r4, 8002120 <can_nxp_setRS+0x18>
			GPIO_BRR(GPIOD)  = (1<<11);	// Set bit LO for SILENT mode
 800211c:	4a08      	ldr	r2, [pc, #32]	; (8002140 <can_nxp_setRS+0x38>)
 800211e:	e008      	b.n	8002132 <can_nxp_setRS+0x2a>
		else
			GPIO_BSRR(GPIOD) = (1<<11);	// Set bit HI for NORMAL mode
 8002120:	4a08      	ldr	r2, [pc, #32]	; (8002144 <can_nxp_setRS+0x3c>)
 8002122:	e009      	b.n	8002138 <can_nxp_setRS+0x30>
	}
	else
	{
		configure_pin ((volatile u32 *)GPIOB,  7);	// configured for push-pull output	
 8002124:	2107      	movs	r1, #7
 8002126:	4808      	ldr	r0, [pc, #32]	; (8002148 <can_nxp_setRS+0x40>)
 8002128:	f000 f9ca 	bl	80024c0 <configure_pin>
 800212c:	2380      	movs	r3, #128	; 0x80
		if (rs == 0)
 800212e:	b914      	cbnz	r4, 8002136 <can_nxp_setRS+0x2e>
			GPIO_BRR(GPIOB)  = (1<< 7);	// Set bit LO for SILENT mode
 8002130:	4a06      	ldr	r2, [pc, #24]	; (800214c <can_nxp_setRS+0x44>)
 8002132:	8013      	strh	r3, [r2, #0]
 8002134:	bd10      	pop	{r4, pc}
		else
			GPIO_BSRR(GPIOB) = (1<< 7);	// Set bit HI for NORMAL mode
 8002136:	4a06      	ldr	r2, [pc, #24]	; (8002150 <can_nxp_setRS+0x48>)
 8002138:	6013      	str	r3, [r2, #0]
 800213a:	bd10      	pop	{r4, pc}
 800213c:	40011400 	.word	0x40011400
 8002140:	40011414 	.word	0x40011414
 8002144:	40011410 	.word	0x40011410
 8002148:	40010c00 	.word	0x40010c00
 800214c:	40010c14 	.word	0x40010c14
 8002150:	40010c10 	.word	0x40010c10

08002154 <canwinch_setup_F103_pod_clocks>:
 * @return	:  pointer to struct
*******************************************************************************/
struct CLOCKS* canwinch_setup_F103_pod_clocks(void)
{
	return (struct CLOCKS*)&clocks;
}
 8002154:	4800      	ldr	r0, [pc, #0]	; (8002158 <canwinch_setup_F103_pod_clocks+0x4>)
 8002156:	4770      	bx	lr
 8002158:	080040b8 	.word	0x080040b8

0800215c <canwinch_setup_F103_pod>:
 *		:  -5 port pin setup failed
 *		:  -6 CAN initialization mode timed out
 *		:  -7 Leave initialization mode timed out
*******************************************************************************/
struct CAN_CTLBLOCK* canwinch_setup_F103_pod(const struct CAN_INIT* pinit, u32 canid)
{
 800215c:	b570      	push	{r4, r5, r6, lr}
 800215e:	460e      	mov	r6, r1
	//                                parameters, TX buff, RX0 buff, RX1 buff
	struct CAN_CTLBLOCK* pctl;
	pctl = can_driver_init( (struct CAN_PARAMS2*)&params, pinit);
 8002160:	4601      	mov	r1, r0
 8002162:	4810      	ldr	r0, [pc, #64]	; (80021a4 <canwinch_setup_F103_pod+0x48>)
 8002164:	f000 fc04 	bl	8002970 <can_driver_init>

	/* Early CAN init failure returns NULL. */
	if (pctl == NULL) return NULL;
 8002168:	4605      	mov	r5, r0
 800216a:	b1c0      	cbz	r0, 800219e <canwinch_setup_F103_pod+0x42>

	/* Check for more init problems. */
	if (pctl->ret != 0) return pctl;
 800216c:	f990 309c 	ldrsb.w	r3, [r0, #156]	; 0x9c
 8002170:	b9ab      	cbnz	r3, 800219e <canwinch_setup_F103_pod+0x42>
 * @return	: 0 = success; -1 for error
*******************************************************************************/
static int canwinch_setup_F103_filter(u32 canid)
{
	/* Turn off active bit for all filters (including those for CAN2!). */
	can_driver_filter_deactivate_all();
 8002172:	f001 f881 	bl	8003278 <can_driver_filter_deactivate_all>

	/* Insert new filters and activate. */
	int ret;
	ret  = can_driver_filter_insert((struct CANFILTERPARAM*)&fb0); // Hi-priority group
 8002176:	480c      	ldr	r0, [pc, #48]	; (80021a8 <canwinch_setup_F103_pod+0x4c>)
 8002178:	f001 f8c2 	bl	8003300 <can_driver_filter_insert>
	ret |= can_driver_filter_add_two_32b_id(canid, CANID_DUMMY, 1, 1); // Unit ID
 800217c:	2301      	movs	r3, #1
	/* Turn off active bit for all filters (including those for CAN2!). */
	can_driver_filter_deactivate_all();

	/* Insert new filters and activate. */
	int ret;
	ret  = can_driver_filter_insert((struct CANFILTERPARAM*)&fb0); // Hi-priority group
 800217e:	4604      	mov	r4, r0
	ret |= can_driver_filter_add_two_32b_id(canid, CANID_DUMMY, 1, 1); // Unit ID
 8002180:	461a      	mov	r2, r3
 8002182:	f06f 0103 	mvn.w	r1, #3
 8002186:	4630      	mov	r0, r6
 8002188:	f001 f9ae 	bl	80034e8 <can_driver_filter_add_two_32b_id>
 800218c:	4304      	orrs	r4, r0
	ret |= can_driver_filter_insert((struct CANFILTERPARAM*)&fb2); // FIFO0 gets all others
 800218e:	4807      	ldr	r0, [pc, #28]	; (80021ac <canwinch_setup_F103_pod+0x50>)
 8002190:	f001 f8b6 	bl	8003300 <can_driver_filter_insert>
	/* Check for more init problems. */
	if (pctl->ret != 0) return pctl;

	/* Here, CAN init OK.  Setup hardware msg filtering */
	int ret = canwinch_setup_F103_filter(canid);
	if (ret != 0) pctl->ret = (ret - 7); // Set ret to -8 or -9
 8002194:	4320      	orrs	r0, r4
 8002196:	bf1c      	itt	ne
 8002198:	3807      	subne	r0, #7
 800219a:	f885 009c 	strbne.w	r0, [r5, #156]	; 0x9c

	return pctl;
	
}
 800219e:	4628      	mov	r0, r5
 80021a0:	bd70      	pop	{r4, r5, r6, pc}
 80021a2:	bf00      	nop
 80021a4:	080040c4 	.word	0x080040c4
 80021a8:	080040ec 	.word	0x080040ec
 80021ac:	080040f8 	.word	0x080040f8

080021b0 <loop>:
{
	GPIO_BSRR(GPIOE) = 0x38;
	return;
}	
static void loop(volatile int ct)
{
 80021b0:	b082      	sub	sp, #8
 80021b2:	9001      	str	r0, [sp, #4]
	while (ct > 0) ct -= 1; 
 80021b4:	9b01      	ldr	r3, [sp, #4]
 80021b6:	2b00      	cmp	r3, #0
 80021b8:	dd03      	ble.n	80021c2 <loop+0x12>
 80021ba:	9b01      	ldr	r3, [sp, #4]
 80021bc:	3b01      	subs	r3, #1
 80021be:	9301      	str	r3, [sp, #4]
 80021c0:	e7f8      	b.n	80021b4 <loop+0x4>
	return;
}
 80021c2:	b002      	add	sp, #8
 80021c4:	4770      	bx	lr

080021c6 <panic_leds_pod>:
	volatile int x;		// Loop ct for timing pause
	volatile int xon;	// Loop ct for timing LED on duration
	volatile int xoff;	// Loop ct for timing LED off duration

	/* Have clocks been setup? */
	if (sysclk_freq < 1000000)
 80021c6:	4b1b      	ldr	r3, [pc, #108]	; (8002234 <panic_leds_pod+0x6e>)
 80021c8:	4a1b      	ldr	r2, [pc, #108]	; (8002238 <panic_leds_pod+0x72>)
 80021ca:	6819      	ldr	r1, [r3, #0]
void panic_leds_pod(unsigned int count);
 * @param	: Number of fast flashes
 * @brief	: Configure gpio pins
 ******************************************************************************/
void panic_leds_pod(unsigned int count)
{
 80021cc:	b5f0      	push	{r4, r5, r6, r7, lr}
	volatile int x;		// Loop ct for timing pause
	volatile int xon;	// Loop ct for timing LED on duration
	volatile int xoff;	// Loop ct for timing LED off duration

	/* Have clocks been setup? */
	if (sysclk_freq < 1000000)
 80021ce:	4291      	cmp	r1, r2
	{ // Here, no.  We are running on the 8 MHz HSI oscillator
		sysclk_freq = 8000000;	// Set default
 80021d0:	bf98      	it	ls
 80021d2:	4a1a      	ldrls	r2, [pc, #104]	; (800223c <panic_leds_pod+0x76>)
void panic_leds_pod(unsigned int count);
 * @param	: Number of fast flashes
 * @brief	: Configure gpio pins
 ******************************************************************************/
void panic_leds_pod(unsigned int count)
{
 80021d4:	b085      	sub	sp, #20
	volatile int xoff;	// Loop ct for timing LED off duration

	/* Have clocks been setup? */
	if (sysclk_freq < 1000000)
	{ // Here, no.  We are running on the 8 MHz HSI oscillator
		sysclk_freq = 8000000;	// Set default
 80021d6:	bf98      	it	ls
 80021d8:	601a      	strls	r2, [r3, #0]
	}

	/* Setup timing for pause */
	x = sysclk_freq/10;
 80021da:	681b      	ldr	r3, [r3, #0]
 80021dc:	220a      	movs	r2, #10
 80021de:	fbb3 f2f2 	udiv	r2, r3, r2
 80021e2:	9201      	str	r2, [sp, #4]

	/* Setup timing for fast flash */
	xon =  sysclk_freq/250;
 80021e4:	22fa      	movs	r2, #250	; 0xfa
 80021e6:	fbb3 f2f2 	udiv	r2, r3, r2
 80021ea:	9202      	str	r2, [sp, #8]
	xoff = sysclk_freq/40;
 80021ec:	2228      	movs	r2, #40	; 0x28
 80021ee:	fbb3 f3f2 	udiv	r3, r3, r2
void panic_leds_pod(unsigned int count);
 * @param	: Number of fast flashes
 * @brief	: Configure gpio pins
 ******************************************************************************/
void panic_leds_pod(unsigned int count)
{
 80021f2:	4604      	mov	r4, r0
	/* Setup timing for pause */
	x = sysclk_freq/10;

	/* Setup timing for fast flash */
	xon =  sysclk_freq/250;
	xoff = sysclk_freq/40;
 80021f4:	9303      	str	r3, [sp, #12]

	/* Limit max count */
	if (count == 0) count = 6; // Bogus count
 80021f6:	b118      	cbz	r0, 8002200 <panic_leds_pod+0x3a>
	if (count > 6)  count = 7; // Bogus count
 80021f8:	2807      	cmp	r0, #7
 80021fa:	bf28      	it	cs
 80021fc:	2407      	movcs	r4, #7
 80021fe:	e000      	b.n	8002202 <panic_leds_pod+0x3c>
	/* Setup timing for fast flash */
	xon =  sysclk_freq/250;
	xoff = sysclk_freq/40;

	/* Limit max count */
	if (count == 0) count = 6; // Bogus count
 8002200:	2406      	movs	r4, #6
	if (count > 6)  count = 7; // Bogus count

	/* Be sure we have the ports and pins setup for the LEDs */
	PODgpiopins_default();	// Set gpio port register bits for low power
 8002202:	f000 fa31 	bl	8002668 <PODgpiopins_default>
	PODgpiopins_Config();	// Now, configure pins
 8002206:	f000 f9b1 	bl	800256c <PODgpiopins_Config>

extern unsigned int	sysclk_freq;	/* 	SYSCLK freq		E.g. 72000000	*/

static void allon(void)
{
	GPIO_BRR(GPIOE) = 0x38;
 800220a:	4d0d      	ldr	r5, [pc, #52]	; (8002240 <panic_leds_pod+0x7a>)
	return;
}
static void alloff(void)
{
	GPIO_BSRR(GPIOE) = 0x38;
 800220c:	4e0d      	ldr	r6, [pc, #52]	; (8002244 <panic_leds_pod+0x7e>)

extern unsigned int	sysclk_freq;	/* 	SYSCLK freq		E.g. 72000000	*/

static void allon(void)
{
	GPIO_BRR(GPIOE) = 0x38;
 800220e:	2138      	movs	r1, #56	; 0x38
 8002210:	460f      	mov	r7, r1
	PODgpiopins_Config();	// Now, configure pins
	
	/* Now flash, flash, flash away, ye' rummies.  Batten the hatches, 'er there be trouble. */
	while (1==1)
	{
		for (i = 0; i < count; i++)
 8002212:	2200      	movs	r2, #0

extern unsigned int	sysclk_freq;	/* 	SYSCLK freq		E.g. 72000000	*/

static void allon(void)
{
	GPIO_BRR(GPIOE) = 0x38;
 8002214:	802f      	strh	r7, [r5, #0]
	/* Now flash, flash, flash away, ye' rummies.  Batten the hatches, 'er there be trouble. */
	while (1==1)
	{
		for (i = 0; i < count; i++)
		{
			allon();	loop(xon);
 8002216:	9802      	ldr	r0, [sp, #8]
 8002218:	f7ff ffca 	bl	80021b0 <loop>
	GPIO_BRR(GPIOE) = 0x38;
	return;
}
static void alloff(void)
{
	GPIO_BSRR(GPIOE) = 0x38;
 800221c:	6031      	str	r1, [r6, #0]
	while (1==1)
	{
		for (i = 0; i < count; i++)
		{
			allon();	loop(xon);
			alloff();	loop(xoff);			
 800221e:	9803      	ldr	r0, [sp, #12]
 8002220:	f7ff ffc6 	bl	80021b0 <loop>
	PODgpiopins_Config();	// Now, configure pins
	
	/* Now flash, flash, flash away, ye' rummies.  Batten the hatches, 'er there be trouble. */
	while (1==1)
	{
		for (i = 0; i < count; i++)
 8002224:	3201      	adds	r2, #1
 8002226:	4294      	cmp	r4, r2
 8002228:	d1f4      	bne.n	8002214 <panic_leds_pod+0x4e>
		{
			allon();	loop(xon);
			alloff();	loop(xoff);			
		}
		loop(x);
 800222a:	9801      	ldr	r0, [sp, #4]
 800222c:	f7ff ffc0 	bl	80021b0 <loop>
	}	
 8002230:	e7ed      	b.n	800220e <panic_leds_pod+0x48>
 8002232:	bf00      	nop
 8002234:	200010d4 	.word	0x200010d4
 8002238:	000f423f 	.word	0x000f423f
 800223c:	007a1200 	.word	0x007a1200
 8002240:	40011814 	.word	0x40011814
 8002244:	40011810 	.word	0x40011810

08002248 <flash_write_ram>:
      ●    Read the programmed value and verify.
Note: The registers are not accessible in write mode when the BSY bit of the FLASH_SR register
      is set.
*/
int flash_write_ram(u16 *pflash, u16 *pfrom, int count)
{
 8002248:	b5f0      	push	{r4, r5, r6, r7, lr}
	while (count > 0)
	{
		while ((FLASH_SR & 0x1) != 0);
		FLASH_CR |= 1;	// Set program bit
 800224a:	4b12      	ldr	r3, [pc, #72]	; (8002294 <flash_write_ram+0x4c>)
*/
int flash_write_ram(u16 *pflash, u16 *pfrom, int count)
{
	while (count > 0)
	{
		while ((FLASH_SR & 0x1) != 0);
 800224c:	4d12      	ldr	r5, [pc, #72]	; (8002298 <flash_write_ram+0x50>)
 800224e:	461e      	mov	r6, r3
 8002250:	462f      	mov	r7, r5
 8002252:	3004      	adds	r0, #4
 8002254:	3104      	adds	r1, #4
Note: The registers are not accessible in write mode when the BSY bit of the FLASH_SR register
      is set.
*/
int flash_write_ram(u16 *pflash, u16 *pfrom, int count)
{
	while (count > 0)
 8002256:	2a00      	cmp	r2, #0
 8002258:	dd19      	ble.n	800228e <flash_write_ram+0x46>
	{
		while ((FLASH_SR & 0x1) != 0);
 800225a:	682c      	ldr	r4, [r5, #0]
 800225c:	07e4      	lsls	r4, r4, #31
 800225e:	d4fc      	bmi.n	800225a <flash_write_ram+0x12>
		FLASH_CR |= 1;	// Set program bit
 8002260:	681c      	ldr	r4, [r3, #0]
 8002262:	f044 0401 	orr.w	r4, r4, #1
 8002266:	601c      	str	r4, [r3, #0]
		*pflash++ = *pfrom++;
 8002268:	f831 4c04 	ldrh.w	r4, [r1, #-4]
 800226c:	f820 4c04 	strh.w	r4, [r0, #-4]
		while ((FLASH_SR & 0x1) != 0);
 8002270:	683c      	ldr	r4, [r7, #0]
 8002272:	07e4      	lsls	r4, r4, #31
 8002274:	d4fc      	bmi.n	8002270 <flash_write_ram+0x28>
		FLASH_CR |= 1;	// Set program bit
 8002276:	6834      	ldr	r4, [r6, #0]
		*pflash++ = *pfrom++;
		count--;
 8002278:	3a01      	subs	r2, #1
	{
		while ((FLASH_SR & 0x1) != 0);
		FLASH_CR |= 1;	// Set program bit
		*pflash++ = *pfrom++;
		while ((FLASH_SR & 0x1) != 0);
		FLASH_CR |= 1;	// Set program bit
 800227a:	f044 0401 	orr.w	r4, r4, #1
 800227e:	6034      	str	r4, [r6, #0]
		*pflash++ = *pfrom++;
 8002280:	f831 4c02 	ldrh.w	r4, [r1, #-2]
 8002284:	3004      	adds	r0, #4
 8002286:	f820 4c06 	strh.w	r4, [r0, #-6]
 800228a:	3104      	adds	r1, #4
 800228c:	e7e3      	b.n	8002256 <flash_write_ram+0xe>
		count--;
	}
	
	return 0;	
}
 800228e:	2000      	movs	r0, #0
 8002290:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002292:	bf00      	nop
 8002294:	40022010 	.word	0x40022010
 8002298:	4002200c 	.word	0x4002200c

0800229c <flash_unlock>:
#define FLASH_KEY1  0x45670123	// Unlock 1st
#define FLASH_KEY2  0xCDEF89AB	// Unlock 2nd

int flash_unlock(void)
{
	FLASH_KEYR = 0x45670123;
 800229c:	4b04      	ldr	r3, [pc, #16]	; (80022b0 <flash_unlock+0x14>)
 800229e:	4a05      	ldr	r2, [pc, #20]	; (80022b4 <flash_unlock+0x18>)
 80022a0:	601a      	str	r2, [r3, #0]
	FLASH_KEYR = 0xCDEF89AB;
 80022a2:	f102 3288 	add.w	r2, r2, #2290649224	; 0x88888888
 80022a6:	601a      	str	r2, [r3, #0]
	return (FLASH_CR & FLASH_LOCK);
 80022a8:	68d8      	ldr	r0, [r3, #12]
}
 80022aa:	f000 0080 	and.w	r0, r0, #128	; 0x80
 80022ae:	4770      	bx	lr
 80022b0:	40022004 	.word	0x40022004
 80022b4:	45670123 	.word	0x45670123

080022b8 <flash_unlock2>:
int flash_unlock2(void)
{
	FLASH_KEYR2 = 0x45670123;
 80022b8:	4b04      	ldr	r3, [pc, #16]	; (80022cc <flash_unlock2+0x14>)
 80022ba:	4a05      	ldr	r2, [pc, #20]	; (80022d0 <flash_unlock2+0x18>)
 80022bc:	601a      	str	r2, [r3, #0]
	FLASH_KEYR2 = 0xCDEF89AB;
 80022be:	f102 3288 	add.w	r2, r2, #2290649224	; 0x88888888
 80022c2:	601a      	str	r2, [r3, #0]
	return (FLASH_CR2 & FLASH_LOCK);
 80022c4:	68d8      	ldr	r0, [r3, #12]
}
 80022c6:	f000 0080 	and.w	r0, r0, #128	; 0x80
 80022ca:	4770      	bx	lr
 80022cc:	40022044 	.word	0x40022044
 80022d0:	45670123 	.word	0x45670123

080022d4 <flash_write>:
 *          -4 = unlock sequence failed for lower bank
 *          -5 = error at some point in the writes, flash_err has the bits
*******************************************************************************/
u32 flash_err;
int flash_write(u16 *pflash, u16 *pfrom, int count)
{
 80022d4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
			flash_err |= FLASH_SR2;			
		}
		else
		{ // Here maybe 1st bank
			if (pflash < (u16*)0x0800000)  return -3;
			while ((FLASH_SR & 0x1) != 0);	// Wait for busy to go away
 80022d8:	4f31      	ldr	r7, [pc, #196]	; (80023a0 <flash_write+0xcc>)
 *          -4 = unlock sequence failed for lower bank
 *          -5 = error at some point in the writes, flash_err has the bits
*******************************************************************************/
u32 flash_err;
int flash_write(u16 *pflash, u16 *pfrom, int count)
{
 80022da:	4691      	mov	r9, r2
 80022dc:	4605      	mov	r5, r0
 80022de:	46b8      	mov	r8, r7
 80022e0:	46ba      	mov	sl, r7
	int i;
	flash_err = 0;
 80022e2:	4c30      	ldr	r4, [pc, #192]	; (80023a4 <flash_write+0xd0>)
 80022e4:	2600      	movs	r6, #0
 80022e6:	6026      	str	r6, [r4, #0]
 80022e8:	3102      	adds	r1, #2
	for (i = 0; i < count; i++)
 80022ea:	454e      	cmp	r6, r9
 80022ec:	da3f      	bge.n	800236e <flash_write+0x9a>
	{
		if (pflash >= (u16*)0x08080000)
 80022ee:	4b2e      	ldr	r3, [pc, #184]	; (80023a8 <flash_write+0xd4>)
 80022f0:	429d      	cmp	r5, r3
 80022f2:	d91d      	bls.n	8002330 <flash_write+0x5c>
		{ // Here maybe 2nd bank
			if (pflash > (u16*)0x080FFFFe)  return -1;
 80022f4:	4b2d      	ldr	r3, [pc, #180]	; (80023ac <flash_write+0xd8>)
 80022f6:	429d      	cmp	r5, r3
 80022f8:	d842      	bhi.n	8002380 <flash_write+0xac>
			while ((FLASH_SR2 & 0x1) != 0);	// Wait for busy to go away
 80022fa:	4a2d      	ldr	r2, [pc, #180]	; (80023b0 <flash_write+0xdc>)
 80022fc:	6813      	ldr	r3, [r2, #0]
 80022fe:	f8df b0b0 	ldr.w	fp, [pc, #176]	; 80023b0 <flash_write+0xdc>
 8002302:	f013 0f01 	tst.w	r3, #1
 8002306:	d1f9      	bne.n	80022fc <flash_write+0x28>
			if (flash_unlock2() != 0) return -2;
 8002308:	f7ff ffd6 	bl	80022b8 <flash_unlock2>
 800230c:	2800      	cmp	r0, #0
 800230e:	d13b      	bne.n	8002388 <flash_write+0xb4>
			FLASH_SR2 = (FLASH_EOP | FLASH_WRPRTERR | FLASH_PGERR); // Clear any error bits
 8002310:	2334      	movs	r3, #52	; 0x34
 8002312:	f8cb 3000 	str.w	r3, [fp]
			FLASH_CR2 = FLASH_PG;		// Set program bit
 8002316:	4b27      	ldr	r3, [pc, #156]	; (80023b4 <flash_write+0xe0>)
 8002318:	2201      	movs	r2, #1
 800231a:	601a      	str	r2, [r3, #0]
			*pflash++ = *pfrom++;		// Program the 1/2 word
 800231c:	f831 3c02 	ldrh.w	r3, [r1, #-2]
 8002320:	802b      	strh	r3, [r5, #0]
			while ((FLASH_SR2 & 0x1) != 0);	// Wait for busy to go away
 8002322:	f8db 3000 	ldr.w	r3, [fp]
 8002326:	07db      	lsls	r3, r3, #31
 8002328:	d4fb      	bmi.n	8002322 <flash_write+0x4e>
			flash_err |= FLASH_SR2;			
 800232a:	4b21      	ldr	r3, [pc, #132]	; (80023b0 <flash_write+0xdc>)
 800232c:	681a      	ldr	r2, [r3, #0]
 800232e:	e017      	b.n	8002360 <flash_write+0x8c>
		}
		else
		{ // Here maybe 1st bank
			if (pflash < (u16*)0x0800000)  return -3;
 8002330:	f5b5 0f00 	cmp.w	r5, #8388608	; 0x800000
 8002334:	d32c      	bcc.n	8002390 <flash_write+0xbc>
			while ((FLASH_SR & 0x1) != 0);	// Wait for busy to go away
 8002336:	683b      	ldr	r3, [r7, #0]
 8002338:	07da      	lsls	r2, r3, #31
 800233a:	d4fc      	bmi.n	8002336 <flash_write+0x62>
			if (flash_unlock() != 0) return -4;
 800233c:	f7ff ffae 	bl	800229c <flash_unlock>
 8002340:	bb50      	cbnz	r0, 8002398 <flash_write+0xc4>
			FLASH_SR = (FLASH_EOP | FLASH_WRPRTERR | FLASH_PGERR); // Clear any error bits
 8002342:	2334      	movs	r3, #52	; 0x34
 8002344:	f8c8 3000 	str.w	r3, [r8]
			FLASH_CR = FLASH_PG;		// Set program bit
 8002348:	4b1b      	ldr	r3, [pc, #108]	; (80023b8 <flash_write+0xe4>)
 800234a:	2201      	movs	r2, #1
 800234c:	601a      	str	r2, [r3, #0]
			*pflash++ = *pfrom++;		// Program the 1/2 word
 800234e:	f831 3c02 	ldrh.w	r3, [r1, #-2]
 8002352:	802b      	strh	r3, [r5, #0]
			while ((FLASH_SR & 0x1) != 0);	// Wait for busy to go away
 8002354:	f8da 3000 	ldr.w	r3, [sl]
 8002358:	07db      	lsls	r3, r3, #31
 800235a:	d4fb      	bmi.n	8002354 <flash_write+0x80>
			flash_err |= FLASH_SR;			
 800235c:	f8d8 2000 	ldr.w	r2, [r8]
 8002360:	6823      	ldr	r3, [r4, #0]
u32 flash_err;
int flash_write(u16 *pflash, u16 *pfrom, int count)
{
	int i;
	flash_err = 0;
	for (i = 0; i < count; i++)
 8002362:	3601      	adds	r6, #1
			if (flash_unlock() != 0) return -4;
			FLASH_SR = (FLASH_EOP | FLASH_WRPRTERR | FLASH_PGERR); // Clear any error bits
			FLASH_CR = FLASH_PG;		// Set program bit
			*pflash++ = *pfrom++;		// Program the 1/2 word
			while ((FLASH_SR & 0x1) != 0);	// Wait for busy to go away
			flash_err |= FLASH_SR;			
 8002364:	4313      	orrs	r3, r2
 8002366:	6023      	str	r3, [r4, #0]
 8002368:	3502      	adds	r5, #2
 800236a:	3102      	adds	r1, #2
 800236c:	e7bd      	b.n	80022ea <flash_write+0x16>
		}
	}	
	if ( (flash_err & (FLASH_WRPRTERR | FLASH_PGERR)) != 0) return -5;	
 800236e:	6823      	ldr	r3, [r4, #0]
	return 0;
 8002370:	f013 0f14 	tst.w	r3, #20
 8002374:	bf14      	ite	ne
 8002376:	f06f 0004 	mvnne.w	r0, #4
 800237a:	2000      	moveq	r0, #0
 800237c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	flash_err = 0;
	for (i = 0; i < count; i++)
	{
		if (pflash >= (u16*)0x08080000)
		{ // Here maybe 2nd bank
			if (pflash > (u16*)0x080FFFFe)  return -1;
 8002380:	f04f 30ff 	mov.w	r0, #4294967295
 8002384:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			while ((FLASH_SR2 & 0x1) != 0);	// Wait for busy to go away
			if (flash_unlock2() != 0) return -2;
 8002388:	f06f 0001 	mvn.w	r0, #1
 800238c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			while ((FLASH_SR2 & 0x1) != 0);	// Wait for busy to go away
			flash_err |= FLASH_SR2;			
		}
		else
		{ // Here maybe 1st bank
			if (pflash < (u16*)0x0800000)  return -3;
 8002390:	f06f 0002 	mvn.w	r0, #2
 8002394:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			while ((FLASH_SR & 0x1) != 0);	// Wait for busy to go away
			if (flash_unlock() != 0) return -4;
 8002398:	f06f 0003 	mvn.w	r0, #3
			flash_err |= FLASH_SR;			
		}
	}	
	if ( (flash_err & (FLASH_WRPRTERR | FLASH_PGERR)) != 0) return -5;	
	return 0;
}
 800239c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80023a0:	4002200c 	.word	0x4002200c
 80023a4:	200018fc 	.word	0x200018fc
 80023a8:	0807ffff 	.word	0x0807ffff
 80023ac:	080ffffe 	.word	0x080ffffe
 80023b0:	4002204c 	.word	0x4002204c
 80023b4:	40022050 	.word	0x40022050
 80023b8:	40022010 	.word	0x40022010

080023bc <flash_erase>:
● Wait for the BSY bit to be reset
● Read the erased page and verify
*/
int flash_erase(u16 *pflash)
{
	flash_err = 0;
 80023bc:	492d      	ldr	r1, [pc, #180]	; (8002474 <flash_erase+0xb8>)
● Set the STRT bit in the FLASH_CR register
● Wait for the BSY bit to be reset
● Read the erased page and verify
*/
int flash_erase(u16 *pflash)
{
 80023be:	b538      	push	{r3, r4, r5, lr}
	flash_err = 0;
 80023c0:	2300      	movs	r3, #0
 80023c2:	600b      	str	r3, [r1, #0]
	if (pflash >= (u16*)0x08080000)
 80023c4:	4b2c      	ldr	r3, [pc, #176]	; (8002478 <flash_erase+0xbc>)
● Set the STRT bit in the FLASH_CR register
● Wait for the BSY bit to be reset
● Read the erased page and verify
*/
int flash_erase(u16 *pflash)
{
 80023c6:	4604      	mov	r4, r0
	flash_err = 0;
	if (pflash >= (u16*)0x08080000)
 80023c8:	4298      	cmp	r0, r3
 80023ca:	d91e      	bls.n	800240a <flash_erase+0x4e>
	{ // Here maybe 2nd bank
		if (pflash > (u16*)0x080FFFFe)  return -1;
 80023cc:	4b2b      	ldr	r3, [pc, #172]	; (800247c <flash_erase+0xc0>)
 80023ce:	4298      	cmp	r0, r3
 80023d0:	d844      	bhi.n	800245c <flash_erase+0xa0>
		while ((FLASH_SR2 & 0x1) != 0);	// Wait for busy to go away
 80023d2:	4a2b      	ldr	r2, [pc, #172]	; (8002480 <flash_erase+0xc4>)
 80023d4:	6813      	ldr	r3, [r2, #0]
 80023d6:	4d2a      	ldr	r5, [pc, #168]	; (8002480 <flash_erase+0xc4>)
 80023d8:	f013 0f01 	tst.w	r3, #1
 80023dc:	d1fa      	bne.n	80023d4 <flash_erase+0x18>
		if (flash_unlock2() != 0) return -2;
 80023de:	f7ff ff6b 	bl	80022b8 <flash_unlock2>
 80023e2:	2800      	cmp	r0, #0
 80023e4:	d13d      	bne.n	8002462 <flash_erase+0xa6>
		FLASH_CR2 = FLASH_PER;		// Set Page Erase function
 80023e6:	4b27      	ldr	r3, [pc, #156]	; (8002484 <flash_erase+0xc8>)
 80023e8:	2202      	movs	r2, #2
 80023ea:	601a      	str	r2, [r3, #0]
		FLASH_AR2 = (u32)pflash;	// Set page address
 80023ec:	4a26      	ldr	r2, [pc, #152]	; (8002488 <flash_erase+0xcc>)
 80023ee:	6014      	str	r4, [r2, #0]
		FLASH_CR2 |= FLASH_STRT;	// Start erase
 80023f0:	681a      	ldr	r2, [r3, #0]
 80023f2:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80023f6:	601a      	str	r2, [r3, #0]
		while ((FLASH_SR2 & 0x1) != 0);	// Wait for busy to go away
 80023f8:	682a      	ldr	r2, [r5, #0]
 80023fa:	07d4      	lsls	r4, r2, #31
 80023fc:	d4fc      	bmi.n	80023f8 <flash_erase+0x3c>
		FLASH_CR2 &= ~FLASH_PER;	// Remove PER bit
 80023fe:	681a      	ldr	r2, [r3, #0]
 8002400:	f022 0202 	bic.w	r2, r2, #2
 8002404:	601a      	str	r2, [r3, #0]
		flash_err |= FLASH_SR2;
 8002406:	4b1e      	ldr	r3, [pc, #120]	; (8002480 <flash_erase+0xc4>)
 8002408:	e01c      	b.n	8002444 <flash_erase+0x88>
	}
	else
	{ // Here maybe 1st bank
		if (pflash < (u16*)0x0800000)  return -3;
 800240a:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 800240e:	d32b      	bcc.n	8002468 <flash_erase+0xac>
		while ((FLASH_SR & 0x1) != 0);	// Wait for busy to go away
 8002410:	4a1e      	ldr	r2, [pc, #120]	; (800248c <flash_erase+0xd0>)
 8002412:	6813      	ldr	r3, [r2, #0]
 8002414:	4d1d      	ldr	r5, [pc, #116]	; (800248c <flash_erase+0xd0>)
 8002416:	f013 0f01 	tst.w	r3, #1
 800241a:	d1fa      	bne.n	8002412 <flash_erase+0x56>
		if (flash_unlock() != 0) return -4;
 800241c:	f7ff ff3e 	bl	800229c <flash_unlock>
 8002420:	bb28      	cbnz	r0, 800246e <flash_erase+0xb2>
		FLASH_CR = FLASH_PER;		// Set Page Erase function
 8002422:	4b1b      	ldr	r3, [pc, #108]	; (8002490 <flash_erase+0xd4>)
 8002424:	2202      	movs	r2, #2
 8002426:	601a      	str	r2, [r3, #0]
		FLASH_AR = (u32)pflash;		// Set page address
 8002428:	4a1a      	ldr	r2, [pc, #104]	; (8002494 <flash_erase+0xd8>)
 800242a:	6014      	str	r4, [r2, #0]
		FLASH_CR |= FLASH_STRT;		// Start erase
 800242c:	681a      	ldr	r2, [r3, #0]
 800242e:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8002432:	601a      	str	r2, [r3, #0]
		while ((FLASH_SR & 0x1) != 0);	// Wait for busy to go away
 8002434:	682a      	ldr	r2, [r5, #0]
 8002436:	07d2      	lsls	r2, r2, #31
 8002438:	d4fc      	bmi.n	8002434 <flash_erase+0x78>
		FLASH_CR &= ~FLASH_PER;		// Remove PER bit
 800243a:	681a      	ldr	r2, [r3, #0]
 800243c:	f022 0202 	bic.w	r2, r2, #2
 8002440:	601a      	str	r2, [r3, #0]
		flash_err |= FLASH_SR;
 8002442:	4b12      	ldr	r3, [pc, #72]	; (800248c <flash_erase+0xd0>)
 8002444:	681b      	ldr	r3, [r3, #0]
 8002446:	680a      	ldr	r2, [r1, #0]
 8002448:	4313      	orrs	r3, r2
 800244a:	600b      	str	r3, [r1, #0]
	}
	if ( (flash_err & (FLASH_WRPRTERR | FLASH_PGERR)) != 0) return -5;
 800244c:	680b      	ldr	r3, [r1, #0]
	return 0;
 800244e:	f013 0f14 	tst.w	r3, #20
 8002452:	bf14      	ite	ne
 8002454:	f06f 0004 	mvnne.w	r0, #4
 8002458:	2000      	moveq	r0, #0
 800245a:	bd38      	pop	{r3, r4, r5, pc}
int flash_erase(u16 *pflash)
{
	flash_err = 0;
	if (pflash >= (u16*)0x08080000)
	{ // Here maybe 2nd bank
		if (pflash > (u16*)0x080FFFFe)  return -1;
 800245c:	f04f 30ff 	mov.w	r0, #4294967295
 8002460:	bd38      	pop	{r3, r4, r5, pc}
		while ((FLASH_SR2 & 0x1) != 0);	// Wait for busy to go away
		if (flash_unlock2() != 0) return -2;
 8002462:	f06f 0001 	mvn.w	r0, #1
 8002466:	bd38      	pop	{r3, r4, r5, pc}
		FLASH_CR2 &= ~FLASH_PER;	// Remove PER bit
		flash_err |= FLASH_SR2;
	}
	else
	{ // Here maybe 1st bank
		if (pflash < (u16*)0x0800000)  return -3;
 8002468:	f06f 0002 	mvn.w	r0, #2
 800246c:	bd38      	pop	{r3, r4, r5, pc}
		while ((FLASH_SR & 0x1) != 0);	// Wait for busy to go away
		if (flash_unlock() != 0) return -4;
 800246e:	f06f 0003 	mvn.w	r0, #3
		FLASH_CR &= ~FLASH_PER;		// Remove PER bit
		flash_err |= FLASH_SR;
	}
	if ( (flash_err & (FLASH_WRPRTERR | FLASH_PGERR)) != 0) return -5;
	return 0;
}
 8002472:	bd38      	pop	{r3, r4, r5, pc}
 8002474:	200018fc 	.word	0x200018fc
 8002478:	0807ffff 	.word	0x0807ffff
 800247c:	080ffffe 	.word	0x080ffffe
 8002480:	4002204c 	.word	0x4002204c
 8002484:	40022050 	.word	0x40022050
 8002488:	40022054 	.word	0x40022054
 800248c:	4002200c 	.word	0x4002200c
 8002490:	40022010 	.word	0x40022010
 8002494:	40022014 	.word	0x40022014

08002498 <SENSORgpiopins_Config>:
const struct PINCONFIGALL led21green = {(volatile u32 *)GPIOB, 15, OUT_PP, MHZ_2};
const struct PINCONFIGALL led20red   = {(volatile u32 *)GPIOC,  5, OUT_PP, MHZ_2};
const struct PINCONFIGALL led19red   = {(volatile u32 *)GPIOC,  4, OUT_PP, MHZ_2};

int SENSORgpiopins_Config(void)
{
 8002498:	b538      	push	{r3, r4, r5, lr}
	int err;

	/* LEDs set for push-pull output, slowest speed */
	err =  pinconfig_all( (struct PINCONFIGALL *)&led21green);
 800249a:	4d08      	ldr	r5, [pc, #32]	; (80024bc <SENSORgpiopins_Config+0x24>)
 800249c:	4628      	mov	r0, r5
 800249e:	f000 f821 	bl	80024e4 <pinconfig_all>
 80024a2:	4604      	mov	r4, r0
	err |= pinconfig_all( (struct PINCONFIGALL *)&led20red);
 80024a4:	f105 0008 	add.w	r0, r5, #8
 80024a8:	f000 f81c 	bl	80024e4 <pinconfig_all>
 80024ac:	4304      	orrs	r4, r0
	err |= pinconfig_all( (struct PINCONFIGALL *)&led19red);
 80024ae:	f105 0010 	add.w	r0, r5, #16
 80024b2:	f000 f817 	bl	80024e4 <pinconfig_all>

	return err;

}
 80024b6:	4320      	orrs	r0, r4
 80024b8:	bd38      	pop	{r3, r4, r5, pc}
 80024ba:	bf00      	nop
 80024bc:	08004104 	.word	0x08004104

080024c0 <configure_pin>:
 * @param	: bit in port to set or reset
 **************************************************************************************************************** */
void configure_pin ( volatile u32 * p, int n)
{
		
	if (n >= 8)
 80024c0:	2907      	cmp	r1, #7
	{ // Here, the high byte register (CRH), else low byte register (CRL)
		p = p + 0x01;	// point to high register
 80024c2:	bfc4      	itt	gt
 80024c4:	3004      	addgt	r0, #4
		n -= 8;		// adjust shift count 
 80024c6:	3908      	subgt	r1, #8
	}

	/* Reset CNF bits */
	*p &= ~((0x000f ) << ( 4 * n ));	// Clear CNF reset bit 01 = Floating input (reset state)
 80024c8:	6802      	ldr	r2, [r0, #0]
 80024ca:	0089      	lsls	r1, r1, #2
 80024cc:	230f      	movs	r3, #15
 80024ce:	408b      	lsls	r3, r1
 80024d0:	ea22 0303 	bic.w	r3, r2, r3
 80024d4:	6003      	str	r3, [r0, #0]

	/* Set for pushpull output */
	*p |=  (( (GPIO_CNF_OUTPUT_PUSHPULL<<2) | (GPIO_MODE_OUTPUT_50_MHZ) ) << ( 4 * n ));	
 80024d6:	6803      	ldr	r3, [r0, #0]
 80024d8:	2203      	movs	r2, #3
 80024da:	fa02 f101 	lsl.w	r1, r2, r1
 80024de:	4319      	orrs	r1, r3
 80024e0:	6001      	str	r1, [r0, #0]
 80024e2:	4770      	bx	lr

080024e4 <pinconfig_all>:
 * @brief	: configure a pin according to the parameters in the struct
 * @param	: p = pointer to struct (see .h file)
 * @return	: negative = error; 0 = OK
 **************************************************************************************************************** */
int pinconfig_all (struct PINCONFIGALL *p)
{
 80024e4:	b510      	push	{r4, lr}
	u8 mode;	// Temp for building 'mode'
	u8 cnf;		// Temp for building 'cnf'
	u8 n = p->pin;			// bit number for port pin.  Save for later
 80024e6:	7903      	ldrb	r3, [r0, #4]
	volatile u32 *pp = p->port;	// port register address.  Save for later
 80024e8:	6802      	ldr	r2, [r0, #0]
	
	/* Check for out-of-bounds parameters */
	if (p->pin > 15) return -3;	// Pin number out of range
 80024ea:	2b0f      	cmp	r3, #15
 80024ec:	d832      	bhi.n	8002554 <pinconfig_all+0x70>
	if (p->speed > 3) return -2;	// Speed code out of range
 80024ee:	7981      	ldrb	r1, [r0, #6]
 80024f0:	2903      	cmp	r1, #3
 80024f2:	d832      	bhi.n	800255a <pinconfig_all+0x76>
	if (p->usecode > 7) return -1;	// Useage code out of range
 80024f4:	7941      	ldrb	r1, [r0, #5]
 80024f6:	2907      	cmp	r1, #7
 80024f8:	d832      	bhi.n	8002560 <pinconfig_all+0x7c>

	/* For input pull-up/dn set ODR register first */
	if (p->usecode == IN_PU)
		// Here, input with pull up, set bit in ODR register
		GPIO_BSRR((unsigned int)p->port) = (1 << p->pin); // Set bit
 80024fa:	bf02      	ittt	eq
 80024fc:	2101      	moveq	r1, #1
 80024fe:	4099      	lsleq	r1, r3
 8002500:	6111      	streq	r1, [r2, #16]
	if (p->usecode == IN_PD)
 8002502:	7941      	ldrb	r1, [r0, #5]
 8002504:	2906      	cmp	r1, #6
 8002506:	d104      	bne.n	8002512 <pinconfig_all+0x2e>
		// Here, input with pull down, clear bit in ODR register
		GPIO_BRR((unsigned int)p->port) = (1 << p->pin); // Reset bit
 8002508:	7904      	ldrb	r4, [r0, #4]
 800250a:	2101      	movs	r1, #1
 800250c:	40a1      	lsls	r1, r4
 800250e:	b289      	uxth	r1, r1
 8002510:	8291      	strh	r1, [r2, #20]
	
	/* Adjust for port address for high and low registers that have the CNF|MODE bits. */
	if (n >= 8)	// Is this pin in the high or low register?
 8002512:	2b07      	cmp	r3, #7
	{ // Here, the high byte register (CRH), else low byte register (CRL)
		pp = pp + 0x01;	// point to high register (pins 8-15)
		n -= 8;		// adjust shift count 
 8002514:	bf82      	ittt	hi
 8002516:	3b08      	subhi	r3, #8
		GPIO_BRR((unsigned int)p->port) = (1 << p->pin); // Reset bit
	
	/* Adjust for port address for high and low registers that have the CNF|MODE bits. */
	if (n >= 8)	// Is this pin in the high or low register?
	{ // Here, the high byte register (CRH), else low byte register (CRL)
		pp = pp + 0x01;	// point to high register (pins 8-15)
 8002518:	3204      	addhi	r2, #4
		n -= 8;		// adjust shift count 
 800251a:	b2db      	uxtbhi	r3, r3
	}

	/* Reset CNF & MODE bits */
	*pp &= ~((0x000f ) << ( 4 * n ));	// Clear CNF reset bit 01 = Floating input (reset state)
 800251c:	6814      	ldr	r4, [r2, #0]
 800251e:	009b      	lsls	r3, r3, #2
 8002520:	210f      	movs	r1, #15
 8002522:	4099      	lsls	r1, r3
 8002524:	ea24 0101 	bic.w	r1, r4, r1
 8002528:	6011      	str	r1, [r2, #0]

	/* Derive 'mode' code from use code */
	if (p->usecode < 4)	// Is this an output useage?
 800252a:	7944      	ldrb	r4, [r0, #5]
 800252c:	2c03      	cmp	r4, #3
 800252e:	d802      	bhi.n	8002536 <pinconfig_all+0x52>
	{ // Here, yes.
		if (p->speed == 0) return -4;	// Outputs require a speed code
 8002530:	7981      	ldrb	r1, [r0, #6]
 8002532:	b931      	cbnz	r1, 8002542 <pinconfig_all+0x5e>
 8002534:	e017      	b.n	8002566 <pinconfig_all+0x82>
	}
	else
	{ // Here, input use
		mode = 0;
		cnf = (p->usecode - 4);	// cnf = 0-3
		if (p->usecode > 5)	// 6 or 7 = input pull up/dn
 8002536:	2c05      	cmp	r4, #5
		cnf = p->usecode; 	// cnf = 0-3.
	}
	else
	{ // Here, input use
		mode = 0;
		cnf = (p->usecode - 4);	// cnf = 0-3
 8002538:	bf9a      	itte	ls
 800253a:	1f21      	subls	r1, r4, #4
 800253c:	b2cc      	uxtbls	r4, r1
		if (p->usecode > 5)	// 6 or 7 = input pull up/dn
			cnf = 2;	// Same cnf code for pull up & pull dn.
 800253e:	2402      	movhi	r4, #2
		mode = p->speed;	// mode 1,2,3
		cnf = p->usecode; 	// cnf = 0-3.
	}
	else
	{ // Here, input use
		mode = 0;
 8002540:	2100      	movs	r1, #0
		if (p->usecode > 5)	// 6 or 7 = input pull up/dn
			cnf = 2;	// Same cnf code for pull up & pull dn.
	}

	/* Set cnf and mode */
	*pp |=  (( (cnf << 2) | (mode) ) << ( 4 * n ));	
 8002542:	6810      	ldr	r0, [r2, #0]
 8002544:	ea41 0184 	orr.w	r1, r1, r4, lsl #2
 8002548:	fa01 f303 	lsl.w	r3, r1, r3
 800254c:	4303      	orrs	r3, r0
 800254e:	6013      	str	r3, [r2, #0]
		
	return 0;
 8002550:	2000      	movs	r0, #0
 8002552:	bd10      	pop	{r4, pc}
	u8 cnf;		// Temp for building 'cnf'
	u8 n = p->pin;			// bit number for port pin.  Save for later
	volatile u32 *pp = p->port;	// port register address.  Save for later
	
	/* Check for out-of-bounds parameters */
	if (p->pin > 15) return -3;	// Pin number out of range
 8002554:	f06f 0002 	mvn.w	r0, #2
 8002558:	bd10      	pop	{r4, pc}
	if (p->speed > 3) return -2;	// Speed code out of range
 800255a:	f06f 0001 	mvn.w	r0, #1
 800255e:	bd10      	pop	{r4, pc}
	if (p->usecode > 7) return -1;	// Useage code out of range
 8002560:	f04f 30ff 	mov.w	r0, #4294967295
 8002564:	bd10      	pop	{r4, pc}
	*pp &= ~((0x000f ) << ( 4 * n ));	// Clear CNF reset bit 01 = Floating input (reset state)

	/* Derive 'mode' code from use code */
	if (p->usecode < 4)	// Is this an output useage?
	{ // Here, yes.
		if (p->speed == 0) return -4;	// Outputs require a speed code
 8002566:	f06f 0003 	mvn.w	r0, #3

	/* Set cnf and mode */
	*pp |=  (( (cnf << 2) | (mode) ) << ( 4 * n ));	
		
	return 0;
}
 800256a:	bd10      	pop	{r4, pc}

0800256c <PODgpiopins_Config>:
/* ----------------------------- PORTA -------------------------------------- */
	//  PA0- - POD_box (external) LED: gpio out
//	GPIO_CRL(GPIOA) &= ~((0x000f ) << (4*0));	// Clear CNF reset bit 01 = Floating input (reset state)
//	GPIO_CRL(GPIOA) |=  (( (GPIO_CNF_OUTPUT_PUSHPULL<<2) | (GPIO_MODE_OUTPUT_50_MHZ) ) << (4*0));
	//  PA4 - AD7799_2 /CS: gpio out
	GPIO_CRL(GPIOA) &= ~((0x000f ) << (4*4));	// Clear CNF reset bit 01 = Floating input (reset state)
 800256c:	4b37      	ldr	r3, [pc, #220]	; (800264c <PODgpiopins_Config+0xe0>)
 800256e:	681a      	ldr	r2, [r3, #0]
	//  PA7 - SPI1_MOSI: gpio out
	GPIO_CRL(GPIOA) &= ~((0x000f ) << (4*7));	// Clear CNF reset bit 01 = Floating input (reset state)
	GPIO_CRL(GPIOA) |=  (( (GPIO_CNF_OUTPUT_PUSHPULL<<2) | (GPIO_MODE_OUTPUT_50_MHZ) ) << (4*7));
	
	//  PA8 - 3.3v SD Card reg enable: gpio out
	GPIO_CRH(GPIOA) &= ~((0x000f ) << (4*0));	// Clear CNF reset bit 01 = Floating input (reset state)
 8002570:	3304      	adds	r3, #4
/* ----------------------------- PORTA -------------------------------------- */
	//  PA0- - POD_box (external) LED: gpio out
//	GPIO_CRL(GPIOA) &= ~((0x000f ) << (4*0));	// Clear CNF reset bit 01 = Floating input (reset state)
//	GPIO_CRL(GPIOA) |=  (( (GPIO_CNF_OUTPUT_PUSHPULL<<2) | (GPIO_MODE_OUTPUT_50_MHZ) ) << (4*0));
	//  PA4 - AD7799_2 /CS: gpio out
	GPIO_CRL(GPIOA) &= ~((0x000f ) << (4*4));	// Clear CNF reset bit 01 = Floating input (reset state)
 8002572:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
 8002576:	f843 2c04 	str.w	r2, [r3, #-4]
	GPIO_CRL(GPIOA) |=  (( (GPIO_CNF_OUTPUT_PUSHPULL<<2) | (GPIO_MODE_OUTPUT_50_MHZ) ) << (4*4));
 800257a:	f853 2c04 	ldr.w	r2, [r3, #-4]
 800257e:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
 8002582:	f843 2c04 	str.w	r2, [r3, #-4]
	//  PA7 - SPI1_MOSI: gpio out
	GPIO_CRL(GPIOA) &= ~((0x000f ) << (4*7));	// Clear CNF reset bit 01 = Floating input (reset state)
 8002586:	f853 2c04 	ldr.w	r2, [r3, #-4]
 800258a:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 800258e:	f843 2c04 	str.w	r2, [r3, #-4]
	GPIO_CRL(GPIOA) |=  (( (GPIO_CNF_OUTPUT_PUSHPULL<<2) | (GPIO_MODE_OUTPUT_50_MHZ) ) << (4*7));
 8002592:	f853 2c04 	ldr.w	r2, [r3, #-4]
 8002596:	f042 5240 	orr.w	r2, r2, #805306368	; 0x30000000
 800259a:	f843 2c04 	str.w	r2, [r3, #-4]
	
	//  PA8 - 3.3v SD Card reg enable: gpio out
	GPIO_CRH(GPIOA) &= ~((0x000f ) << (4*0));	// Clear CNF reset bit 01 = Floating input (reset state)
 800259e:	681a      	ldr	r2, [r3, #0]
 80025a0:	f022 020f 	bic.w	r2, r2, #15
 80025a4:	601a      	str	r2, [r3, #0]
	GPIO_CRH(GPIOA) |=  (( (GPIO_CNF_OUTPUT_PUSHPULL<<2 | GPIO_MODE_OUTPUT_50_MHZ) << (4*0) ) );	
 80025a6:	681a      	ldr	r2, [r3, #0]
 80025a8:	f042 0203 	orr.w	r2, r2, #3
 80025ac:	601a      	str	r2, [r3, #0]
/* ----------------------------- PORTB -------------------------------------- */
	// PB5	3.3v reg enable--XBee : gpio out
	GPIO_CRL(GPIOB) &= ~((0x000f ) << (4*5));	// Clear CNF reset bit 01 = Floating input (reset state)
 80025ae:	f8d3 23fc 	ldr.w	r2, [r3, #1020]	; 0x3fc
 80025b2:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
 80025b6:	f8c3 23fc 	str.w	r2, [r3, #1020]	; 0x3fc
	GPIO_CRL(GPIOB) |=  (( (GPIO_CNF_OUTPUT_PUSHPULL<<2 | GPIO_MODE_OUTPUT_50_MHZ) << (4*5)));	
 80025ba:	f8d3 23fc 	ldr.w	r2, [r3, #1020]	; 0x3fc
 80025be:	f442 1240 	orr.w	r2, r2, #3145728	; 0x300000
 80025c2:	f8c3 23fc 	str.w	r2, [r3, #1020]	; 0x3fc
	// PB8	XBee /DTR/SLEEP_RQ: gpio_out 
	// PB9	XBee /RESET: gpio_out 
	// PB10	AD7799_1 /CS:gpio_out
	// PB12	SD_CARD_CD/DAT3/CS:SPI2_NSS
	GPIO_CRH(GPIOB) &=  ~(  ((0x000f) << (4*0)) | ((0x000f) << (4*1)) | ((0x000f) << (4*2)) | ((0x000f ) << (4*4)) );
 80025c6:	f8d3 1400 	ldr.w	r1, [r3, #1024]	; 0x400
 80025ca:	4a21      	ldr	r2, [pc, #132]	; (8002650 <PODgpiopins_Config+0xe4>)
 80025cc:	400a      	ands	r2, r1
 80025ce:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400

	GPIO_CRH(GPIOB) |=      (((GPIO_CNF_OUTPUT_PUSHPULL<<2) | GPIO_MODE_OUTPUT_50_MHZ) << (4*0)) |\
 80025d2:	f8d3 1400 	ldr.w	r1, [r3, #1024]	; 0x400
 80025d6:	4a1f      	ldr	r2, [pc, #124]	; (8002654 <PODgpiopins_Config+0xe8>)
 80025d8:	430a      	orrs	r2, r1
 80025da:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
				(((GPIO_CNF_OUTPUT_PUSHPULL<<2) | GPIO_MODE_OUTPUT_50_MHZ) << (4*2)) |\
				(((GPIO_CNF_OUTPUT_PUSHPULL<<2) | GPIO_MODE_OUTPUT_50_MHZ) << (4*4)) ;
/* ----------------------------- PORTC -------------------------------------- */
	// PC4	Top Cell V ADC divider enable: gpio
	// PC5	Bottom Cell V ADC divider enable: gpio
	GPIO_CRL(GPIOC) &=  ~( ( 0x000f<<(4*4) ) | ( 0x000f<<(4*5) ) );
 80025de:	f8d3 27fc 	ldr.w	r2, [r3, #2044]	; 0x7fc
 80025e2:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 80025e6:	f8c3 27fc 	str.w	r2, [r3, #2044]	; 0x7fc

	GPIO_CRL(GPIOC) |=	(((GPIO_CNF_OUTPUT_PUSHPULL<<2) | GPIO_MODE_OUTPUT_2_MHZ) << (4*4)) |\
 80025ea:	f8d3 27fc 	ldr.w	r2, [r3, #2044]	; 0x7fc
 80025ee:	f442 1208 	orr.w	r2, r2, #2228224	; 0x220000
 80025f2:	f8c3 27fc 	str.w	r2, [r3, #2044]	; 0x7fc
				(((GPIO_CNF_OUTPUT_PUSHPULL<<2) | GPIO_MODE_OUTPUT_2_MHZ) << (4*5)) ;

/* ----------------------------- PORTD -------------------------------------- */
	// PD1	TXCO Vcc switch:gpio out
	// PD7	MAX3232 Vcc switch: gpio out
	GPIO_CRL(GPIOD) &= ~( ( 0x000f<<(4*1) ) | ( 0x000f<<(4*7) ) );
 80025f6:	4a18      	ldr	r2, [pc, #96]	; (8002658 <PODgpiopins_Config+0xec>)
 80025f8:	6813      	ldr	r3, [r2, #0]
 80025fa:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 80025fe:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002602:	6013      	str	r3, [r2, #0]

	GPIO_CRL(GPIOD) |=  	(((GPIO_CNF_OUTPUT_PUSHPULL<<2) | GPIO_MODE_OUTPUT_50_MHZ) << (4*1)) |\
 8002604:	6813      	ldr	r3, [r2, #0]
 8002606:	f043 5340 	orr.w	r3, r3, #805306368	; 0x30000000
 800260a:	f043 0330 	orr.w	r3, r3, #48	; 0x30
 800260e:	6013      	str	r3, [r2, #0]
				(((GPIO_CNF_OUTPUT_PUSHPULL<<2) | GPIO_MODE_OUTPUT_50_MHZ) << (4*7)) ;


	// PD10	5V reg enable--Analog--strain guage & AD7799: gpio_out
	// PD14	5v reg enable--Encoders & GPS : gpio
	GPIO_CRH(GPIOD) &= ~( ((0x000f ) << (4*2)) | ((0x000f ) << (4*6)) );
 8002610:	4b12      	ldr	r3, [pc, #72]	; (800265c <PODgpiopins_Config+0xf0>)
 8002612:	681a      	ldr	r2, [r3, #0]
 8002614:	f022 220f 	bic.w	r2, r2, #251662080	; 0xf000f00
 8002618:	601a      	str	r2, [r3, #0]

	GPIO_CRH(GPIOD) |= 	( ((GPIO_CNF_OUTPUT_PUSHPULL<<2 | GPIO_MODE_OUTPUT_50_MHZ) << (4*2)) |\
 800261a:	681a      	ldr	r2, [r3, #0]
 800261c:	f042 2203 	orr.w	r2, r2, #50332416	; 0x3000300
 8002620:	601a      	str	r2, [r3, #0]
	// PE3	LED43_1: gpio out
	// PE4	LED43_2: gpio out
	// PE5	LED65_1: gpio out
	// PE6	LED65_2: gpio out
	// PE7	3.2 Regulator EN, Analog: gpio
	GPIO_CRL(GPIOE) &=     ~(((0x000f ) << (4*2)) | ((0x000f ) << (4*3)) | ((0x000f ) << (4*4)) |\
 8002622:	4a0f      	ldr	r2, [pc, #60]	; (8002660 <PODgpiopins_Config+0xf4>)
 8002624:	6813      	ldr	r3, [r2, #0]
 8002626:	b2db      	uxtb	r3, r3
 8002628:	6013      	str	r3, [r2, #0]
			   	 ((0x000f ) << (4*5)) | ((0x000f ) << (4*6)) | ((0x000f ) << (4*7)) );


	GPIO_CRL(GPIOE) |=	(((GPIO_CNF_OUTPUT_PUSHPULL<<2) | GPIO_MODE_OUTPUT_50_MHZ) << (4*2)) |\
 800262a:	6813      	ldr	r3, [r2, #0]
 800262c:	f043 2333 	orr.w	r3, r3, #855651072	; 0x33003300
 8002630:	f443 134c 	orr.w	r3, r3, #3342336	; 0x330000
 8002634:	6013      	str	r3, [r2, #0]
				(((GPIO_CNF_OUTPUT_PUSHPULL<<2) | GPIO_MODE_OUTPUT_50_MHZ) << (4*6)) |\
				(((GPIO_CNF_OUTPUT_PUSHPULL<<2) | GPIO_MODE_OUTPUT_50_MHZ) << (4*7)) ;

	
	// PE15	AD7799 Vcc switch: gpio out
	GPIO_CRH(GPIOE) &=  (~((0x000f ) << (4*7)));	// Clear CNF reset bit 01 = Floating input (reset state)
 8002636:	4b0b      	ldr	r3, [pc, #44]	; (8002664 <PODgpiopins_Config+0xf8>)
 8002638:	681a      	ldr	r2, [r3, #0]
 800263a:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 800263e:	601a      	str	r2, [r3, #0]
	GPIO_CRH(GPIOE) |=  (( (GPIO_CNF_OUTPUT_PUSHPULL<<2) | (GPIO_MODE_OUTPUT_50_MHZ) ) << (4*7));	
 8002640:	681a      	ldr	r2, [r3, #0]
 8002642:	f042 5240 	orr.w	r2, r2, #805306368	; 0x30000000
 8002646:	601a      	str	r2, [r3, #0]
 8002648:	4770      	bx	lr
 800264a:	bf00      	nop
 800264c:	40010800 	.word	0x40010800
 8002650:	fff0f000 	.word	0xfff0f000
 8002654:	00030333 	.word	0x00030333
 8002658:	40011400 	.word	0x40011400
 800265c:	40011404 	.word	0x40011404
 8002660:	40011800 	.word	0x40011800
 8002664:	40011804 	.word	0x40011804

08002668 <PODgpiopins_default>:
 ******************************************************************************/
void PODgpiopins_default(void)
{
/* ----------------------------- PORTA -------------------------------------- */
	//  PA4 - AD7799_2 /CS: gpio out
	AD7799_2_CS_hi	// Set bit
 8002668:	4a17      	ldr	r2, [pc, #92]	; (80026c8 <PODgpiopins_default+0x60>)
	//  PA8 - 3.3v SD Card regulator enable: gpio out
	SDCARDREG_off	// Reset bit
 800266a:	4918      	ldr	r1, [pc, #96]	; (80026cc <PODgpiopins_default+0x64>)
/******************************************************************************
 * void PODgpiopins_default(void);
 * @brief	: Set pins to low power (default setting)
 ******************************************************************************/
void PODgpiopins_default(void)
{
 800266c:	b530      	push	{r4, r5, lr}
/* ----------------------------- PORTA -------------------------------------- */
	//  PA4 - AD7799_2 /CS: gpio out
	AD7799_2_CS_hi	// Set bit
 800266e:	2310      	movs	r3, #16
	//  PA8 - 3.3v SD Card regulator enable: gpio out
	SDCARDREG_off	// Reset bit
 8002670:	f44f 7480 	mov.w	r4, #256	; 0x100
/* ----------------------------- PORTB -------------------------------------- */
	// PB5	3.3v regulator enable--XBee : gpio out
	XBEEREG_off	// Reset bit
 8002674:	4816      	ldr	r0, [pc, #88]	; (80026d0 <PODgpiopins_default+0x68>)
	// PB8	XBee /DTR/SLEEP_RQ: gpio_out 
	XBEESLEEPRQ_hi	// Set bit
 8002676:	4d17      	ldr	r5, [pc, #92]	; (80026d4 <PODgpiopins_default+0x6c>)
 ******************************************************************************/
void PODgpiopins_default(void)
{
/* ----------------------------- PORTA -------------------------------------- */
	//  PA4 - AD7799_2 /CS: gpio out
	AD7799_2_CS_hi	// Set bit
 8002678:	6013      	str	r3, [r2, #0]
	//  PA8 - 3.3v SD Card regulator enable: gpio out
	SDCARDREG_off	// Reset bit
 800267a:	800c      	strh	r4, [r1, #0]
/* ----------------------------- PORTB -------------------------------------- */
	// PB5	3.3v regulator enable--XBee : gpio out
	XBEEREG_off	// Reset bit
 800267c:	2120      	movs	r1, #32
 800267e:	8001      	strh	r1, [r0, #0]
	// PB8	XBee /DTR/SLEEP_RQ: gpio_out 
	XBEESLEEPRQ_hi	// Set bit
 8002680:	602c      	str	r4, [r5, #0]
	// PB9	XBee /RESET: gpio_out 
	XBEE_RESET_low	// Reset bit
 8002682:	f44f 7400 	mov.w	r4, #512	; 0x200
 8002686:	8004      	strh	r4, [r0, #0]
	// PB10	AD7799_1 /CS:gpio_out
	AD7799_2_CS_hi	// Set bit
 8002688:	6013      	str	r3, [r2, #0]
/* ----------------------------- PORTC -------------------------------------- */
	// PC4	Top Cell V ADC divider enable: gpio
	TOPCELLADC_off	// Reset bit
 800268a:	f8a2 3804 	strh.w	r3, [r2, #2052]	; 0x804
	// PC5	Bottom Cell V ADC divider enable: gpio
	BOTTMCELLADC_off// Reset bit

/* ----------------------------- PORTD -------------------------------------- */
	// PD1	TXCO Vcc switch:gpio out
	TXCOSW_off	// Set bit
 800268e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
	AD7799_2_CS_hi	// Set bit
/* ----------------------------- PORTC -------------------------------------- */
	// PC4	Top Cell V ADC divider enable: gpio
	TOPCELLADC_off	// Reset bit
	// PC5	Bottom Cell V ADC divider enable: gpio
	BOTTMCELLADC_off// Reset bit
 8002692:	f8a2 1804 	strh.w	r1, [r2, #2052]	; 0x804

/* ----------------------------- PORTD -------------------------------------- */
	// PD1	TXCO Vcc switch:gpio out
	TXCOSW_off	// Set bit
 8002696:	f503 338a 	add.w	r3, r3, #70656	; 0x11400
 800269a:	2202      	movs	r2, #2
 800269c:	601a      	str	r2, [r3, #0]
	// PD7	MAX3232 Vcc switch: gpio out
	MAX3232SW_off	// Set bit
	// PD10	5V regulator enable--Analog--strain guage & AD7799: gpio_out
	STRAINGAUGEPWR_off	// Set bit
 800269e:	f44f 6180 	mov.w	r1, #1024	; 0x400

/* ----------------------------- PORTD -------------------------------------- */
	// PD1	TXCO Vcc switch:gpio out
	TXCOSW_off	// Set bit
	// PD7	MAX3232 Vcc switch: gpio out
	MAX3232SW_off	// Set bit
 80026a2:	2280      	movs	r2, #128	; 0x80
 80026a4:	601a      	str	r2, [r3, #0]
	// PD10	5V regulator enable--Analog--strain guage & AD7799: gpio_out
	STRAINGAUGEPWR_off	// Set bit
 80026a6:	8099      	strh	r1, [r3, #4]
	// PD14	5v regulator enable--Encoders & GPS : gpio
	ENCODERGPSPWR_off	// Reset bit
 80026a8:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 80026ac:	8099      	strh	r1, [r3, #4]

/* ----------------------------- PORTE -------------------------------------- */
	// PE2	EXTERNAL LED FET-PAD3: gpio out
	EXTERNALLED_off	// Reset bit
 80026ae:	2104      	movs	r1, #4
 80026b0:	f8a3 1404 	strh.w	r1, [r3, #1028]	; 0x404
	// PE3	LED43_1: gpio out
	// PE7	3.3 Regulator EN, Analog: gpio
	ANALOGREG_off	// Reset bit
 80026b4:	f8a3 2404 	strh.w	r2, [r3, #1028]	; 0x404
	// PE15	AD7799 Vcc switch: gpio out
	ADC7799VCCSW_off	// Set bit
 80026b8:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 80026bc:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
	// LED 43_1,_2 and LED 65_1, _2 *all* off
	LEDSALL_off
 80026c0:	2278      	movs	r2, #120	; 0x78
 80026c2:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
	EXTERNALLED_off	// Reset bit
	// PE3	LED43_1: gpio out
	// PE7	3.3 Regulator EN, Analog: gpio
	ANALOGREG_off	// Reset bit
	// PE15	AD7799 Vcc switch: gpio out
	ADC7799VCCSW_off	// Set bit
 80026c6:	bd30      	pop	{r4, r5, pc}
 80026c8:	40010810 	.word	0x40010810
 80026cc:	40010814 	.word	0x40010814
 80026d0:	40010c14 	.word	0x40010c14
 80026d4:	40010c10 	.word	0x40010c10

080026d8 <PA0_reconfig>:
 * void PA0_reconfig(char x);
 * @param	: 0 = output; not-zero = floating input
 * @brief	: Reconfigure PA0 
 ******************************************************************************/
void PA0_reconfig(char x)
{
 80026d8:	4b06      	ldr	r3, [pc, #24]	; (80026f4 <PA0_reconfig+0x1c>)
	if (x == 0)
	{ // Here, setup for output
		//  PA0- - POD_box (external) LED: gpio out
		GPIO_CRL(GPIOA) &= ~((0x000f ) << (4*0));	// Clear CNF
 80026da:	681a      	ldr	r2, [r3, #0]
 80026dc:	f022 020f 	bic.w	r2, r2, #15
 80026e0:	601a      	str	r2, [r3, #0]
		GPIO_CRL(GPIOA) |=  (( (GPIO_CNF_OUTPUT_PUSHPULL<<2) | (GPIO_MODE_OUTPUT_50_MHZ) ) << (4*0));		
 80026e2:	681a      	ldr	r2, [r3, #0]
 * @param	: 0 = output; not-zero = floating input
 * @brief	: Reconfigure PA0 
 ******************************************************************************/
void PA0_reconfig(char x)
{
	if (x == 0)
 80026e4:	b910      	cbnz	r0, 80026ec <PA0_reconfig+0x14>
	{ // Here, setup for output
		//  PA0- - POD_box (external) LED: gpio out
		GPIO_CRL(GPIOA) &= ~((0x000f ) << (4*0));	// Clear CNF
		GPIO_CRL(GPIOA) |=  (( (GPIO_CNF_OUTPUT_PUSHPULL<<2) | (GPIO_MODE_OUTPUT_50_MHZ) ) << (4*0));		
 80026e6:	f042 0203 	orr.w	r2, r2, #3
 80026ea:	e001      	b.n	80026f0 <PA0_reconfig+0x18>
	}
	else
	{ // Here, setup for input
		//  PA0- - POD_box (external) pushbutton input
		GPIO_CRL(GPIOA) &= ~((0x000f ) << (4*0));	// Clear CNF
		GPIO_CRL(GPIOA) |=  (( (GPIO_CNF_INPUT_FLOAT<<2) | (GPIO_MODE_INPUT) ) << (4*0));
 80026ec:	f042 0204 	orr.w	r2, r2, #4
 80026f0:	601a      	str	r2, [r3, #0]
 80026f2:	4770      	bx	lr
 80026f4:	40010800 	.word	0x40010800

080026f8 <configure_pin_pod>:
 * @param	: bit in port to set or reset
 **************************************************************************************************************** */
void configure_pin_pod ( volatile u32 * p, int n)
{
		
	if (n >= 8)
 80026f8:	2907      	cmp	r1, #7
	{ // Here, the high byte register (CRH), else low byte register (CRL)
		p = p + 0x01;	// point to high register
 80026fa:	bfc4      	itt	gt
 80026fc:	3004      	addgt	r0, #4
		n -= 8;		// adjust shift count 
 80026fe:	3908      	subgt	r1, #8
	}

	/* Reset CNF bits */
	*p &= ~((0x000f ) << ( 4 * n ));	// Clear CNF reset bit 01 = Floating input (reset state)
 8002700:	6802      	ldr	r2, [r0, #0]
 8002702:	0089      	lsls	r1, r1, #2
 8002704:	230f      	movs	r3, #15
 8002706:	408b      	lsls	r3, r1
 8002708:	ea22 0303 	bic.w	r3, r2, r3
 800270c:	6003      	str	r3, [r0, #0]

	/* Set for pushpull output */
	*p |=  (( (GPIO_CNF_OUTPUT_PUSHPULL<<2) | (GPIO_MODE_OUTPUT_50_MHZ) ) << ( 4 * n ));	
 800270e:	6803      	ldr	r3, [r0, #0]
 8002710:	2203      	movs	r2, #3
 8002712:	fa02 f101 	lsl.w	r1, r2, r1
 8002716:	4319      	orrs	r1, r3
 8002718:	6001      	str	r1, [r0, #0]
 800271a:	4770      	bx	lr

0800271c <configure_pin_in_pd>:
 * @param	: pointer to port base
 * @param	: bit in port to set or reset
 * @pararm	: 0 = pull-down, 1 = pull-up
 **************************************************************************************************************** */
void configure_pin_in_pd ( volatile u32 * p, int n, char pd)
{		
 800271c:	b530      	push	{r4, r5, lr}
	/* Set output bit register (ODR) p 159 */
	// Mask out ODR bit, then or in the new bit (pd) *.
	p += 0X03;	// Point to ODR register
	*p = ( *p & ~(2 << n) ) | ( *p | ((pd & 0x01) << n) );
 800271e:	f002 0201 	and.w	r2, r2, #1
 8002722:	68c5      	ldr	r5, [r0, #12]
 8002724:	2402      	movs	r4, #2
 8002726:	68c3      	ldr	r3, [r0, #12]
 8002728:	408a      	lsls	r2, r1
 800272a:	408c      	lsls	r4, r1
 800272c:	4313      	orrs	r3, r2
 800272e:	ea25 0404 	bic.w	r4, r5, r4
	p -= 0x03;	// Back to original

	if (n >= 8)
 8002732:	2907      	cmp	r1, #7
void configure_pin_in_pd ( volatile u32 * p, int n, char pd)
{		
	/* Set output bit register (ODR) p 159 */
	// Mask out ODR bit, then or in the new bit (pd) *.
	p += 0X03;	// Point to ODR register
	*p = ( *p & ~(2 << n) ) | ( *p | ((pd & 0x01) << n) );
 8002734:	ea43 0304 	orr.w	r3, r3, r4
 8002738:	60c3      	str	r3, [r0, #12]
	p -= 0x03;	// Back to original

	if (n >= 8)
	{ // Here, the high byte register (CRH), ('else' = low byte register (CRL))
		p = p + 0x01;	// point to high register
		n -= 8;		// adjust shift count 
 800273a:	bfc4      	itt	gt
 800273c:	3908      	subgt	r1, #8
	*p = ( *p & ~(2 << n) ) | ( *p | ((pd & 0x01) << n) );
	p -= 0x03;	// Back to original

	if (n >= 8)
	{ // Here, the high byte register (CRH), ('else' = low byte register (CRL))
		p = p + 0x01;	// point to high register
 800273e:	3004      	addgt	r0, #4
		n -= 8;		// adjust shift count 
	}

	/* Reset CNF bits and Mode bits */
	*p &= ~((0x000f ) << ( 4 * n ));	// Clear CNF and mode
 8002740:	6802      	ldr	r2, [r0, #0]
 8002742:	0089      	lsls	r1, r1, #2
 8002744:	230f      	movs	r3, #15
 8002746:	408b      	lsls	r3, r1
 8002748:	ea22 0303 	bic.w	r3, r2, r3
 800274c:	6003      	str	r3, [r0, #0]

	/* Set for input, pull-up/pull-down */
	*p |=  (( (GPIO_CNF_INPUT_PULL_UPDOWN<<2) | (GPIO_MODE_INPUT) ) << ( 4 * n ));	
 800274e:	6803      	ldr	r3, [r0, #0]
 8002750:	2208      	movs	r2, #8
 8002752:	fa02 f101 	lsl.w	r1, r2, r1
 8002756:	4319      	orrs	r1, r3
 8002758:	6001      	str	r1, [r0, #0]
 800275a:	bd30      	pop	{r4, r5, pc}

0800275c <disable_ints>:
 * @param	: p[2] = pointer to save
 ----------------------------------------------------------------------------------------------*/
static void disable_ints(u32 p[])
{
//   __attribute__((__unused__)) int rdbk ; // Readback dummy
	p[0] = CAN_IER(CAN1) & 0x7F;	// Save current IER
 800275c:	4a15      	ldr	r2, [pc, #84]	; (80027b4 <disable_ints+0x58>)
 * static void disable_ints(u32* p[2]);
 * @brief	: disable CAN1 and CAN2 TX, RX0, RX1 interrupts
 * @param	: p[2] = pointer to save
 ----------------------------------------------------------------------------------------------*/
static void disable_ints(u32 p[])
{
 800275e:	b510      	push	{r4, lr}
//   __attribute__((__unused__)) int rdbk ; // Readback dummy
	p[0] = CAN_IER(CAN1) & 0x7F;	// Save current IER
 8002760:	6813      	ldr	r3, [r2, #0]
 8002762:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8002766:	6003      	str	r3, [r0, #0]
	p[1] = CAN_IER(CAN2) & 0x7F;
 8002768:	4b13      	ldr	r3, [pc, #76]	; (80027b8 <disable_ints+0x5c>)
 800276a:	6819      	ldr	r1, [r3, #0]
 800276c:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8002770:	6041      	str	r1, [r0, #4]
	CAN_IER(CAN1) &= ~0x7F;	// Disable TX, RX0, RX1, and errors
 8002772:	6811      	ldr	r1, [r2, #0]
 8002774:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
 8002778:	6011      	str	r1, [r2, #0]
	CAN_IER(CAN2) &= ~0x7F;
 800277a:	6819      	ldr	r1, [r3, #0]
 800277c:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
 8002780:	6019      	str	r1, [r3, #0]
	/* Note: the while assures that the disabling is complete before returning. */
	// The counting is for monitoring if the looping ever takes place
	while((CAN_IER(CAN1) & 0x13) != 0) pctl0->can_errors.disable_ints_ct += 1;
 8002782:	490e      	ldr	r1, [pc, #56]	; (80027bc <disable_ints+0x60>)
 8002784:	680c      	ldr	r4, [r1, #0]
 8002786:	6810      	ldr	r0, [r2, #0]
 8002788:	f010 0f13 	tst.w	r0, #19
 800278c:	d005      	beq.n	800279a <disable_ints+0x3e>
 800278e:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 8002792:	3001      	adds	r0, #1
 8002794:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
 8002798:	e7f5      	b.n	8002786 <disable_ints+0x2a>
	while((CAN_IER(CAN2) & 0x13) != 0) pctl1->can_errors.disable_ints_ct += 1;
 800279a:	6849      	ldr	r1, [r1, #4]
 800279c:	681a      	ldr	r2, [r3, #0]
 800279e:	f012 0f13 	tst.w	r2, #19
 80027a2:	d005      	beq.n	80027b0 <disable_ints+0x54>
 80027a4:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
 80027a8:	3201      	adds	r2, #1
 80027aa:	f8c1 208c 	str.w	r2, [r1, #140]	; 0x8c
 80027ae:	e7f5      	b.n	800279c <disable_ints+0x40>
	return;
}
 80027b0:	bd10      	pop	{r4, pc}
 80027b2:	bf00      	nop
 80027b4:	40006414 	.word	0x40006414
 80027b8:	40006814 	.word	0x40006814
 80027bc:	20001900 	.word	0x20001900

080027c0 <reenable_ints>:
 * @param	: p1 = pointer to CAN1 IER before disable
 * @param	: p2 = pointer to CAN2 IER before disable
 ----------------------------------------------------------------------------------------------*/
static void reenable_ints(u32 p[])
{
	CAN_IER(CAN1) |= p[0];
 80027c0:	4a05      	ldr	r2, [pc, #20]	; (80027d8 <reenable_ints+0x18>)
 80027c2:	6803      	ldr	r3, [r0, #0]
 80027c4:	6811      	ldr	r1, [r2, #0]
 80027c6:	430b      	orrs	r3, r1
 80027c8:	6013      	str	r3, [r2, #0]
	CAN_IER(CAN2) |= p[1];
 80027ca:	f8d2 1400 	ldr.w	r1, [r2, #1024]	; 0x400
 80027ce:	6843      	ldr	r3, [r0, #4]
 80027d0:	430b      	orrs	r3, r1
 80027d2:	f8c2 3400 	str.w	r3, [r2, #1024]	; 0x400
 80027d6:	4770      	bx	lr
 80027d8:	40006414 	.word	0x40006414

080027dc <can_driver_toss>:
 * @return	: struct with pointer to can msg struct, ptr = zero if no new data
 ******************************************************************************/
u32 debugB = 0;
u32 debugC = 0;
static void can_driver_toss(volatile struct CAN_RCV_PTRS* ptrs)
{
 80027dc:	b513      	push	{r0, r1, r4, lr}
 80027de:	4604      	mov	r4, r0
	volatile struct CAN_POOLBLOCK* pmov; // 'volatile' to match plinknext

	u32 save[2];
	disable_ints(save);
 80027e0:	4668      	mov	r0, sp
 80027e2:	f7ff ffbb 	bl	800275c <disable_ints>
	// Remove block from received list
	ptrs->bct -= 1;		// Decrement RX pending list
 80027e6:	68a3      	ldr	r3, [r4, #8]
 80027e8:	3b01      	subs	r3, #1
 80027ea:	60a3      	str	r3, [r4, #8]
	friict += 1;		// Increment free list inventory
 80027ec:	4b0e      	ldr	r3, [pc, #56]	; (8002828 <can_driver_toss+0x4c>)
 80027ee:	689a      	ldr	r2, [r3, #8]
 80027f0:	3201      	adds	r2, #1
 80027f2:	609a      	str	r2, [r3, #8]
	pmov = ptrs->ptail->plinknext;	// pmov pts to head
 80027f4:	6822      	ldr	r2, [r4, #0]
 80027f6:	6812      	ldr	r2, [r2, #0]
	if (pmov == pmov->plinknext)
 80027f8:	6811      	ldr	r1, [r2, #0]
 80027fa:	428a      	cmp	r2, r1
 80027fc:	d105      	bne.n	800280a <can_driver_toss+0x2e>
	{ // Removing last block for list
		ptrs->ptail = NULL;
 80027fe:	2100      	movs	r1, #0
 8002800:	6021      	str	r1, [r4, #0]
debugB += 1;
 8002802:	68d9      	ldr	r1, [r3, #12]
 8002804:	3101      	adds	r1, #1
 8002806:	60d9      	str	r1, [r3, #12]
 8002808:	e005      	b.n	8002816 <can_driver_toss+0x3a>
	}
	else
	{ // More than one block on the list
		ptrs->ptail->plinknext = pmov->plinknext; // Set new head ptr
 800280a:	6821      	ldr	r1, [r4, #0]
 800280c:	6810      	ldr	r0, [r2, #0]
 800280e:	6008      	str	r0, [r1, #0]
debugC += 1;
 8002810:	6919      	ldr	r1, [r3, #16]
 8002812:	3101      	adds	r1, #1
 8002814:	6119      	str	r1, [r3, #16]
	}
	pmov->plinknext = frii.plinknext;
 8002816:	6999      	ldr	r1, [r3, #24]
	frii.plinknext  = pmov;
	reenable_ints(save);
 8002818:	4668      	mov	r0, sp
	else
	{ // More than one block on the list
		ptrs->ptail->plinknext = pmov->plinknext; // Set new head ptr
debugC += 1;
	}
	pmov->plinknext = frii.plinknext;
 800281a:	6011      	str	r1, [r2, #0]
	frii.plinknext  = pmov;
 800281c:	619a      	str	r2, [r3, #24]
	reenable_ints(save);
 800281e:	f7ff ffcf 	bl	80027c0 <reenable_ints>
	return;
}
 8002822:	b002      	add	sp, #8
 8002824:	bd10      	pop	{r4, pc}
 8002826:	bf00      	nop
 8002828:	20001900 	.word	0x20001900

0800282c <loadmbx2>:
 ----------------------------------------------------------------------------------------------*/
static void loadmbx2(struct CAN_CTLBLOCK* pctl, u16 dbug)
{
	volatile struct CAN_POOLBLOCK* p = pctl->pend.plinknext;

if (pctl == pctl1)
 800282c:	4b40      	ldr	r3, [pc, #256]	; (8002930 <loadmbx2+0x104>)
/*---------------------------------------------------------------------------------------------
 * static void loadmbx2(struct CAN_CTLBLOCK* pctl)
 * @brief	: Load mailbox
 ----------------------------------------------------------------------------------------------*/
static void loadmbx2(struct CAN_CTLBLOCK* pctl, u16 dbug)
{
 800282e:	b5f0      	push	{r4, r5, r6, r7, lr}
	volatile struct CAN_POOLBLOCK* p = pctl->pend.plinknext;

if (pctl == pctl1)
 8002830:	685f      	ldr	r7, [r3, #4]
 * static void loadmbx2(struct CAN_CTLBLOCK* pctl)
 * @brief	: Load mailbox
 ----------------------------------------------------------------------------------------------*/
static void loadmbx2(struct CAN_CTLBLOCK* pctl, u16 dbug)
{
	volatile struct CAN_POOLBLOCK* p = pctl->pend.plinknext;
 8002832:	6885      	ldr	r5, [r0, #8]

if (pctl == pctl1)
 8002834:	42b8      	cmp	r0, r7
 8002836:	461e      	mov	r6, r3
 8002838:	d163      	bne.n	8002902 <loadmbx2+0xd6>
{
dbugx[dbugxidx].idb4  = CAN_TIxR (pctl->vcan, CAN_MBOX0);
 800283a:	f8d0 e000 	ldr.w	lr, [r0]
 800283e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002840:	f8de c180 	ldr.w	ip, [lr, #384]	; 0x180
 8002844:	eb03 1442 	add.w	r4, r3, r2, lsl #5
 8002848:	f8c4 c03c 	str.w	ip, [r4, #60]	; 0x3c
dbugx[dbugxidx].aflag = pctl->abortflag;
 800284c:	f8b0 c04c 	ldrh.w	ip, [r0, #76]	; 0x4c
dbugx[dbugxidx].mbx2  = dbug;
 8002850:	64e1      	str	r1, [r4, #76]	; 0x4c
dbugx[dbugxidx].ct    = pctl->txbct;
 8002852:	f8d0 1090 	ldr.w	r1, [r0, #144]	; 0x90
	volatile struct CAN_POOLBLOCK* p = pctl->pend.plinknext;

if (pctl == pctl1)
{
dbugx[dbugxidx].idb4  = CAN_TIxR (pctl->vcan, CAN_MBOX0);
dbugx[dbugxidx].aflag = pctl->abortflag;
 8002856:	f8a4 c044 	strh.w	ip, [r4, #68]	; 0x44
dbugx[dbugxidx].mbx2  = dbug;
dbugx[dbugxidx].ct    = pctl->txbct;
 800285a:	6521      	str	r1, [r4, #80]	; 0x50
dbugx[dbugxidx].ct1   = dbugabort[6]; // Number of aborts handled
 800285c:	f8d3 1854 	ldr.w	r1, [r3, #2132]	; 0x854
 8002860:	64a1      	str	r1, [r4, #72]	; 0x48
dbugx[dbugxidx].bit   = CAN_TSR(pctl->vcan);
 8002862:	f8de 1008 	ldr.w	r1, [lr, #8]
 8002866:	65a1      	str	r1, [r4, #88]	; 0x58
dbugx[dbugxidx].arbq  = arbqctr;
 8002868:	f8d3 18bc 	ldr.w	r1, [r3, #2236]	; 0x8bc
 800286c:	6561      	str	r1, [r4, #84]	; 0x54
}
	if (p == NULL)
 800286e:	2d00      	cmp	r5, #0
 8002870:	d04b      	beq.n	800290a <loadmbx2+0xde>
}
		return; // Return if no more to send
	}
	pctl->pxprv = &pctl->pend;	// Save

dbugabort[19] += 1;
 8002872:	f8d6 2888 	ldr.w	r2, [r6, #2184]	; 0x888
dbugx[dbugxidx].idb4 = ~0x1;
dbugx[dbugxidx].idaf = ~0x3;
}
		return; // Return if no more to send
	}
	pctl->pxprv = &pctl->pend;	// Save
 8002876:	f100 0308 	add.w	r3, r0, #8

dbugabort[19] += 1;
 800287a:	3201      	adds	r2, #1
dbugx[dbugxidx].idb4 = ~0x1;
dbugx[dbugxidx].idaf = ~0x3;
}
		return; // Return if no more to send
	}
	pctl->pxprv = &pctl->pend;	// Save
 800287c:	6283      	str	r3, [r0, #40]	; 0x28

dbugabort[19] += 1;
 800287e:	f8c6 2888 	str.w	r2, [r6, #2184]	; 0x888

	/* Load the mailbox with the message.  CAN ID low bit starts xmission. */
	CAN_TDTxR(pctl->vcan, CAN_MBOX0) =  p->can.dlc;	 	// CAN_TDT0R:  mailbox 0 time & length p 660
 8002882:	68e9      	ldr	r1, [r5, #12]
 8002884:	6802      	ldr	r2, [r0, #0]
	CAN_TDLxR(pctl->vcan, CAN_MBOX0) =  p->can.cd.ui[0];	// CAN_TDL0RL: mailbox 0 data low  register p 661 
	CAN_TDHxR(pctl->vcan, CAN_MBOX0) =  p->can.cd.ui[1];	// CAN_TDL0RH: mailbox 0 data low  register p 661 
	/* Load CAN ID and set TX Request bit */
if (pctl== pctl1)
 8002886:	42b8      	cmp	r0, r7
	pctl->pxprv = &pctl->pend;	// Save

dbugabort[19] += 1;

	/* Load the mailbox with the message.  CAN ID low bit starts xmission. */
	CAN_TDTxR(pctl->vcan, CAN_MBOX0) =  p->can.dlc;	 	// CAN_TDT0R:  mailbox 0 time & length p 660
 8002888:	f8c2 1184 	str.w	r1, [r2, #388]	; 0x184
	CAN_TDLxR(pctl->vcan, CAN_MBOX0) =  p->can.cd.ui[0];	// CAN_TDL0RL: mailbox 0 data low  register p 661 
 800288c:	6802      	ldr	r2, [r0, #0]
 800288e:	6929      	ldr	r1, [r5, #16]
}
		return; // Return if no more to send
	}
	pctl->pxprv = &pctl->pend;	// Save

dbugabort[19] += 1;
 8002890:	4b27      	ldr	r3, [pc, #156]	; (8002930 <loadmbx2+0x104>)

	/* Load the mailbox with the message.  CAN ID low bit starts xmission. */
	CAN_TDTxR(pctl->vcan, CAN_MBOX0) =  p->can.dlc;	 	// CAN_TDT0R:  mailbox 0 time & length p 660
	CAN_TDLxR(pctl->vcan, CAN_MBOX0) =  p->can.cd.ui[0];	// CAN_TDL0RL: mailbox 0 data low  register p 661 
 8002892:	f8c2 1188 	str.w	r1, [r2, #392]	; 0x188
	CAN_TDHxR(pctl->vcan, CAN_MBOX0) =  p->can.cd.ui[1];	// CAN_TDL0RH: mailbox 0 data low  register p 661 
 8002896:	6969      	ldr	r1, [r5, #20]
 8002898:	6802      	ldr	r2, [r0, #0]
 800289a:	f8c2 118c 	str.w	r1, [r2, #396]	; 0x18c
 800289e:	6801      	ldr	r1, [r0, #0]
	/* Load CAN ID and set TX Request bit */
if (pctl== pctl1)
 80028a0:	d10b      	bne.n	80028ba <loadmbx2+0x8e>
{
dbugx[dbugxidx].aflag &= 0x80;
 80028a2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
dbugx[dbugxidx].aflag |= (CAN_TSR (pctl->vcan) & CAN_TSR_TME0) >> (26-7);
 80028a4:	688c      	ldr	r4, [r1, #8]
 80028a6:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 80028aa:	f8b3 2044 	ldrh.w	r2, [r3, #68]	; 0x44
 80028ae:	ea42 42d4 	orr.w	r2, r2, r4, lsr #19
 80028b2:	f002 0280 	and.w	r2, r2, #128	; 0x80
 80028b6:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
}
	CAN_TIxR (pctl->vcan, CAN_MBOX0) =  (p->can.id | 0x1); 	// CAN_TI0R:   mailbox 0 identifier register p 659
 80028ba:	68ab      	ldr	r3, [r5, #8]

if (pctl== pctl1)
 80028bc:	42b8      	cmp	r0, r7
if (pctl== pctl1)
{
dbugx[dbugxidx].aflag &= 0x80;
dbugx[dbugxidx].aflag |= (CAN_TSR (pctl->vcan) & CAN_TSR_TME0) >> (26-7);
}
	CAN_TIxR (pctl->vcan, CAN_MBOX0) =  (p->can.id | 0x1); 	// CAN_TI0R:   mailbox 0 identifier register p 659
 80028be:	f043 0301 	orr.w	r3, r3, #1
 80028c2:	f8c1 3180 	str.w	r3, [r1, #384]	; 0x180

if (pctl== pctl1)
 80028c6:	d131      	bne.n	800292c <loadmbx2+0x100>
{
updn  += 1;
 80028c8:	f8b6 38c0 	ldrh.w	r3, [r6, #2240]	; 0x8c0
dbugx[dbugxidx].updn = updn;
 80028cc:	6bb2      	ldr	r2, [r6, #56]	; 0x38
}
	CAN_TIxR (pctl->vcan, CAN_MBOX0) =  (p->can.id | 0x1); 	// CAN_TI0R:   mailbox 0 identifier register p 659

if (pctl== pctl1)
{
updn  += 1;
 80028ce:	3301      	adds	r3, #1
 80028d0:	b21b      	sxth	r3, r3
dbugx[dbugxidx].updn = updn;
 80028d2:	eb06 1442 	add.w	r4, r6, r2, lsl #5
}
	CAN_TIxR (pctl->vcan, CAN_MBOX0) =  (p->can.id | 0x1); 	// CAN_TI0R:   mailbox 0 identifier register p 659

if (pctl== pctl1)
{
updn  += 1;
 80028d6:	f8a6 38c0 	strh.w	r3, [r6, #2240]	; 0x8c0
dbugx[dbugxidx].updn = updn;
 80028da:	f8a4 3046 	strh.w	r3, [r4, #70]	; 0x46
dbugx[dbugxidx].idaf = CAN_TIxR (pctl->vcan, CAN_MBOX0);
 80028de:	6803      	ldr	r3, [r0, #0]
}
	CAN_TIxR (pctl->vcan, CAN_MBOX0) =  (p->can.id | 0x1); 	// CAN_TI0R:   mailbox 0 identifier register p 659

if (pctl== pctl1)
{
updn  += 1;
 80028e0:	4913      	ldr	r1, [pc, #76]	; (8002930 <loadmbx2+0x104>)
dbugx[dbugxidx].updn = updn;
dbugx[dbugxidx].idaf = CAN_TIxR (pctl->vcan, CAN_MBOX0);
 80028e2:	f8d3 3180 	ldr.w	r3, [r3, #384]	; 0x180
 80028e6:	6423      	str	r3, [r4, #64]	; 0x40
dbugxidx += 1;
 80028e8:	1c53      	adds	r3, r2, #1
if (dbugxidx >= DBUGXSZ) dbugxidx = 0;
 80028ea:	2b3f      	cmp	r3, #63	; 0x3f
 80028ec:	bf88      	it	hi
 80028ee:	2300      	movhi	r3, #0
 80028f0:	638b      	str	r3, [r1, #56]	; 0x38
dbugx[dbugxidx].idb4 = ~0x1;
 80028f2:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 80028f4:	eb06 1643 	add.w	r6, r6, r3, lsl #5
 80028f8:	f06f 0301 	mvn.w	r3, #1
 80028fc:	63f3      	str	r3, [r6, #60]	; 0x3c
dbugx[dbugxidx].idaf = ~0x1;
 80028fe:	6433      	str	r3, [r6, #64]	; 0x40
 8002900:	bdf0      	pop	{r4, r5, r6, r7, pc}
dbugx[dbugxidx].ct    = pctl->txbct;
dbugx[dbugxidx].ct1   = dbugabort[6]; // Number of aborts handled
dbugx[dbugxidx].bit   = CAN_TSR(pctl->vcan);
dbugx[dbugxidx].arbq  = arbqctr;
}
	if (p == NULL)
 8002902:	2d00      	cmp	r5, #0
 8002904:	d1b5      	bne.n	8002872 <loadmbx2+0x46>
	{
		pctl->pxprv = NULL;
 8002906:	6285      	str	r5, [r0, #40]	; 0x28
 8002908:	bdf0      	pop	{r4, r5, r6, r7, pc}

if (pctl == pctl1)
{
dbugx[dbugxidx].idaf = 0xaaaaaaaa;
dbugxidx += 1; if (dbugxidx >= DBUGXSZ) dbugxidx = 0;
 800290a:	3201      	adds	r2, #1
 800290c:	2a3f      	cmp	r2, #63	; 0x3f
 800290e:	bf88      	it	hi
 8002910:	2200      	movhi	r2, #0
 8002912:	639a      	str	r2, [r3, #56]	; 0x38
dbugx[dbugxidx].idb4 = ~0x1;
 8002914:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 8002918:	f06f 0201 	mvn.w	r2, #1
dbugx[dbugxidx].bit   = CAN_TSR(pctl->vcan);
dbugx[dbugxidx].arbq  = arbqctr;
}
	if (p == NULL)
	{
		pctl->pxprv = NULL;
 800291c:	6285      	str	r5, [r0, #40]	; 0x28

if (pctl == pctl1)
{
dbugx[dbugxidx].idaf = 0xaaaaaaaa;
 800291e:	f04f 31aa 	mov.w	r1, #2863311530	; 0xaaaaaaaa
dbugxidx += 1; if (dbugxidx >= DBUGXSZ) dbugxidx = 0;
dbugx[dbugxidx].idb4 = ~0x1;
 8002922:	63da      	str	r2, [r3, #60]	; 0x3c
dbugx[dbugxidx].idaf = ~0x3;
 8002924:	f06f 0203 	mvn.w	r2, #3
	{
		pctl->pxprv = NULL;

if (pctl == pctl1)
{
dbugx[dbugxidx].idaf = 0xaaaaaaaa;
 8002928:	6421      	str	r1, [r4, #64]	; 0x40
dbugxidx += 1; if (dbugxidx >= DBUGXSZ) dbugxidx = 0;
dbugx[dbugxidx].idb4 = ~0x1;
dbugx[dbugxidx].idaf = ~0x3;
 800292a:	641a      	str	r2, [r3, #64]	; 0x40
 800292c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800292e:	bf00      	nop
 8002930:	20001900 	.word	0x20001900

08002934 <moveremove2>:
/* --------------------------------------------------------------------------------------
* static void moveremove2(struct CAN_CTLBLOCK* pctl);
* @brief	: Remove msg from pending list and add to free list
  --------------------------------------------------------------------------------------- */
static void moveremove2(struct CAN_CTLBLOCK* pctl)
{
 8002934:	b513      	push	{r0, r1, r4, lr}
 8002936:	4604      	mov	r4, r0
	volatile struct CAN_POOLBLOCK* pmov;
	u32 save[2];

	disable_ints(save);	// TX or RX(other) interrupts might remove a msg from the free list.
 8002938:	4668      	mov	r0, sp
 800293a:	f7ff ff0f 	bl	800275c <disable_ints>
//?	{ // Here, yes. 'pfor' points to the msg removed in the following statements.
//?		pctl->pfor = pctl->pxprv; // Move 'pfor' back "up" one msg in linked list
//?		pctl->can_errors.can_pfor_bk_one += 1; // Keep track of instances
//?	}
	// Remove from pending list
	pmov = pctl->pxprv->plinknext;	// Pts to removed item
 800293e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	// Adding to free list
	pmov->plinknext = frii.plinknext; 
	frii.plinknext  = pmov;
	pctl->txbct -= 1;	// Decrement running ct of pending list msgs
	friict += 1;		// Increment running ct of free list inventory
	reenable_ints(save);
 8002940:	4668      	mov	r0, sp
//?	{ // Here, yes. 'pfor' points to the msg removed in the following statements.
//?		pctl->pfor = pctl->pxprv; // Move 'pfor' back "up" one msg in linked list
//?		pctl->can_errors.can_pfor_bk_one += 1; // Keep track of instances
//?	}
	// Remove from pending list
	pmov = pctl->pxprv->plinknext;	// Pts to removed item
 8002942:	681a      	ldr	r2, [r3, #0]
	pctl->pxprv->plinknext = pmov->plinknext;
 8002944:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002946:	6811      	ldr	r1, [r2, #0]
 8002948:	6019      	str	r1, [r3, #0]

	// Adding to free list
	pmov->plinknext = frii.plinknext; 
 800294a:	4b08      	ldr	r3, [pc, #32]	; (800296c <moveremove2+0x38>)
 800294c:	6999      	ldr	r1, [r3, #24]
 800294e:	6011      	str	r1, [r2, #0]
	frii.plinknext  = pmov;
 8002950:	619a      	str	r2, [r3, #24]
	pctl->txbct -= 1;	// Decrement running ct of pending list msgs
 8002952:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 8002956:	3a01      	subs	r2, #1
 8002958:	f8c4 2090 	str.w	r2, [r4, #144]	; 0x90
	friict += 1;		// Increment running ct of free list inventory
 800295c:	689a      	ldr	r2, [r3, #8]
 800295e:	3201      	adds	r2, #1
 8002960:	609a      	str	r2, [r3, #8]
	reenable_ints(save);
 8002962:	f7ff ff2d 	bl	80027c0 <reenable_ints>
	return;
}
 8002966:	b002      	add	sp, #8
 8002968:	bd10      	pop	{r4, pc}
 800296a:	bf00      	nop
 800296c:	20001900 	.word	0x20001900

08002970 <can_driver_init>:
 *		: -13 port pin setup CAN2
*******************************************************************************/
struct CANWINCHPODCOMMONERRORS* pcan_errors; // Debug: pointer to CAN errors struct

struct CAN_CTLBLOCK* can_driver_init(struct CAN_PARAMS2 *p, const struct CAN_INIT* pinit)
{
 8002970:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	struct CAN_POOLBLOCK* plst;
	struct CAN_POOLBLOCK* ptmp;

	/* Get base address of CAN module. */
	// We depend on F4, F103, and F373 being the same (which they are, so far)
	if ((p->cannum != 1) && (p->cannum != 2)) return NULL;
 8002974:	7906      	ldrb	r6, [r0, #4]
 *		: -13 port pin setup CAN2
*******************************************************************************/
struct CANWINCHPODCOMMONERRORS* pcan_errors; // Debug: pointer to CAN errors struct

struct CAN_CTLBLOCK* can_driver_init(struct CAN_PARAMS2 *p, const struct CAN_INIT* pinit)
{
 8002976:	4605      	mov	r5, r0
	struct CAN_POOLBLOCK* plst;
	struct CAN_POOLBLOCK* ptmp;

	/* Get base address of CAN module. */
	// We depend on F4, F103, and F373 being the same (which they are, so far)
	if ((p->cannum != 1) && (p->cannum != 2)) return NULL;
 8002978:	1e73      	subs	r3, r6, #1
 800297a:	2b01      	cmp	r3, #1
 *		: -13 port pin setup CAN2
*******************************************************************************/
struct CANWINCHPODCOMMONERRORS* pcan_errors; // Debug: pointer to CAN errors struct

struct CAN_CTLBLOCK* can_driver_init(struct CAN_PARAMS2 *p, const struct CAN_INIT* pinit)
{
 800297c:	468a      	mov	sl, r1
	struct CAN_POOLBLOCK* plst;
	struct CAN_POOLBLOCK* ptmp;

	/* Get base address of CAN module. */
	// We depend on F4, F103, and F373 being the same (which they are, so far)
	if ((p->cannum != 1) && (p->cannum != 2)) return NULL;
 800297e:	d902      	bls.n	8002986 <can_driver_init+0x16>
 8002980:	2000      	movs	r0, #0
 8002982:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

	/* Get control block for this CAN module. */
	pctl = (struct CAN_CTLBLOCK*)calloc(1, sizeof(struct CAN_CTLBLOCK));
 8002986:	21a0      	movs	r1, #160	; 0xa0
 8002988:	2001      	movs	r0, #1
 800298a:	f000 fe4d 	bl	8003628 <calloc>
	if (pctl == NULL) return NULL;
 800298e:	4604      	mov	r4, r0
 8002990:	2800      	cmp	r0, #0
 8002992:	d0f5      	beq.n	8002980 <can_driver_init+0x10>
	if (p->cannum == 1) {pctl0 = pctl; pctl->vcan = CAN1;}
 8002994:	2e01      	cmp	r6, #1
 8002996:	4e9a      	ldr	r6, [pc, #616]	; (8002c00 <can_driver_init+0x290>)
 8002998:	f040 812f 	bne.w	8002bfa <can_driver_init+0x28a>
 800299c:	4b99      	ldr	r3, [pc, #612]	; (8002c04 <can_driver_init+0x294>)
 800299e:	6030      	str	r0, [r6, #0]

	/* One time only--get pool of msg blocks for "everybody." */
	// Note: if the first caller doesn't setup of the buffers, maybe the 2nd one will
	// in which case the buffers get setup then.  If neither sets them up the the
	// enable interrupts call will return -1 and not enable interrupts.
	if ((buffct == 0)  && (pinit->numbuff != 0)) // Have we calloc'ed the buffer space?
 80029a0:	f8d6 78c4 	ldr.w	r7, [r6, #2244]	; 0x8c4
	if ((p->cannum != 1) && (p->cannum != 2)) return NULL;

	/* Get control block for this CAN module. */
	pctl = (struct CAN_CTLBLOCK*)calloc(1, sizeof(struct CAN_CTLBLOCK));
	if (pctl == NULL) return NULL;
	if (p->cannum == 1) {pctl0 = pctl; pctl->vcan = CAN1;}
 80029a4:	6023      	str	r3, [r4, #0]

	/* One time only--get pool of msg blocks for "everybody." */
	// Note: if the first caller doesn't setup of the buffers, maybe the 2nd one will
	// in which case the buffers get setup then.  If neither sets them up the the
	// enable interrupts call will return -1 and not enable interrupts.
	if ((buffct == 0)  && (pinit->numbuff != 0)) // Have we calloc'ed the buffer space?
 80029a6:	f8df 8258 	ldr.w	r8, [pc, #600]	; 8002c00 <can_driver_init+0x290>
 80029aa:	b1bf      	cbz	r7, 80029dc <can_driver_init+0x6c>
			plst = ptmp++;
		} 
	}

	/* Save msg count limits for this CAN. */
	pctl->txbct     = 0;	// Zero'd by calloc
 80029ac:	2300      	movs	r3, #0
 80029ae:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
	pctl->ptrs0.bct = 0;	// Zero'd by calloc
 80029b2:	6363      	str	r3, [r4, #52]	; 0x34
	pctl->ptrs1.bct = 0;	// Zero'd by calloc
 80029b4:	6463      	str	r3, [r4, #68]	; 0x44
	pctl->txbmx     = pinit->txmax;		// Max blocks this TX can commandeer
 80029b6:	f8da 3004 	ldr.w	r3, [sl, #4]
	// calloc set these to zero so we comment them out
//	pctl->ptrs0.ptail = NULL; // RX0
//	pctl->ptrs1.ptail = NULL; // RX1

	/* Setup CAN port pins and enable module clocking. */
	ret = can_driver_port(p->port, p->cannum);
 80029ba:	7929      	ldrb	r1, [r5, #4]

	/* Save msg count limits for this CAN. */
	pctl->txbct     = 0;	// Zero'd by calloc
	pctl->ptrs0.bct = 0;	// Zero'd by calloc
	pctl->ptrs1.bct = 0;	// Zero'd by calloc
	pctl->txbmx     = pinit->txmax;		// Max blocks this TX can commandeer
 80029bc:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
	pctl->ptrs0.bmx = pinit->rx0max;	// Max blocks this RX0 can commandeer
 80029c0:	f8da 3008 	ldr.w	r3, [sl, #8]
	// calloc set these to zero so we comment them out
//	pctl->ptrs0.ptail = NULL; // RX0
//	pctl->ptrs1.ptail = NULL; // RX1

	/* Setup CAN port pins and enable module clocking. */
	ret = can_driver_port(p->port, p->cannum);
 80029c4:	7968      	ldrb	r0, [r5, #5]
	/* Save msg count limits for this CAN. */
	pctl->txbct     = 0;	// Zero'd by calloc
	pctl->ptrs0.bct = 0;	// Zero'd by calloc
	pctl->ptrs1.bct = 0;	// Zero'd by calloc
	pctl->txbmx     = pinit->txmax;		// Max blocks this TX can commandeer
	pctl->ptrs0.bmx = pinit->rx0max;	// Max blocks this RX0 can commandeer
 80029c6:	63a3      	str	r3, [r4, #56]	; 0x38
	pctl->ptrs1.bmx = pinit->rx1max;	// Max blocks this RX1 can commandeer
 80029c8:	f8da 300c 	ldr.w	r3, [sl, #12]
 80029cc:	64a3      	str	r3, [r4, #72]	; 0x48
	// calloc set these to zero so we comment them out
//	pctl->ptrs0.ptail = NULL; // RX0
//	pctl->ptrs1.ptail = NULL; // RX1

	/* Setup CAN port pins and enable module clocking. */
	ret = can_driver_port(p->port, p->cannum);
 80029ce:	f000 fbbf 	bl	8003150 <can_driver_port>
	if (ret != 0) {pctl->ret = ret - 10; return pctl;} // failed
 80029d2:	b300      	cbz	r0, 8002a16 <can_driver_init+0xa6>
 80029d4:	380a      	subs	r0, #10
 80029d6:	f884 009c 	strb.w	r0, [r4, #156]	; 0x9c
 80029da:	e10b      	b.n	8002bf4 <can_driver_init+0x284>

	/* One time only--get pool of msg blocks for "everybody." */
	// Note: if the first caller doesn't setup of the buffers, maybe the 2nd one will
	// in which case the buffers get setup then.  If neither sets them up the the
	// enable interrupts call will return -1 and not enable interrupts.
	if ((buffct == 0)  && (pinit->numbuff != 0)) // Have we calloc'ed the buffer space?
 80029dc:	f8da 9000 	ldr.w	r9, [sl]
 80029e0:	f1b9 0f00 	cmp.w	r9, #0
 80029e4:	d0e2      	beq.n	80029ac <can_driver_init+0x3c>
	{ // Here, no.
		buffct = pinit->numbuff;// Serves as a OTO switch and saves total blk count
		friict = buffct;	// Initial running count of free list msg  block inventory

		/* Get CAN xmit linked list and init 'plinknext'. */	
		ptmp = (struct CAN_POOLBLOCK*)calloc(pinit->numbuff, sizeof(struct CAN_POOLBLOCK));
 80029e6:	2120      	movs	r1, #32
 80029e8:	4648      	mov	r0, r9
	// Note: if the first caller doesn't setup of the buffers, maybe the 2nd one will
	// in which case the buffers get setup then.  If neither sets them up the the
	// enable interrupts call will return -1 and not enable interrupts.
	if ((buffct == 0)  && (pinit->numbuff != 0)) // Have we calloc'ed the buffer space?
	{ // Here, no.
		buffct = pinit->numbuff;// Serves as a OTO switch and saves total blk count
 80029ea:	f8c8 98c4 	str.w	r9, [r8, #2244]	; 0x8c4
		friict = buffct;	// Initial running count of free list msg  block inventory
 80029ee:	f8c8 9008 	str.w	r9, [r8, #8]

		/* Get CAN xmit linked list and init 'plinknext'. */	
		ptmp = (struct CAN_POOLBLOCK*)calloc(pinit->numbuff, sizeof(struct CAN_POOLBLOCK));
 80029f2:	f000 fe19 	bl	8003628 <calloc>
		if ( ptmp == NULL){pctl->ret = -2; return pctl;} // Get buff failed
 80029f6:	b908      	cbnz	r0, 80029fc <can_driver_init+0x8c>
 80029f8:	23fe      	movs	r3, #254	; 0xfe
 80029fa:	e098      	b.n	8002b2e <can_driver_init+0x1be>
 80029fc:	463b      	mov	r3, r7
 80029fe:	f108 0818 	add.w	r8, r8, #24

		/* Initialize links in the free list. */
		plst = &frii;
		for (can_timeout = 0; can_timeout < pinit->numbuff; can_timeout++)
 8002a02:	3301      	adds	r3, #1
 8002a04:	4599      	cmp	r9, r3
		{
			plst->plinknext = ptmp;
 8002a06:	f8c8 0000 	str.w	r0, [r8]
			plst = ptmp++;
 8002a0a:	f100 0220 	add.w	r2, r0, #32
 8002a0e:	4680      	mov	r8, r0
		ptmp = (struct CAN_POOLBLOCK*)calloc(pinit->numbuff, sizeof(struct CAN_POOLBLOCK));
		if ( ptmp == NULL){pctl->ret = -2; return pctl;} // Get buff failed

		/* Initialize links in the free list. */
		plst = &frii;
		for (can_timeout = 0; can_timeout < pinit->numbuff; can_timeout++)
 8002a10:	d0cc      	beq.n	80029ac <can_driver_init+0x3c>
		{
			plst->plinknext = ptmp;
			plst = ptmp++;
 8002a12:	4610      	mov	r0, r2
 8002a14:	e7f5      	b.n	8002a02 <can_driver_init+0x92>
	ret = can_driver_port(p->port, p->cannum);
	if (ret != 0) {pctl->ret = ret - 10; return pctl;} // failed

	/* ---------- Put CAN module into Initialization mode -------------------- */
	/* Request initialization p 632, 648.  DEBUG freeze bit on */
	CAN_MCR(pctl->vcan) &= CAN_MCR_DBF;	// Clear DBF since it is set coming out RESET
 8002a16:	6822      	ldr	r2, [r4, #0]
 8002a18:	6813      	ldr	r3, [r2, #0]
 8002a1a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8002a1e:	6013      	str	r3, [r2, #0]
	CAN_MCR(pctl->vcan) = ((bitcvt(p->dbf) << 16) | (CAN_MCR_INRQ) );
 8002a20:	7aeb      	ldrb	r3, [r5, #11]
 8002a22:	6822      	ldr	r2, [r4, #0]
 8002a24:	2b00      	cmp	r3, #0
 8002a26:	bf14      	ite	ne
 8002a28:	f04f 1301 	movne.w	r3, #65537	; 0x10001
 8002a2c:	2301      	moveq	r3, #1
 8002a2e:	6013      	str	r3, [r2, #0]

	/* The initialization request (above) causes the INAK bit to be set.  This bit goes off when 11 consecutive
	   recessive bits have been received p 633 */
	can_timeout = CAN_TIMEOUT;	// Counter to break loop for timeout
	while ( ((CAN_MSR(pctl->vcan) & CAN_MSR_INAK) == 0 ) && (can_timeout-- > 0) ); // Wait until initialization mode starts or times out
 8002a30:	6821      	ldr	r1, [r4, #0]
	CAN_MCR(pctl->vcan) &= CAN_MCR_DBF;	// Clear DBF since it is set coming out RESET
	CAN_MCR(pctl->vcan) = ((bitcvt(p->dbf) << 16) | (CAN_MCR_INRQ) );

	/* The initialization request (above) causes the INAK bit to be set.  This bit goes off when 11 consecutive
	   recessive bits have been received p 633 */
	can_timeout = CAN_TIMEOUT;	// Counter to break loop for timeout
 8002a32:	4b75      	ldr	r3, [pc, #468]	; (8002c08 <can_driver_init+0x298>)
	while ( ((CAN_MSR(pctl->vcan) & CAN_MSR_INAK) == 0 ) && (can_timeout-- > 0) ); // Wait until initialization mode starts or times out
 8002a34:	1d0a      	adds	r2, r1, #4
 8002a36:	6810      	ldr	r0, [r2, #0]
 8002a38:	07c0      	lsls	r0, r0, #31
 8002a3a:	d403      	bmi.n	8002a44 <can_driver_init+0xd4>
 8002a3c:	f113 33ff 	adds.w	r3, r3, #4294967295
 8002a40:	d2f9      	bcs.n	8002a36 <can_driver_init+0xc6>
 8002a42:	e002      	b.n	8002a4a <can_driver_init+0xda>
	if (can_timeout <= 0 ) {pctl->ret = -6; return pctl;}	// Timed out
 8002a44:	b90b      	cbnz	r3, 8002a4a <can_driver_init+0xda>
 8002a46:	23fa      	movs	r3, #250	; 0xfa
 8002a48:	e071      	b.n	8002b2e <can_driver_init+0x1be>

	/* Compute Baud Rate Prescalar (+1). */
	u32 brp = (pclk1_freq / (1 + p->tbs1 + p->tbs2) ) / p->baudrate;
 8002a4a:	7aab      	ldrb	r3, [r5, #10]
 8002a4c:	7a6a      	ldrb	r2, [r5, #9]
 8002a4e:	3301      	adds	r3, #1
 8002a50:	4413      	add	r3, r2
 8002a52:	4a6e      	ldr	r2, [pc, #440]	; (8002c0c <can_driver_init+0x29c>)
 8002a54:	6812      	ldr	r2, [r2, #0]
 8002a56:	fbb2 f3f3 	udiv	r3, r2, r3
 8002a5a:	682a      	ldr	r2, [r5, #0]
 8002a5c:	fbb3 f3f2 	udiv	r3, r3, r2

	/* Setup Bit Timing Register. */
	CAN_BTR(pctl->vcan)  =  (bitcvt(p->silm)        << 31);	// Silent mode bit
 8002a60:	79aa      	ldrb	r2, [r5, #6]
	CAN_BTR(pctl->vcan) |=  (bitcvt(p->lbkm)        << 30);	// Loopback mode bit
	CAN_BTR(pctl->vcan) |=  (((p->sjw  - 1) & 0x03) << 24);	// Resynchronization jump width
	CAN_BTR(pctl->vcan) |=  (((p->tbs2 - 1) & 0x07) << 20);	// Time segment 2
	CAN_BTR(pctl->vcan) |=  (((p->tbs1 - 1) & 0x0F) << 16);	// Time segment 1
	CAN_BTR(pctl->vcan) |=  (((brp-1)      & 0x3FF) <<  0);	// Baud rate prescalar
 8002a62:	3b01      	subs	r3, #1

	/* Compute Baud Rate Prescalar (+1). */
	u32 brp = (pclk1_freq / (1 + p->tbs1 + p->tbs2) ) / p->baudrate;

	/* Setup Bit Timing Register. */
	CAN_BTR(pctl->vcan)  =  (bitcvt(p->silm)        << 31);	// Silent mode bit
 8002a64:	3200      	adds	r2, #0
 8002a66:	bf18      	it	ne
 8002a68:	2201      	movne	r2, #1
 8002a6a:	07d2      	lsls	r2, r2, #31
 8002a6c:	61ca      	str	r2, [r1, #28]
	CAN_BTR(pctl->vcan) |=  (bitcvt(p->lbkm)        << 30);	// Loopback mode bit
 8002a6e:	6820      	ldr	r0, [r4, #0]
 8002a70:	79ea      	ldrb	r2, [r5, #7]
 8002a72:	69c1      	ldr	r1, [r0, #28]
 8002a74:	3200      	adds	r2, #0
 8002a76:	bf18      	it	ne
 8002a78:	2201      	movne	r2, #1
 8002a7a:	ea41 7282 	orr.w	r2, r1, r2, lsl #30
 8002a7e:	61c2      	str	r2, [r0, #28]
	CAN_BTR(pctl->vcan) |=  (((p->sjw  - 1) & 0x03) << 24);	// Resynchronization jump width
 8002a80:	7a2a      	ldrb	r2, [r5, #8]
 8002a82:	6820      	ldr	r0, [r4, #0]
 8002a84:	3a01      	subs	r2, #1
 8002a86:	69c1      	ldr	r1, [r0, #28]
 8002a88:	0612      	lsls	r2, r2, #24
 8002a8a:	f002 7240 	and.w	r2, r2, #50331648	; 0x3000000
 8002a8e:	430a      	orrs	r2, r1
 8002a90:	61c2      	str	r2, [r0, #28]
	CAN_BTR(pctl->vcan) |=  (((p->tbs2 - 1) & 0x07) << 20);	// Time segment 2
 8002a92:	7a6a      	ldrb	r2, [r5, #9]
 8002a94:	6820      	ldr	r0, [r4, #0]
 8002a96:	3a01      	subs	r2, #1
 8002a98:	69c1      	ldr	r1, [r0, #28]
 8002a9a:	0512      	lsls	r2, r2, #20
 8002a9c:	f402 02e0 	and.w	r2, r2, #7340032	; 0x700000
 8002aa0:	430a      	orrs	r2, r1
 8002aa2:	61c2      	str	r2, [r0, #28]
	CAN_BTR(pctl->vcan) |=  (((p->tbs1 - 1) & 0x0F) << 16);	// Time segment 1
 8002aa4:	7aaa      	ldrb	r2, [r5, #10]
 8002aa6:	6820      	ldr	r0, [r4, #0]
 8002aa8:	3a01      	subs	r2, #1
 8002aaa:	69c1      	ldr	r1, [r0, #28]
 8002aac:	0412      	lsls	r2, r2, #16
 8002aae:	f402 2270 	and.w	r2, r2, #983040	; 0xf0000
 8002ab2:	430a      	orrs	r2, r1
 8002ab4:	61c2      	str	r2, [r0, #28]
	CAN_BTR(pctl->vcan) |=  (((brp-1)      & 0x3FF) <<  0);	// Baud rate prescalar
 8002ab6:	6821      	ldr	r1, [r4, #0]
 8002ab8:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8002abc:	69ca      	ldr	r2, [r1, #28]
 8002abe:	4313      	orrs	r3, r2
 8002ac0:	61cb      	str	r3, [r1, #28]

	/* Master Control Register */
	CAN_MCR(pctl->vcan) &= ~(0xfe);			// Clear bits except for INAQ
 8002ac2:	6822      	ldr	r2, [r4, #0]
 8002ac4:	6813      	ldr	r3, [r2, #0]
 8002ac6:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
 8002aca:	6013      	str	r3, [r2, #0]
	CAN_MCR(pctl->vcan) |=  (bitcvt(p->ttcm) << 7);	// Time triggered communication mode
 8002acc:	6821      	ldr	r1, [r4, #0]
 8002ace:	7b2b      	ldrb	r3, [r5, #12]
 8002ad0:	680a      	ldr	r2, [r1, #0]
 8002ad2:	3300      	adds	r3, #0
 8002ad4:	bf18      	it	ne
 8002ad6:	2301      	movne	r3, #1
 8002ad8:	ea42 13c3 	orr.w	r3, r2, r3, lsl #7
 8002adc:	600b      	str	r3, [r1, #0]
	CAN_MCR(pctl->vcan) |=  (bitcvt(p->abom) << 6);	// Automatic bus-off management
 8002ade:	6821      	ldr	r1, [r4, #0]
 8002ae0:	7b6b      	ldrb	r3, [r5, #13]
 8002ae2:	680a      	ldr	r2, [r1, #0]
 8002ae4:	3300      	adds	r3, #0
 8002ae6:	bf18      	it	ne
 8002ae8:	2301      	movne	r3, #1
 8002aea:	ea42 1383 	orr.w	r3, r2, r3, lsl #6
 8002aee:	600b      	str	r3, [r1, #0]
	CAN_MCR(pctl->vcan) |=  (bitcvt(p->awum) << 5);	// Auto WakeUp Mode
 8002af0:	6821      	ldr	r1, [r4, #0]
 8002af2:	7bab      	ldrb	r3, [r5, #14]
 8002af4:	680a      	ldr	r2, [r1, #0]
 8002af6:	3300      	adds	r3, #0
 8002af8:	bf18      	it	ne
 8002afa:	2301      	movne	r3, #1
 8002afc:	ea42 1343 	orr.w	r3, r2, r3, lsl #5
 8002b00:	600b      	str	r3, [r1, #0]
	CAN_MCR(pctl->vcan) |=  (1 << 4);		// No Automatic ReTry (0 = retry; non-zero = xmit only once)
 8002b02:	6822      	ldr	r2, [r4, #0]
 8002b04:	6813      	ldr	r3, [r2, #0]
 8002b06:	f043 0310 	orr.w	r3, r3, #16
 8002b0a:	6013      	str	r3, [r2, #0]

	/* Leave initialization mode */
	CAN_MCR(pctl->vcan) &= ~CAN_MCR_INRQ;
 8002b0c:	6822      	ldr	r2, [r4, #0]
 8002b0e:	6813      	ldr	r3, [r2, #0]
 8002b10:	f023 0301 	bic.w	r3, r3, #1
 8002b14:	6013      	str	r3, [r2, #0]
	can_timeout = CAN_TIMEOUT;	// Counter to break loop for timeout
	while ( ((CAN_MSR(pctl->vcan) & CAN_MSR_INAK) != 0 ) && (can_timeout-- > 0) );	// Wait until initialization mode starts or times out
 8002b16:	6823      	ldr	r3, [r4, #0]
 8002b18:	1d1a      	adds	r2, r3, #4
	CAN_MCR(pctl->vcan) |=  (bitcvt(p->awum) << 5);	// Auto WakeUp Mode
	CAN_MCR(pctl->vcan) |=  (1 << 4);		// No Automatic ReTry (0 = retry; non-zero = xmit only once)

	/* Leave initialization mode */
	CAN_MCR(pctl->vcan) &= ~CAN_MCR_INRQ;
	can_timeout = CAN_TIMEOUT;	// Counter to break loop for timeout
 8002b1a:	4b3b      	ldr	r3, [pc, #236]	; (8002c08 <can_driver_init+0x298>)
	while ( ((CAN_MSR(pctl->vcan) & CAN_MSR_INAK) != 0 ) && (can_timeout-- > 0) );	// Wait until initialization mode starts or times out
 8002b1c:	6811      	ldr	r1, [r2, #0]
 8002b1e:	07c9      	lsls	r1, r1, #31
 8002b20:	d503      	bpl.n	8002b2a <can_driver_init+0x1ba>
 8002b22:	f113 33ff 	adds.w	r3, r3, #4294967295
 8002b26:	d2f9      	bcs.n	8002b1c <can_driver_init+0x1ac>
 8002b28:	e004      	b.n	8002b34 <can_driver_init+0x1c4>
	if (can_timeout == 0 ){pctl->ret = -7; return pctl;}	// Timed out
 8002b2a:	b91b      	cbnz	r3, 8002b34 <can_driver_init+0x1c4>
 8002b2c:	23f9      	movs	r3, #249	; 0xf9
 8002b2e:	f884 309c 	strb.w	r3, [r4, #156]	; 0x9c
 8002b32:	e05f      	b.n	8002bf4 <can_driver_init+0x284>

	/* Set and enable interrupt controller for CAN interrupts: TX, RX0, RX1 */
	NVICIPR (p->tx.vectnum, p->tx.vectpriority);	// Set interrupt priority
 8002b34:	692a      	ldr	r2, [r5, #16]
 8002b36:	6969      	ldr	r1, [r5, #20]
 8002b38:	f022 0303 	bic.w	r3, r2, #3
 8002b3c:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 8002b40:	f002 0203 	and.w	r2, r2, #3
 8002b44:	f503 4364 	add.w	r3, r3, #58368	; 0xe400
 8002b48:	00d2      	lsls	r2, r2, #3
 8002b4a:	fa01 f202 	lsl.w	r2, r1, r2
 8002b4e:	6819      	ldr	r1, [r3, #0]
 8002b50:	430a      	orrs	r2, r1
 8002b52:	601a      	str	r2, [r3, #0]
	NVICISER(p->tx.vectnum);			// Enable interrupt controller
 8002b54:	692a      	ldr	r2, [r5, #16]
 8002b56:	2101      	movs	r1, #1
 8002b58:	0953      	lsrs	r3, r2, #5
 8002b5a:	f103 2338 	add.w	r3, r3, #939538432	; 0x38003800
 8002b5e:	3340      	adds	r3, #64	; 0x40
 8002b60:	009b      	lsls	r3, r3, #2
 8002b62:	6818      	ldr	r0, [r3, #0]
 8002b64:	f002 021f 	and.w	r2, r2, #31
 8002b68:	fa01 f202 	lsl.w	r2, r1, r2
 8002b6c:	4302      	orrs	r2, r0
 8002b6e:	601a      	str	r2, [r3, #0]

	NVICIPR (p->rx0.vectnum, p->rx0.vectpriority);	// Set interrupt priority
 8002b70:	69aa      	ldr	r2, [r5, #24]
 8002b72:	69e8      	ldr	r0, [r5, #28]
 8002b74:	f022 0303 	bic.w	r3, r2, #3
 8002b78:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 8002b7c:	f002 0203 	and.w	r2, r2, #3
 8002b80:	f503 4364 	add.w	r3, r3, #58368	; 0xe400
 8002b84:	00d2      	lsls	r2, r2, #3
 8002b86:	fa00 f202 	lsl.w	r2, r0, r2
 8002b8a:	6818      	ldr	r0, [r3, #0]
 8002b8c:	4302      	orrs	r2, r0
 8002b8e:	601a      	str	r2, [r3, #0]
	NVICISER(p->rx0.vectnum);			// Enable interrupt controller
 8002b90:	69aa      	ldr	r2, [r5, #24]
 8002b92:	0953      	lsrs	r3, r2, #5
 8002b94:	f103 2338 	add.w	r3, r3, #939538432	; 0x38003800
 8002b98:	3340      	adds	r3, #64	; 0x40
 8002b9a:	009b      	lsls	r3, r3, #2
 8002b9c:	6818      	ldr	r0, [r3, #0]
 8002b9e:	f002 021f 	and.w	r2, r2, #31
 8002ba2:	fa01 f202 	lsl.w	r2, r1, r2
 8002ba6:	4302      	orrs	r2, r0
 8002ba8:	601a      	str	r2, [r3, #0]

	NVICIPR (p->rx1.vectnum, p->rx1.vectpriority);	// Set interrupt priority
 8002baa:	6a2a      	ldr	r2, [r5, #32]
 8002bac:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8002bae:	f022 0303 	bic.w	r3, r2, #3
 8002bb2:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 8002bb6:	f002 0203 	and.w	r2, r2, #3
 8002bba:	f503 4364 	add.w	r3, r3, #58368	; 0xe400
 8002bbe:	00d2      	lsls	r2, r2, #3
 8002bc0:	fa00 f202 	lsl.w	r2, r0, r2
 8002bc4:	6818      	ldr	r0, [r3, #0]
 8002bc6:	4302      	orrs	r2, r0
 8002bc8:	601a      	str	r2, [r3, #0]
	NVICISER(p->rx1.vectnum);			// Enable interrupt controller
 8002bca:	6a2a      	ldr	r2, [r5, #32]
 8002bcc:	0953      	lsrs	r3, r2, #5
 8002bce:	f103 2338 	add.w	r3, r3, #939538432	; 0x38003800
 8002bd2:	3340      	adds	r3, #64	; 0x40
 8002bd4:	009b      	lsls	r3, r3, #2
 8002bd6:	f002 021f 	and.w	r2, r2, #31
 8002bda:	4091      	lsls	r1, r2
 8002bdc:	681a      	ldr	r2, [r3, #0]
 8002bde:	4311      	orrs	r1, r2
 8002be0:	6019      	str	r1, [r3, #0]

	/* If mailbox is not empty, then enabling interrupts will result in an immediate
           interrupt, and the TX_IRQHandler will be dealing with an empty pending list! */
	while ( (CAN_TSR(pctl->vcan) & CAN_TSR_TME0) == 0);         // Wait for transmit mailbox 0 to be empty
 8002be2:	6823      	ldr	r3, [r4, #0]
 8002be4:	3308      	adds	r3, #8
 8002be6:	681a      	ldr	r2, [r3, #0]
 8002be8:	0152      	lsls	r2, r2, #5
 8002bea:	d5fc      	bpl.n	8002be6 <can_driver_init+0x276>

pcan_errors = &pctl->can_errors;
 8002bec:	f104 0350 	add.w	r3, r4, #80	; 0x50
 8002bf0:	f8c6 38c8 	str.w	r3, [r6, #2248]	; 0x8c8

	/* CAN (CAN1 or CAN2) was intialized.  Enable by calling 'can_driver_enable_interrupts'
	   below *after both* CAN1 and CAN2 intialized (if both are being used). */
//	pctl->ret = 0;	// Set success code (which 'calloc' already set to zero)
	return pctl;	// Return pointer to control block
 8002bf4:	4620      	mov	r0, r4
 8002bf6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

	/* Get control block for this CAN module. */
	pctl = (struct CAN_CTLBLOCK*)calloc(1, sizeof(struct CAN_CTLBLOCK));
	if (pctl == NULL) return NULL;
	if (p->cannum == 1) {pctl0 = pctl; pctl->vcan = CAN1;}
	if (p->cannum == 2) {pctl1 = pctl; pctl->vcan = CAN2;}
 8002bfa:	6070      	str	r0, [r6, #4]
 8002bfc:	4b04      	ldr	r3, [pc, #16]	; (8002c10 <can_driver_init+0x2a0>)
 8002bfe:	e6cf      	b.n	80029a0 <can_driver_init+0x30>
 8002c00:	20001900 	.word	0x20001900
 8002c04:	40006400 	.word	0x40006400
 8002c08:	005b8d80 	.word	0x005b8d80
 8002c0c:	200010dc 	.word	0x200010dc
 8002c10:	40006800 	.word	0x40006800

08002c14 <can_driver_enable_interrupts>:
 * @brief	: Enable interrupts after all CAN modules have been initialized
 * @return	: 0 = OK; -1 = no buffers were set up
 ******************************************************************************/
int can_driver_enable_interrupts(void)
{
	if (buffct == 0) return -1;
 8002c14:	4b09      	ldr	r3, [pc, #36]	; (8002c3c <can_driver_enable_interrupts+0x28>)
 8002c16:	f8d3 38c4 	ldr.w	r3, [r3, #2244]	; 0x8c4
 8002c1a:	b163      	cbz	r3, 8002c36 <can_driver_enable_interrupts+0x22>
	CAN_IER(CAN1) |= 0x13;
 8002c1c:	4a08      	ldr	r2, [pc, #32]	; (8002c40 <can_driver_enable_interrupts+0x2c>)
	CAN_IER(CAN2) |= 0x13;
	return 0;	
 8002c1e:	2000      	movs	r0, #0
 * @return	: 0 = OK; -1 = no buffers were set up
 ******************************************************************************/
int can_driver_enable_interrupts(void)
{
	if (buffct == 0) return -1;
	CAN_IER(CAN1) |= 0x13;
 8002c20:	6813      	ldr	r3, [r2, #0]
 8002c22:	f043 0313 	orr.w	r3, r3, #19
 8002c26:	6013      	str	r3, [r2, #0]
	CAN_IER(CAN2) |= 0x13;
 8002c28:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
 8002c2c:	f043 0313 	orr.w	r3, r3, #19
 8002c30:	f8c2 3400 	str.w	r3, [r2, #1024]	; 0x400
	return 0;	
 8002c34:	4770      	bx	lr
 * @brief	: Enable interrupts after all CAN modules have been initialized
 * @return	: 0 = OK; -1 = no buffers were set up
 ******************************************************************************/
int can_driver_enable_interrupts(void)
{
	if (buffct == 0) return -1;
 8002c36:	f04f 30ff 	mov.w	r0, #4294967295
	CAN_IER(CAN1) |= 0x13;
	CAN_IER(CAN2) |= 0x13;
	return 0;	
}
 8002c3a:	4770      	bx	lr
 8002c3c:	20001900 	.word	0x20001900
 8002c40:	40006414 	.word	0x40006414

08002c44 <can_driver_toss0>:
 * void can_driver_toss1(struct CAN_CTLBLOCK* pctl);
 * @brief	: Release msg buffer back to free list
 ******************************************************************************/
void can_driver_toss0(struct CAN_CTLBLOCK* pctl)
{
	can_driver_toss(&pctl->ptrs0);
 8002c44:	302c      	adds	r0, #44	; 0x2c
 8002c46:	e5c9      	b.n	80027dc <can_driver_toss>

08002c48 <can_driver_toss1>:
	return;
}
void can_driver_toss1(struct CAN_CTLBLOCK* pctl)
{
	can_driver_toss(&pctl->ptrs1);
 8002c48:	303c      	adds	r0, #60	; 0x3c
 8002c4a:	e5c7      	b.n	80027dc <can_driver_toss>

08002c4c <can_driver_peek0>:
 ******************************************************************************/
u32 debugA = 0;
struct CANRCVBUF* can_driver_peek0(struct CAN_CTLBLOCK* pctl)
{
	/* Return if no msgs in this list */
	if (pctl->ptrs0.ptail == NULL) return NULL;
 8002c4c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8002c4e:	b11b      	cbz	r3, 8002c58 <can_driver_peek0+0xc>
	return (struct CANRCVBUF*)&pctl->ptrs0.ptail->plinknext->can; // volatile discard warning
 8002c50:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8002c52:	6818      	ldr	r0, [r3, #0]
 8002c54:	3008      	adds	r0, #8
 8002c56:	4770      	bx	lr
 ******************************************************************************/
u32 debugA = 0;
struct CANRCVBUF* can_driver_peek0(struct CAN_CTLBLOCK* pctl)
{
	/* Return if no msgs in this list */
	if (pctl->ptrs0.ptail == NULL) return NULL;
 8002c58:	4618      	mov	r0, r3
	return (struct CANRCVBUF*)&pctl->ptrs0.ptail->plinknext->can; // volatile discard warning
}
 8002c5a:	4770      	bx	lr

08002c5c <can_driver_peek1>:
struct CANRCVBUF* can_driver_peek1(struct CAN_CTLBLOCK* pctl)
{
	/* Return if no msgs in this list */
	if (pctl->ptrs1.ptail == NULL) return NULL;
 8002c5c:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8002c5e:	b14b      	cbz	r3, 8002c74 <can_driver_peek1+0x18>
debugA += 1;
 8002c60:	4a05      	ldr	r2, [pc, #20]	; (8002c78 <can_driver_peek1+0x1c>)
 8002c62:	f8d2 38cc 	ldr.w	r3, [r2, #2252]	; 0x8cc
 8002c66:	3301      	adds	r3, #1
 8002c68:	f8c2 38cc 	str.w	r3, [r2, #2252]	; 0x8cc
	return (struct CANRCVBUF*)&pctl->ptrs1.ptail->plinknext->can; // volatile discard warning
 8002c6c:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8002c6e:	6818      	ldr	r0, [r3, #0]
 8002c70:	3008      	adds	r0, #8
 8002c72:	4770      	bx	lr
	return (struct CANRCVBUF*)&pctl->ptrs0.ptail->plinknext->can; // volatile discard warning
}
struct CANRCVBUF* can_driver_peek1(struct CAN_CTLBLOCK* pctl)
{
	/* Return if no msgs in this list */
	if (pctl->ptrs1.ptail == NULL) return NULL;
 8002c74:	4618      	mov	r0, r3
debugA += 1;
	return (struct CANRCVBUF*)&pctl->ptrs1.ptail->plinknext->can; // volatile discard warning
}
 8002c76:	4770      	bx	lr
 8002c78:	20001900 	.word	0x20001900

08002c7c <can_driver_put>:
 * @return	:  0 = OK; 
 *		: -1 = Buffer overrun (no free slots for the new msg)
 *		: -2 = Bogus CAN id rejected
 ******************************************************************************/
int can_driver_put(struct CAN_CTLBLOCK* pctl, struct CANRCVBUF *pcan, u8 maxretryct, u8 bits)
{
 8002c7c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 8002c80:	4692      	mov	sl, r2

	u32 save[2];	// IER register saved during disable of interrupts

	/* Reject CAN msg if CAN id is "bogus". */
	// If 11b is specified && bits in extended address are present it is bogus
	if (((pcan->id & CAN_IDE) == 0) && ((pcan->id & CAN_EXTENDED_MASK) != 0))
 8002c82:	680a      	ldr	r2, [r1, #0]
 * @return	:  0 = OK; 
 *		: -1 = Buffer overrun (no free slots for the new msg)
 *		: -2 = Bogus CAN id rejected
 ******************************************************************************/
int can_driver_put(struct CAN_CTLBLOCK* pctl, struct CANRCVBUF *pcan, u8 maxretryct, u8 bits)
{
 8002c84:	4699      	mov	r9, r3

	u32 save[2];	// IER register saved during disable of interrupts

	/* Reject CAN msg if CAN id is "bogus". */
	// If 11b is specified && bits in extended address are present it is bogus
	if (((pcan->id & CAN_IDE) == 0) && ((pcan->id & CAN_EXTENDED_MASK) != 0))
 8002c86:	0753      	lsls	r3, r2, #29
 * @return	:  0 = OK; 
 *		: -1 = Buffer overrun (no free slots for the new msg)
 *		: -2 = Bogus CAN id rejected
 ******************************************************************************/
int can_driver_put(struct CAN_CTLBLOCK* pctl, struct CANRCVBUF *pcan, u8 maxretryct, u8 bits)
{
 8002c88:	4604      	mov	r4, r0
 8002c8a:	4688      	mov	r8, r1

	u32 save[2];	// IER register saved during disable of interrupts

	/* Reject CAN msg if CAN id is "bogus". */
	// If 11b is specified && bits in extended address are present it is bogus
	if (((pcan->id & CAN_IDE) == 0) && ((pcan->id & CAN_EXTENDED_MASK) != 0))
 8002c8c:	d40a      	bmi.n	8002ca4 <can_driver_put+0x28>
 8002c8e:	4b62      	ldr	r3, [pc, #392]	; (8002e18 <can_driver_put+0x19c>)
 8002c90:	4013      	ands	r3, r2
 8002c92:	b13b      	cbz	r3, 8002ca4 <can_driver_put+0x28>
	{
		pctl->bogusct += 1;
 8002c94:	f8d0 3098 	ldr.w	r3, [r0, #152]	; 0x98
 8002c98:	3301      	adds	r3, #1
 8002c9a:	f8c0 3098 	str.w	r3, [r0, #152]	; 0x98
		return -2;
 8002c9e:	f06f 0001 	mvn.w	r0, #1
 8002ca2:	e0b6      	b.n	8002e12 <can_driver_put+0x196>
	}

	/* Get a free block from the free list. */
	disable_ints(save);	// TX, RX0, RX1 interrupt might move a msg to the free list.
	pnew = frii.plinknext;
 8002ca4:	4d5d      	ldr	r5, [pc, #372]	; (8002e1c <can_driver_put+0x1a0>)
		pctl->bogusct += 1;
		return -2;
	}

	/* Get a free block from the free list. */
	disable_ints(save);	// TX, RX0, RX1 interrupt might move a msg to the free list.
 8002ca6:	4668      	mov	r0, sp
 8002ca8:	f7ff fd58 	bl	800275c <disable_ints>
	pnew = frii.plinknext;
 8002cac:	69ae      	ldr	r6, [r5, #24]
	if ((pnew == NULL) || (pctl->txbct >= pctl->txbmx))
 8002cae:	b12e      	cbz	r6, 8002cbc <can_driver_put+0x40>
 8002cb0:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 8002cb4:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 8002cb8:	429a      	cmp	r2, r3
 8002cba:	db08      	blt.n	8002cce <can_driver_put+0x52>
	{ // Here, either no free list blocks OR this TX reached its limit
		reenable_ints(save);
 8002cbc:	4668      	mov	r0, sp
 8002cbe:	f7ff fd7f 	bl	80027c0 <reenable_ints>
		pctl->can_errors.can_msgovrflow += 1;	// Count overflows
 8002cc2:	6e23      	ldr	r3, [r4, #96]	; 0x60
		return -1;	// Return failure: no space & screwed
 8002cc4:	f04f 30ff 	mov.w	r0, #4294967295
	disable_ints(save);	// TX, RX0, RX1 interrupt might move a msg to the free list.
	pnew = frii.plinknext;
	if ((pnew == NULL) || (pctl->txbct >= pctl->txbmx))
	{ // Here, either no free list blocks OR this TX reached its limit
		reenable_ints(save);
		pctl->can_errors.can_msgovrflow += 1;	// Count overflows
 8002cc8:	3301      	adds	r3, #1
 8002cca:	6623      	str	r3, [r4, #96]	; 0x60
		return -1;	// Return failure: no space & screwed
 8002ccc:	e0a1      	b.n	8002e12 <can_driver_put+0x196>
	}	
	frii.plinknext = pnew->plinknext;
 8002cce:	4637      	mov	r7, r6
 8002cd0:	f857 3b08 	ldr.w	r3, [r7], #8
	friict -= 1; // Keep running count of free list inventory
	reenable_ints(save);
 8002cd4:	4668      	mov	r0, sp
	{ // Here, either no free list blocks OR this TX reached its limit
		reenable_ints(save);
		pctl->can_errors.can_msgovrflow += 1;	// Count overflows
		return -1;	// Return failure: no space & screwed
	}	
	frii.plinknext = pnew->plinknext;
 8002cd6:	61ab      	str	r3, [r5, #24]
	friict -= 1; // Keep running count of free list inventory
 8002cd8:	68ab      	ldr	r3, [r5, #8]
 8002cda:	3b01      	subs	r3, #1
 8002cdc:	60ab      	str	r3, [r5, #8]
	reenable_ints(save);
 8002cde:	f7ff fd6f 	bl	80027c0 <reenable_ints>
	/* Build struct/block for addition to the pending list. */
	// retryct    xb[0]	// Counter for number of retries for TERR errors
	// maxretryct xb[1]	// Maximum number of TERR retry counts
	// bits	      xb[2]		// Use these bits to set some conditions (see below)
	// nosend     xb[3]	// Do not send: 0 = send; 1 = do NOT send on CAN bus (internal use only)
	pnew->can     = *pcan;	// Copy CAN msg.
 8002ce2:	e898 000f 	ldmia.w	r8, {r0, r1, r2, r3}
 8002ce6:	e887 000f 	stmia.w	r7, {r0, r1, r2, r3}
	pnew->x.xb[1] = maxretryct;	// Maximum number of TERR retry counts
	pnew->x.xb[2] = bits;	// Use these bits to set some conditions (see .h file)
	pnew->x.xb[3] = 0;	// not used for now
 8002cea:	2300      	movs	r3, #0
	// retryct    xb[0]	// Counter for number of retries for TERR errors
	// maxretryct xb[1]	// Maximum number of TERR retry counts
	// bits	      xb[2]		// Use these bits to set some conditions (see below)
	// nosend     xb[3]	// Do not send: 0 = send; 1 = do NOT send on CAN bus (internal use only)
	pnew->can     = *pcan;	// Copy CAN msg.
	pnew->x.xb[1] = maxretryct;	// Maximum number of TERR retry counts
 8002cec:	f886 a019 	strb.w	sl, [r6, #25]
	pnew->x.xb[2] = bits;	// Use these bits to set some conditions (see .h file)
 8002cf0:	f886 901a 	strb.w	r9, [r6, #26]
	pnew->x.xb[3] = 0;	// not used for now
 8002cf4:	76f3      	strb	r3, [r6, #27]
	pnew->x.xb[0] = 0;	// Retry counter for TERRs
 8002cf6:	7633      	strb	r3, [r6, #24]
dbugabort[20] += 1;
 8002cf8:	f8d5 388c 	ldr.w	r3, [r5, #2188]	; 0x88c
	/* Find location to insert new msg.  Lower value CAN ids are higher priority, 
           and when the CAN id msg to be inserted has the same CAN id as the 'pfor' one
           already in the list, then place the new one further down so that msgs with 
           the same CAN id do not get their order of transmission altered. */
 	disable_ints(save);
 8002cfc:	4668      	mov	r0, sp
	pnew->can     = *pcan;	// Copy CAN msg.
	pnew->x.xb[1] = maxretryct;	// Maximum number of TERR retry counts
	pnew->x.xb[2] = bits;	// Use these bits to set some conditions (see .h file)
	pnew->x.xb[3] = 0;	// not used for now
	pnew->x.xb[0] = 0;	// Retry counter for TERRs
dbugabort[20] += 1;
 8002cfe:	3301      	adds	r3, #1
 8002d00:	f8c5 388c 	str.w	r3, [r5, #2188]	; 0x88c
	/* Find location to insert new msg.  Lower value CAN ids are higher priority, 
           and when the CAN id msg to be inserted has the same CAN id as the 'pfor' one
           already in the list, then place the new one further down so that msgs with 
           the same CAN id do not get their order of transmission altered. */
 	disable_ints(save);
 8002d04:	f7ff fd2a 	bl	800275c <disable_ints>

	for (pfor = &pctl->pend; pfor->plinknext != NULL; pfor = pfor->plinknext)
 8002d08:	f104 0308 	add.w	r3, r4, #8
 8002d0c:	681a      	ldr	r2, [r3, #0]
 8002d0e:	b122      	cbz	r2, 8002d1a <can_driver_put+0x9e>
	{
		if (pnew->can.id < (pfor->plinknext)->can.id) // Pay attention: "value" vs "priority"
 8002d10:	68b1      	ldr	r1, [r6, #8]
 8002d12:	681a      	ldr	r2, [r3, #0]
 8002d14:	6892      	ldr	r2, [r2, #8]
 8002d16:	4291      	cmp	r1, r2
 8002d18:	d20d      	bcs.n	8002d36 <can_driver_put+0xba>
			break;
	}

	/* Add new msg to pending list. (TX interrupt is still disabled) */
	pnew->plinknext = pfor->plinknext; 	// Insert new msg into 
 8002d1a:	681a      	ldr	r2, [r3, #0]
	pfor->plinknext = pnew;			//   pending list.
	pctl->txbct += 1;	// Increment running ct of pending list
 8002d1c:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
		if (pnew->can.id < (pfor->plinknext)->can.id) // Pay attention: "value" vs "priority"
			break;
	}

	/* Add new msg to pending list. (TX interrupt is still disabled) */
	pnew->plinknext = pfor->plinknext; 	// Insert new msg into 
 8002d20:	6032      	str	r2, [r6, #0]
	pfor->plinknext = pnew;			//   pending list.
 8002d22:	601e      	str	r6, [r3, #0]
	pctl->txbct += 1;	// Increment running ct of pending list
	pfor =  NULL;	// Signal TX interrupt that search loop is not active.

	if (pctl->pxprv == NULL) // Is sending complete?
 8002d24:	6aa1      	ldr	r1, [r4, #40]	; 0x28
	}

	/* Add new msg to pending list. (TX interrupt is still disabled) */
	pnew->plinknext = pfor->plinknext; 	// Insert new msg into 
	pfor->plinknext = pnew;			//   pending list.
	pctl->txbct += 1;	// Increment running ct of pending list
 8002d26:	3001      	adds	r0, #1
 8002d28:	f8c4 0090 	str.w	r0, [r4, #144]	; 0x90
	pfor =  NULL;	// Signal TX interrupt that search loop is not active.

	if (pctl->pxprv == NULL) // Is sending complete?
 8002d2c:	b929      	cbnz	r1, 8002d3a <can_driver_put+0xbe>
//#if ( (pctl->pxprv == NULL) || ((CAN_TSR(pctl->vcan) & CAN_TSR_TME0) != 0) ) // Is sending complete?
	{ // pxprv == NULL means CAN mailbox did not get loaded, so CAN is idle.
		loadmbx2(pctl,0); // Start sending
 8002d2e:	4620      	mov	r0, r4
 8002d30:	f7ff fd7c 	bl	800282c <loadmbx2>
 8002d34:	e069      	b.n	8002e0a <can_driver_put+0x18e>
           and when the CAN id msg to be inserted has the same CAN id as the 'pfor' one
           already in the list, then place the new one further down so that msgs with 
           the same CAN id do not get their order of transmission altered. */
 	disable_ints(save);

	for (pfor = &pctl->pend; pfor->plinknext != NULL; pfor = pfor->plinknext)
 8002d36:	681b      	ldr	r3, [r3, #0]
 8002d38:	e7e8      	b.n	8002d0c <can_driver_put+0x90>
	{ // pxprv == NULL means CAN mailbox did not get loaded, so CAN is idle.
		loadmbx2(pctl,0); // Start sending
	}
	else
   { // Here CAN is supposed to be running
		if ((pctl->pxprv)->plinknext == pnew) // Does pxprv need adjustment?
 8002d3a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002d3c:	681b      	ldr	r3, [r3, #0]
 8002d3e:	429e      	cmp	r6, r3
		{ // Here yes. We inserted a msg between 'pxprv' and 'pxprv->linknext'
			pctl->pxprv = pnew;	// Update 'pxprv' so that it still points to msg TX using.
			pctl->can_errors.can_pxprv_fwd_one += 1;	// Count: Instances that pxprv was adjusted in 'for' loop
 8002d40:	bf01      	itttt	eq
 8002d42:	6f23      	ldreq	r3, [r4, #112]	; 0x70
	}
	else
   { // Here CAN is supposed to be running
		if ((pctl->pxprv)->plinknext == pnew) // Does pxprv need adjustment?
		{ // Here yes. We inserted a msg between 'pxprv' and 'pxprv->linknext'
			pctl->pxprv = pnew;	// Update 'pxprv' so that it still points to msg TX using.
 8002d44:	62a6      	streq	r6, [r4, #40]	; 0x28
			pctl->can_errors.can_pxprv_fwd_one += 1;	// Count: Instances that pxprv was adjusted in 'for' loop
 8002d46:	3301      	addeq	r3, #1
 8002d48:	6723      	streq	r3, [r4, #112]	; 0x70
		}
/* &&&&&&&&&&&&&& BEGIN ABORT MODS &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& */
#ifdef YESABORTCODE
		/* Check if new msg is higher CAN priority than msg in mailbox */
		if ( (pctl->pend.plinknext)->can.id < (CAN_TIxR (pctl->vcan, CAN_MBOX0) & ~0x1)  )
 8002d4a:	6826      	ldr	r6, [r4, #0]
 8002d4c:	68a3      	ldr	r3, [r4, #8]
 8002d4e:	689a      	ldr	r2, [r3, #8]
 8002d50:	f8d6 3180 	ldr.w	r3, [r6, #384]	; 0x180
 8002d54:	f023 0301 	bic.w	r3, r3, #1
 8002d58:	429a      	cmp	r2, r3
 8002d5a:	d256      	bcs.n	8002e0a <can_driver_put+0x18e>
Set by software to abort the transmission request for the corresponding mailbox.
Cleared by hardware when the mailbox becomes empty.
Setting this bit has no effect when the mailbox is not pending for transmission. 
*/
/* [deh] "no effect"--does this mean the bit does not appear in the register? */
if (pctl == pctl0)
 8002d5c:	682a      	ldr	r2, [r5, #0]
 8002d5e:	4b2f      	ldr	r3, [pc, #188]	; (8002e1c <can_driver_put+0x1a0>)
 8002d60:	4294      	cmp	r4, r2
 8002d62:	d10f      	bne.n	8002d84 <can_driver_put+0x108>
{
dbugabort[0] += 1;
 8002d64:	f8d3 283c 	ldr.w	r2, [r3, #2108]	; 0x83c
dbugabort[1] = pctl->txbct;
 8002d68:	f8c3 0840 	str.w	r0, [r3, #2112]	; 0x840
Setting this bit has no effect when the mailbox is not pending for transmission. 
*/
/* [deh] "no effect"--does this mean the bit does not appear in the register? */
if (pctl == pctl0)
{
dbugabort[0] += 1;
 8002d6c:	3201      	adds	r2, #1
 8002d6e:	f8c3 283c 	str.w	r2, [r3, #2108]	; 0x83c
dbugabort[1] = pctl->txbct;
dbugabort[8] = (pctl->pend.plinknext)->can.id;
 8002d72:	68a2      	ldr	r2, [r4, #8]
 8002d74:	6892      	ldr	r2, [r2, #8]
 8002d76:	f8c3 285c 	str.w	r2, [r3, #2140]	; 0x85c
//$$		CAN_TSR(pctl->vcan) |= CAN_TSR_ABRQ0;	// Set Abort request for mailbox 0.
dbugabort[9] = CAN_TIxR (pctl->vcan, CAN_MBOX0);
 8002d7a:	f8d6 2180 	ldr.w	r2, [r6, #384]	; 0x180
 8002d7e:	f8c3 2860 	str.w	r2, [r3, #2144]	; 0x860
 8002d82:	e037      	b.n	8002df4 <can_driver_put+0x178>
}
else
{
dbugabort[4] += 1;
 8002d84:	f8d3 284c 	ldr.w	r2, [r3, #2124]	; 0x84c
dbugabort[5] = pctl->txbct;
 8002d88:	f8c3 0850 	str.w	r0, [r3, #2128]	; 0x850
//$$		CAN_TSR(pctl->vcan) |= CAN_TSR_ABRQ0;	// Set Abort request for mailbox 0.
dbugabort[9] = CAN_TIxR (pctl->vcan, CAN_MBOX0);
}
else
{
dbugabort[4] += 1;
 8002d8c:	3201      	adds	r2, #1
 8002d8e:	f8c3 284c 	str.w	r2, [r3, #2124]	; 0x84c
dbugabort[5] = pctl->txbct;
dbugabort[10] = (pctl->pend.plinknext)->can.id;
 8002d92:	68a2      	ldr	r2, [r4, #8]
dbugabort[11] = CAN_TIxR (pctl->vcan, CAN_MBOX0);

dbugx[dbugxidx].idb4  = dbugabort[11];
 8002d94:	6b99      	ldr	r1, [r3, #56]	; 0x38
}
else
{
dbugabort[4] += 1;
dbugabort[5] = pctl->txbct;
dbugabort[10] = (pctl->pend.plinknext)->can.id;
 8002d96:	6897      	ldr	r7, [r2, #8]
dbugabort[11] = CAN_TIxR (pctl->vcan, CAN_MBOX0);

dbugx[dbugxidx].idb4  = dbugabort[11];
 8002d98:	eb03 1241 	add.w	r2, r3, r1, lsl #5
}
else
{
dbugabort[4] += 1;
dbugabort[5] = pctl->txbct;
dbugabort[10] = (pctl->pend.plinknext)->can.id;
 8002d9c:	f8c3 7864 	str.w	r7, [r3, #2148]	; 0x864
dbugabort[11] = CAN_TIxR (pctl->vcan, CAN_MBOX0);
 8002da0:	f8d6 e180 	ldr.w	lr, [r6, #384]	; 0x180

dbugx[dbugxidx].idb4  = dbugabort[11];
dbugx[dbugxidx].idaf  = dbugabort[10];
 8002da4:	6417      	str	r7, [r2, #64]	; 0x40
dbugabort[4] += 1;
dbugabort[5] = pctl->txbct;
dbugabort[10] = (pctl->pend.plinknext)->can.id;
dbugabort[11] = CAN_TIxR (pctl->vcan, CAN_MBOX0);

dbugx[dbugxidx].idb4  = dbugabort[11];
 8002da6:	f8c2 e03c 	str.w	lr, [r2, #60]	; 0x3c
else
{
dbugabort[4] += 1;
dbugabort[5] = pctl->txbct;
dbugabort[10] = (pctl->pend.plinknext)->can.id;
dbugabort[11] = CAN_TIxR (pctl->vcan, CAN_MBOX0);
 8002daa:	f8c3 e868 	str.w	lr, [r3, #2152]	; 0x868

dbugx[dbugxidx].idb4  = dbugabort[11];
dbugx[dbugxidx].idaf  = dbugabort[10];
//$$	CAN_TSR(pctl->vcan) |= CAN_TSR_ABRQ0;	// Set Abort request for mailbox 0.
dbugx[dbugxidx].aflag = pctl->abortflag;
dbugx[dbugxidx].bit   = CAN_TSR(pctl->vcan);
 8002dae:	68b6      	ldr	r6, [r6, #8]
dbugabort[11] = CAN_TIxR (pctl->vcan, CAN_MBOX0);

dbugx[dbugxidx].idb4  = dbugabort[11];
dbugx[dbugxidx].idaf  = dbugabort[10];
//$$	CAN_TSR(pctl->vcan) |= CAN_TSR_ABRQ0;	// Set Abort request for mailbox 0.
dbugx[dbugxidx].aflag = pctl->abortflag;
 8002db0:	6ce7      	ldr	r7, [r4, #76]	; 0x4c
dbugx[dbugxidx].bit   = CAN_TSR(pctl->vcan);
dbugx[dbugxidx].mbx2  = 0xff;
dbugx[dbugxidx].ct    = pctl->txbct;
 8002db2:	6510      	str	r0, [r2, #80]	; 0x50
dbugx[dbugxidx].ct1   = dbugabort[6]; // Number of aborts *handled*
 8002db4:	f8d3 0854 	ldr.w	r0, [r3, #2132]	; 0x854

dbugx[dbugxidx].idb4  = dbugabort[11];
dbugx[dbugxidx].idaf  = dbugabort[10];
//$$	CAN_TSR(pctl->vcan) |= CAN_TSR_ABRQ0;	// Set Abort request for mailbox 0.
dbugx[dbugxidx].aflag = pctl->abortflag;
dbugx[dbugxidx].bit   = CAN_TSR(pctl->vcan);
 8002db8:	6596      	str	r6, [r2, #88]	; 0x58
dbugx[dbugxidx].mbx2  = 0xff;
dbugx[dbugxidx].ct    = pctl->txbct;
dbugx[dbugxidx].ct1   = dbugabort[6]; // Number of aborts *handled*
 8002dba:	6490      	str	r0, [r2, #72]	; 0x48
dbugx[dbugxidx].updn = updn;
 8002dbc:	f8b3 08c0 	ldrh.w	r0, [r3, #2240]	; 0x8c0
dbugx[dbugxidx].idb4  = dbugabort[11];
dbugx[dbugxidx].idaf  = dbugabort[10];
//$$	CAN_TSR(pctl->vcan) |= CAN_TSR_ABRQ0;	// Set Abort request for mailbox 0.
dbugx[dbugxidx].aflag = pctl->abortflag;
dbugx[dbugxidx].bit   = CAN_TSR(pctl->vcan);
dbugx[dbugxidx].mbx2  = 0xff;
 8002dc0:	26ff      	movs	r6, #255	; 0xff
dbugx[dbugxidx].ct    = pctl->txbct;
dbugx[dbugxidx].ct1   = dbugabort[6]; // Number of aborts *handled*
dbugx[dbugxidx].updn = updn;
 8002dc2:	f8a2 0046 	strh.w	r0, [r2, #70]	; 0x46
arbqctr += 1;
 8002dc6:	f8d3 08bc 	ldr.w	r0, [r3, #2236]	; 0x8bc
dbugabort[11] = CAN_TIxR (pctl->vcan, CAN_MBOX0);

dbugx[dbugxidx].idb4  = dbugabort[11];
dbugx[dbugxidx].idaf  = dbugabort[10];
//$$	CAN_TSR(pctl->vcan) |= CAN_TSR_ABRQ0;	// Set Abort request for mailbox 0.
dbugx[dbugxidx].aflag = pctl->abortflag;
 8002dca:	f8a2 7044 	strh.w	r7, [r2, #68]	; 0x44
dbugx[dbugxidx].bit   = CAN_TSR(pctl->vcan);
dbugx[dbugxidx].mbx2  = 0xff;
dbugx[dbugxidx].ct    = pctl->txbct;
dbugx[dbugxidx].ct1   = dbugabort[6]; // Number of aborts *handled*
dbugx[dbugxidx].updn = updn;
arbqctr += 1;
 8002dce:	3001      	adds	r0, #1
dbugx[dbugxidx].idb4  = dbugabort[11];
dbugx[dbugxidx].idaf  = dbugabort[10];
//$$	CAN_TSR(pctl->vcan) |= CAN_TSR_ABRQ0;	// Set Abort request for mailbox 0.
dbugx[dbugxidx].aflag = pctl->abortflag;
dbugx[dbugxidx].bit   = CAN_TSR(pctl->vcan);
dbugx[dbugxidx].mbx2  = 0xff;
 8002dd0:	64d6      	str	r6, [r2, #76]	; 0x4c
dbugx[dbugxidx].ct    = pctl->txbct;
dbugx[dbugxidx].ct1   = dbugabort[6]; // Number of aborts *handled*
dbugx[dbugxidx].updn = updn;
arbqctr += 1;
dbugx[dbugxidx].arbq = arbqctr;
 8002dd2:	6550      	str	r0, [r2, #84]	; 0x54

dbugxidx += 1; if (dbugxidx >= DBUGXSZ) dbugxidx = 0;
 8002dd4:	1c4a      	adds	r2, r1, #1
 8002dd6:	2a3f      	cmp	r2, #63	; 0x3f
 8002dd8:	bf88      	it	hi
 8002dda:	2200      	movhi	r2, #0
 8002ddc:	639a      	str	r2, [r3, #56]	; 0x38
dbugx[dbugxidx].bit   = CAN_TSR(pctl->vcan);
dbugx[dbugxidx].mbx2  = 0xff;
dbugx[dbugxidx].ct    = pctl->txbct;
dbugx[dbugxidx].ct1   = dbugabort[6]; // Number of aborts *handled*
dbugx[dbugxidx].updn = updn;
arbqctr += 1;
 8002dde:	f8c3 08bc 	str.w	r0, [r3, #2236]	; 0x8bc
dbugx[dbugxidx].arbq = arbqctr;

dbugxidx += 1; if (dbugxidx >= DBUGXSZ) dbugxidx = 0;
dbugx[dbugxidx].idb4 = ~0x2;
 8002de2:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8002de4:	eb05 1543 	add.w	r5, r5, r3, lsl #5
 8002de8:	f06f 0302 	mvn.w	r3, #2
 8002dec:	63eb      	str	r3, [r5, #60]	; 0x3c
dbugx[dbugxidx].idaf = ~0x7;
 8002dee:	f06f 0307 	mvn.w	r3, #7
 8002df2:	642b      	str	r3, [r5, #64]	; 0x40
}

			pctl->abortflag = 1;	// Set flag for interrupt routine use
 8002df4:	2301      	movs	r3, #1
 8002df6:	64e3      	str	r3, [r4, #76]	; 0x4c
reenable_ints(save);  // This could result in next msg being aborted!
 8002df8:	4668      	mov	r0, sp
 8002dfa:	f7ff fce1 	bl	80027c0 <reenable_ints>
			CAN_TSR(pctl->vcan) |= CAN_TSR_ABRQ0;	// Set Abort request for mailbox 0.
 8002dfe:	6822      	ldr	r2, [r4, #0]
 8002e00:	6893      	ldr	r3, [r2, #8]
 8002e02:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002e06:	6093      	str	r3, [r2, #8]
 8002e08:	e002      	b.n	8002e10 <can_driver_put+0x194>
		}
/* &&&&&&&&&&&&&& END ABORT MODS &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& */
#endif
	}

	reenable_ints(save);
 8002e0a:	4668      	mov	r0, sp
 8002e0c:	f7ff fcd8 	bl	80027c0 <reenable_ints>

	return 0;	// Success!
 8002e10:	2000      	movs	r0, #0
}
 8002e12:	b002      	add	sp, #8
 8002e14:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8002e18:	001ffff8 	.word	0x001ffff8
 8002e1c:	20001900 	.word	0x20001900

08002e20 <can_driver_getcount>:
 * @param	: pctla = pointer to control block for CAN module, if a 2nd one used ("b")
 * @param	: pcts = pointer to stucts with current counts for all six possible lists.
 * @return	: free list count
 ******************************************************************************/
u32 can_driver_getcount(struct CAN_CTLBLOCK* pctla, struct CAN_CTLBLOCK* pctlb, struct CAN_BLOCK_CTS* pcts)
{
 8002e20:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8002e22:	4606      	mov	r6, r0
	u32 save[2];	// IER register saved during disable of interrupts
	
	disable_ints(save);	// Disable CAN interrupts so counts don't change
 8002e24:	4668      	mov	r0, sp
 * @param	: pctla = pointer to control block for CAN module, if a 2nd one used ("b")
 * @param	: pcts = pointer to stucts with current counts for all six possible lists.
 * @return	: free list count
 ******************************************************************************/
u32 can_driver_getcount(struct CAN_CTLBLOCK* pctla, struct CAN_CTLBLOCK* pctlb, struct CAN_BLOCK_CTS* pcts)
{
 8002e26:	460d      	mov	r5, r1
 8002e28:	4614      	mov	r4, r2
	u32 save[2];	// IER register saved during disable of interrupts
	
	disable_ints(save);	// Disable CAN interrupts so counts don't change
 8002e2a:	f7ff fc97 	bl	800275c <disable_ints>
	if (pctla != NULL)
 8002e2e:	b136      	cbz	r6, 8002e3e <can_driver_getcount+0x1e>
	{ // Here, first CAN 
		pcts->catx  = pctla->txbct;
 8002e30:	f8d6 3090 	ldr.w	r3, [r6, #144]	; 0x90
 8002e34:	6023      	str	r3, [r4, #0]
		pcts->carx0 = pctla->ptrs0.bct;
 8002e36:	6b73      	ldr	r3, [r6, #52]	; 0x34
 8002e38:	6063      	str	r3, [r4, #4]
		pcts->carx1 = pctla->ptrs1.bct;
 8002e3a:	6c73      	ldr	r3, [r6, #68]	; 0x44
 8002e3c:	60a3      	str	r3, [r4, #8]
	}
	if (pctlb != NULL)
 8002e3e:	b135      	cbz	r5, 8002e4e <can_driver_getcount+0x2e>
	{ // Here, second CAN.
		pcts->cbtx  = pctlb->txbct;
 8002e40:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 8002e44:	60e3      	str	r3, [r4, #12]
		pcts->cbrx0 = pctlb->ptrs0.bct;
 8002e46:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8002e48:	6123      	str	r3, [r4, #16]
		pcts->cbrx1 = pctlb->ptrs1.bct;
 8002e4a:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8002e4c:	6163      	str	r3, [r4, #20]
	}
	reenable_ints(save);
 8002e4e:	4668      	mov	r0, sp
 8002e50:	f7ff fcb6 	bl	80027c0 <reenable_ints>
	return friict;	// Return number of blocks calloc'ed
}
 8002e54:	4b01      	ldr	r3, [pc, #4]	; (8002e5c <can_driver_getcount+0x3c>)
 8002e56:	6898      	ldr	r0, [r3, #8]
 8002e58:	b002      	add	sp, #8
 8002e5a:	bd70      	pop	{r4, r5, r6, pc}
 8002e5c:	20001900 	.word	0x20001900

08002e60 <CAN_TX_IRQHandler>:
  Cleared by software writing a “1” or by hardware on transmission request (TXRQ0 set in
  CAN_TI0R register).
  Clearing this bit clears all the status bits (TXOK0, ALST0 and TERR0) for Mailbox 0.
*/
void CAN_TX_IRQHandler(struct CAN_CTLBLOCK* pctl)
{
 8002e60:	b538      	push	{r3, r4, r5, lr}
	 __attribute__((__unused__))int temp;	// Dummy for readback of hardware registers

if (pctl == pctl1)
 8002e62:	4d65      	ldr	r5, [pc, #404]	; (8002ff8 <CAN_TX_IRQHandler+0x198>)
  Cleared by software writing a “1” or by hardware on transmission request (TXRQ0 set in
  CAN_TI0R register).
  Clearing this bit clears all the status bits (TXOK0, ALST0 and TERR0) for Mailbox 0.
*/
void CAN_TX_IRQHandler(struct CAN_CTLBLOCK* pctl)
{
 8002e64:	4604      	mov	r4, r0
	 __attribute__((__unused__))int temp;	// Dummy for readback of hardware registers

if (pctl == pctl1)
 8002e66:	686b      	ldr	r3, [r5, #4]
 8002e68:	4283      	cmp	r3, r0
 8002e6a:	d12f      	bne.n	8002ecc <CAN_TX_IRQHandler+0x6c>
{
   updn  -= 1;
 8002e6c:	f8b5 28c0 	ldrh.w	r2, [r5, #2240]	; 0x8c0
	dbugx[dbugxidx].updn = updn;
 8002e70:	6ba9      	ldr	r1, [r5, #56]	; 0x38
{
	 __attribute__((__unused__))int temp;	// Dummy for readback of hardware registers

if (pctl == pctl1)
{
   updn  -= 1;
 8002e72:	3a01      	subs	r2, #1
	dbugx[dbugxidx].updn = updn;
 8002e74:	eb05 1341 	add.w	r3, r5, r1, lsl #5
{
	 __attribute__((__unused__))int temp;	// Dummy for readback of hardware registers

if (pctl == pctl1)
{
   updn  -= 1;
 8002e78:	b212      	sxth	r2, r2
	dbugx[dbugxidx].updn = updn;
 8002e7a:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
{
	 __attribute__((__unused__))int temp;	// Dummy for readback of hardware registers

if (pctl == pctl1)
{
   updn  -= 1;
 8002e7e:	f8a5 28c0 	strh.w	r2, [r5, #2240]	; 0x8c0
	dbugx[dbugxidx].updn = updn;

dbugx[dbugxidx].idb4  = CAN_TIxR (pctl->vcan, CAN_MBOX0);
 8002e82:	6802      	ldr	r2, [r0, #0]
 8002e84:	f8d2 0180 	ldr.w	r0, [r2, #384]	; 0x180
 8002e88:	63d8      	str	r0, [r3, #60]	; 0x3c
dbugx[dbugxidx].idaf  = 0xbbbbbbbb;
 8002e8a:	f04f 30bb 	mov.w	r0, #3149642683	; 0xbbbbbbbb
 8002e8e:	6418      	str	r0, [r3, #64]	; 0x40
dbugx[dbugxidx].aflag = pctl->abortflag;
 8002e90:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8002e92:	f8a3 0044 	strh.w	r0, [r3, #68]	; 0x44
dbugx[dbugxidx].mbx2  = 33;
 8002e96:	2021      	movs	r0, #33	; 0x21
 8002e98:	64d8      	str	r0, [r3, #76]	; 0x4c
dbugx[dbugxidx].ct    = pctl->txbct;
 8002e9a:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
 8002e9e:	6518      	str	r0, [r3, #80]	; 0x50
dbugx[dbugxidx].ct1   = dbugabort[6]; // Number of aborts handled
 8002ea0:	f8d5 0854 	ldr.w	r0, [r5, #2132]	; 0x854
 8002ea4:	6498      	str	r0, [r3, #72]	; 0x48
dbugx[dbugxidx].bit   = CAN_TSR(pctl->vcan);
 8002ea6:	6892      	ldr	r2, [r2, #8]
 8002ea8:	659a      	str	r2, [r3, #88]	; 0x58
dbugx[dbugxidx].arbq  = arbqctr;
 8002eaa:	f8d5 28bc 	ldr.w	r2, [r5, #2236]	; 0x8bc
 8002eae:	655a      	str	r2, [r3, #84]	; 0x54
dbugxidx += 1; if (dbugxidx >= DBUGXSZ) dbugxidx = 0;
 8002eb0:	1c4b      	adds	r3, r1, #1
 8002eb2:	2b3f      	cmp	r3, #63	; 0x3f
 8002eb4:	bf88      	it	hi
 8002eb6:	2300      	movhi	r3, #0
 8002eb8:	63ab      	str	r3, [r5, #56]	; 0x38
dbugx[dbugxidx].idb4 = ~0x1f;
 8002eba:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8002ebc:	f06f 021f 	mvn.w	r2, #31
 8002ec0:	eb05 1343 	add.w	r3, r5, r3, lsl #5
 8002ec4:	63da      	str	r2, [r3, #60]	; 0x3c
dbugx[dbugxidx].idaf = ~0xf;
 8002ec6:	f06f 020f 	mvn.w	r2, #15
 8002eca:	641a      	str	r2, [r3, #64]	; 0x40
}

	/* JIC: mailboxes 1 & 2 are not used and should not have a flag */
	if ((CAN_TSR(pctl->vcan) & (CAN_TSR_RQCP1 | CAN_TSR_RQCP2)) != 0)
 8002ecc:	6822      	ldr	r2, [r4, #0]
 8002ece:	4b4b      	ldr	r3, [pc, #300]	; (8002ffc <CAN_TX_IRQHandler+0x19c>)
 8002ed0:	6891      	ldr	r1, [r2, #8]
 8002ed2:	400b      	ands	r3, r1
 8002ed4:	b163      	cbz	r3, 8002ef0 <CAN_TX_IRQHandler+0x90>
	{ // Here, something bogus going on.
		CAN_TSR(pctl->vcan) = (CAN_TSR_RQCP1 | CAN_TSR_RQCP2);	// Turn flags OFF
 8002ed6:	4b49      	ldr	r3, [pc, #292]	; (8002ffc <CAN_TX_IRQHandler+0x19c>)
 8002ed8:	6093      	str	r3, [r2, #8]
		pctl->can_errors.can_cp1cp2 += 1;	// Count: (RQCP1 | RQCP2) unexpectedly ON
 8002eda:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 8002edc:	3301      	adds	r3, #1
 8002ede:	67e3      	str	r3, [r4, #124]	; 0x7c
		temp = CAN_TSR(pctl->vcan);	// JIC Prevent tail-chaining
 8002ee0:	6823      	ldr	r3, [r4, #0]
 8002ee2:	689b      	ldr	r3, [r3, #8]
dbugabort[17] += 1;
 8002ee4:	f8d5 3880 	ldr.w	r3, [r5, #2176]	; 0x880
 8002ee8:	3301      	adds	r3, #1
 8002eea:	f8c5 3880 	str.w	r3, [r5, #2176]	; 0x880
		return;
 8002eee:	bd38      	pop	{r3, r4, r5, pc}
	}

	u32 tsr = CAN_TSR(pctl->vcan);	// Copy of status register mailbox 0 bits

	/* Do this early so it percolates down into the hardware. */
	CAN_TSR(pctl->vcan) = CAN_TSR_RQCP0;	// Clear mailbox 0: RQCP0 (which clears TERR0, ALST0, TXOK0)
 8002ef0:	2101      	movs	r1, #1
		temp = CAN_TSR(pctl->vcan);	// JIC Prevent tail-chaining
dbugabort[17] += 1;
		return;
	}

	u32 tsr = CAN_TSR(pctl->vcan);	// Copy of status register mailbox 0 bits
 8002ef2:	6893      	ldr	r3, [r2, #8]

	/* Do this early so it percolates down into the hardware. */
	CAN_TSR(pctl->vcan) = CAN_TSR_RQCP0;	// Clear mailbox 0: RQCP0 (which clears TERR0, ALST0, TXOK0)
 8002ef4:	6091      	str	r1, [r2, #8]

	/* JIC we got a TX completion when we did not load the mailbox, e.g. initialization. */
	if (pctl->pend.plinknext == NULL) // Is the linked list empty?
 8002ef6:	68a2      	ldr	r2, [r4, #8]
 8002ef8:	b952      	cbnz	r2, 8002f10 <CAN_TX_IRQHandler+0xb0>
	{ // Here, yes.  Something bogus, and never try to remove a block when the list is empty!
		pctl->can_errors.txint_emptylist += 1; // Count: TX interrupt with pending list empty
 8002efa:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 8002efe:	440b      	add	r3, r1
 8002f00:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
dbugabort[14] += 1;
 8002f04:	f8d5 3874 	ldr.w	r3, [r5, #2164]	; 0x874
 8002f08:	440b      	add	r3, r1
 8002f0a:	f8c5 3874 	str.w	r3, [r5, #2164]	; 0x874
		return;
 8002f0e:	bd38      	pop	{r3, r4, r5, pc}
	}

	/* Check for a bogus interrupt. */
	if ( (tsr & CAN_TSR_RQCP0) == 0) // Is mailbox0 RQCP0 (request complete) ON?
 8002f10:	07da      	lsls	r2, r3, #31
 8002f12:	d407      	bmi.n	8002f24 <CAN_TX_IRQHandler+0xc4>
	{ // Here, no RXCPx bits are on, so interrupt is bogus.
		temp = CAN_TSR(pctl->vcan);	// JIC Prevent tail-chaining
 8002f14:	6823      	ldr	r3, [r4, #0]
 8002f16:	689b      	ldr	r3, [r3, #8]
dbugabort[18] += 1;
 8002f18:	f8d5 3884 	ldr.w	r3, [r5, #2180]	; 0x884
 8002f1c:	3301      	adds	r3, #1
 8002f1e:	f8c5 3884 	str.w	r3, [r5, #2180]	; 0x884
		return;
 8002f22:	bd38      	pop	{r3, r4, r5, pc}
	}

	if ((tsr & CAN_TSR_TXOK0) != 0) // TXOK0: Transmission OK for mailbox 0?
 8002f24:	0798      	lsls	r0, r3, #30
 8002f26:	d449      	bmi.n	8002fbc <CAN_TX_IRQHandler+0x15c>
		moveremove2(pctl);	// remove from pending list, add to free list
	}

/* &&&&&&&&&&&&&& BEGIN ABORT MODS &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& */
#ifdef YESABORTCODE
	else if (pctl->abortflag != 0) // Transmission not OK.  Was this due to ABRQ0?
 8002f28:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 8002f2a:	b38a      	cbz	r2, 8002f90 <CAN_TX_IRQHandler+0x130>
	{ // Here, yes.  Do not remove from pending queue
if (pctl == pctl0)
 8002f2c:	682a      	ldr	r2, [r5, #0]
 8002f2e:	4b32      	ldr	r3, [pc, #200]	; (8002ff8 <CAN_TX_IRQHandler+0x198>)
 8002f30:	4294      	cmp	r4, r2
 8002f32:	6822      	ldr	r2, [r4, #0]
 dbugabort[21] = CAN_TIxR (pctl->vcan, CAN_MBOX0);
else
 dbugabort[22] = CAN_TIxR (pctl->vcan, CAN_MBOX0);

		loadmbx2(pctl,5);		// Load mailbox0 with top of pending queue
 8002f34:	4620      	mov	r0, r4
/* &&&&&&&&&&&&&& BEGIN ABORT MODS &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& */
#ifdef YESABORTCODE
	else if (pctl->abortflag != 0) // Transmission not OK.  Was this due to ABRQ0?
	{ // Here, yes.  Do not remove from pending queue
if (pctl == pctl0)
 dbugabort[21] = CAN_TIxR (pctl->vcan, CAN_MBOX0);
 8002f36:	f8d2 2180 	ldr.w	r2, [r2, #384]	; 0x180
else
 dbugabort[22] = CAN_TIxR (pctl->vcan, CAN_MBOX0);

		loadmbx2(pctl,5);		// Load mailbox0 with top of pending queue
 8002f3a:	f04f 0105 	mov.w	r1, #5
/* &&&&&&&&&&&&&& BEGIN ABORT MODS &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& */
#ifdef YESABORTCODE
	else if (pctl->abortflag != 0) // Transmission not OK.  Was this due to ABRQ0?
	{ // Here, yes.  Do not remove from pending queue
if (pctl == pctl0)
 dbugabort[21] = CAN_TIxR (pctl->vcan, CAN_MBOX0);
 8002f3e:	bf0c      	ite	eq
 8002f40:	f8c3 2890 	streq.w	r2, [r3, #2192]	; 0x890
else
 dbugabort[22] = CAN_TIxR (pctl->vcan, CAN_MBOX0);
 8002f44:	f8c3 2894 	strne.w	r2, [r3, #2196]	; 0x894

		loadmbx2(pctl,5);		// Load mailbox0 with top of pending queue
 8002f48:	f7ff fc70 	bl	800282c <loadmbx2>
		pctl->abortflag = 0;

if (pctl == pctl0)
 8002f4c:	682a      	ldr	r2, [r5, #0]
 dbugabort[21] = CAN_TIxR (pctl->vcan, CAN_MBOX0);
else
 dbugabort[22] = CAN_TIxR (pctl->vcan, CAN_MBOX0);

		loadmbx2(pctl,5);		// Load mailbox0 with top of pending queue
		pctl->abortflag = 0;
 8002f4e:	2300      	movs	r3, #0

if (pctl == pctl0)
 8002f50:	4294      	cmp	r4, r2
 dbugabort[21] = CAN_TIxR (pctl->vcan, CAN_MBOX0);
else
 dbugabort[22] = CAN_TIxR (pctl->vcan, CAN_MBOX0);

		loadmbx2(pctl,5);		// Load mailbox0 with top of pending queue
		pctl->abortflag = 0;
 8002f52:	64e3      	str	r3, [r4, #76]	; 0x4c
 8002f54:	6822      	ldr	r2, [r4, #0]

if (pctl == pctl0)
 8002f56:	4b28      	ldr	r3, [pc, #160]	; (8002ff8 <CAN_TX_IRQHandler+0x198>)
 8002f58:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
 8002f5c:	d10b      	bne.n	8002f76 <CAN_TX_IRQHandler+0x116>
{
dbugabort[2] += 1;
 8002f5e:	f8d3 1844 	ldr.w	r1, [r3, #2116]	; 0x844
dbugabort[3] = pctl->txbct;
 8002f62:	f8c3 0848 	str.w	r0, [r3, #2120]	; 0x848
		loadmbx2(pctl,5);		// Load mailbox0 with top of pending queue
		pctl->abortflag = 0;

if (pctl == pctl0)
{
dbugabort[2] += 1;
 8002f66:	3101      	adds	r1, #1
 8002f68:	f8c3 1844 	str.w	r1, [r3, #2116]	; 0x844
dbugabort[3] = pctl->txbct;
dbugabort[13] = CAN_TIxR (pctl->vcan, CAN_MBOX0);
 8002f6c:	f8d2 1180 	ldr.w	r1, [r2, #384]	; 0x180
 8002f70:	f8c3 1870 	str.w	r1, [r3, #2160]	; 0x870
 8002f74:	e00a      	b.n	8002f8c <CAN_TX_IRQHandler+0x12c>
}
else
{
dbugabort[6] += 1;
 8002f76:	f8d3 1854 	ldr.w	r1, [r3, #2132]	; 0x854
dbugabort[7] = pctl->txbct;
 8002f7a:	f8c3 0858 	str.w	r0, [r3, #2136]	; 0x858
dbugabort[3] = pctl->txbct;
dbugabort[13] = CAN_TIxR (pctl->vcan, CAN_MBOX0);
}
else
{
dbugabort[6] += 1;
 8002f7e:	3101      	adds	r1, #1
 8002f80:	f8c3 1854 	str.w	r1, [r3, #2132]	; 0x854
dbugabort[7] = pctl->txbct;
dbugabort[15] = CAN_TIxR (pctl->vcan, CAN_MBOX0);
 8002f84:	f8d2 1180 	ldr.w	r1, [r2, #384]	; 0x180
 8002f88:	f8c3 1878 	str.w	r1, [r3, #2168]	; 0x878
}
		temp = CAN_TSR(pctl->vcan);	// JIC Prevent tail-chaining
 8002f8c:	6893      	ldr	r3, [r2, #8]
		return;		
 8002f8e:	bd38      	pop	{r3, r4, r5, pc}
	}
#endif
/* &&&&&&&&&&&&&& END ABORT MODS &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& */

	else if ((tsr & CAN_TSR_TERR0) != 0) // Transmission error for mailbox 0? 
 8002f90:	0719      	lsls	r1, r3, #28
 8002f92:	d517      	bpl.n	8002fc4 <CAN_TX_IRQHandler+0x164>
	{ // Here, TERR error bit, so try it some more.
		pctl->can_errors.can_txerr += 1; 	// Count total CAN errors
 8002f94:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8002f96:	3301      	adds	r3, #1
 8002f98:	6523      	str	r3, [r4, #80]	; 0x50
		pctl->pxprv->plinknext->x.xb[0] += 1;	// Count errors for this msg
 8002f9a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002f9c:	681a      	ldr	r2, [r3, #0]
 8002f9e:	7e13      	ldrb	r3, [r2, #24]
 8002fa0:	3301      	adds	r3, #1
 8002fa2:	b2db      	uxtb	r3, r3
 8002fa4:	7613      	strb	r3, [r2, #24]
		if (pctl->pxprv->plinknext->x.xb[0] > pctl->pxprv->plinknext->x.xb[1])
 8002fa6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002fa8:	681b      	ldr	r3, [r3, #0]
 8002faa:	7e1a      	ldrb	r2, [r3, #24]
 8002fac:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002fae:	681b      	ldr	r3, [r3, #0]
 8002fb0:	7e5b      	ldrb	r3, [r3, #25]
 8002fb2:	429a      	cmp	r2, r3
 8002fb4:	d917      	bls.n	8002fe6 <CAN_TX_IRQHandler+0x186>
		{ // Here, too many error, remove from list
			pctl->can_errors.can_tx_bombed += 1;	// Number of bombouts
 8002fb6:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8002fb8:	3301      	adds	r3, #1
 8002fba:	6563      	str	r3, [r4, #84]	; 0x54
			moveremove2(pctl);	// Remove msg from pending queue
 8002fbc:	4620      	mov	r0, r4
 8002fbe:	f7ff fcb9 	bl	8002934 <moveremove2>
 8002fc2:	e010      	b.n	8002fe6 <CAN_TX_IRQHandler+0x186>
		}
	}
	else if ((tsr & CAN_TSR_ALST0) != 0) // Arbitration lost for mailbox 0?
 8002fc4:	075a      	lsls	r2, r3, #29
 8002fc6:	d50b      	bpl.n	8002fe0 <CAN_TX_IRQHandler+0x180>
	{ // Here, arbitration for mailbox 0 failed.
		pctl->can_errors.can_tx_alst0_err += 1; // Running ct of arb lost: Mostly for debugging/monitoring
 8002fc8:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8002fca:	3301      	adds	r3, #1
 8002fcc:	65a3      	str	r3, [r4, #88]	; 0x58
		if ((pctl->pxprv->plinknext->x.xb[2] & SOFTNART) != 0)
 8002fce:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002fd0:	681b      	ldr	r3, [r3, #0]
 8002fd2:	7e9b      	ldrb	r3, [r3, #26]
 8002fd4:	07db      	lsls	r3, r3, #31
 8002fd6:	d506      	bpl.n	8002fe6 <CAN_TX_IRQHandler+0x186>
		{ // Here this msg was not to be re-sent, i.e. NART
			pctl->can_errors.can_tx_alst0_nart_err += 1; // Mostly for debugging/monitoring
 8002fd8:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8002fda:	3301      	adds	r3, #1
 8002fdc:	65e3      	str	r3, [r4, #92]	; 0x5c
 8002fde:	e7ed      	b.n	8002fbc <CAN_TX_IRQHandler+0x15c>
			moveremove2(pctl);	// Remove msg from pending queue
		}
	}
	else
	{ // Here, no bits on, therefore something bogus.
		pctl->can_errors.can_no_flagged += 1; // Count for monitoring purposes
 8002fe0:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8002fe2:	3301      	adds	r3, #1
 8002fe4:	66a3      	str	r3, [r4, #104]	; 0x68
	}

	loadmbx2(pctl,7);		// Load mailbox 0.  Mailbox should be available/empty.
 8002fe6:	2107      	movs	r1, #7
 8002fe8:	4620      	mov	r0, r4
 8002fea:	f7ff fc1f 	bl	800282c <loadmbx2>
/* &&&&&&&&&&&&&& BEGIN ABORT MODS &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& */
	pctl->abortflag = 0;
 8002fee:	2300      	movs	r3, #0
 8002ff0:	64e3      	str	r3, [r4, #76]	; 0x4c
/* &&&&&&&&&&&&&& END ABORT MODS &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& */
	temp = CAN_TSR(pctl->vcan);	// JIC Prevent tail-chaining
 8002ff2:	6823      	ldr	r3, [r4, #0]
 8002ff4:	689b      	ldr	r3, [r3, #8]
 8002ff6:	bd38      	pop	{r3, r4, r5, pc}
 8002ff8:	20001900 	.word	0x20001900
 8002ffc:	00010100 	.word	0x00010100

08003000 <CAN_RX_IRQHandler>:
volatile u32 debugT1;
volatile int debugT3;
volatile int debugT2 = 0; //0x7fffffff;

void CAN_RX_IRQHandler(const struct RXIRQPARAM* p, struct CAN_RCV_PTRS* ptrs)
{
 8003000:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 8003004:	4606      	mov	r6, r0
 8003006:	460c      	mov	r4, r1
	u32 save[2];				// Save CAN1 and CAN2 IER registers
	struct CAN_CTLBLOCK* pctl = *p->pctl_addr;// Get control block pointer
 8003008:	6803      	ldr	r3, [r0, #0]
 800300a:	4f35      	ldr	r7, [pc, #212]	; (80030e0 <CAN_RX_IRQHandler+0xe0>)
 800300c:	681d      	ldr	r5, [r3, #0]
	struct CAN_POOLBLOCK* pnew;	// Temp block pointer
	u32 fifo1DTW = DTWTIME;	// Save time of msg arrival
 800300e:	4b35      	ldr	r3, [pc, #212]	; (80030e4 <CAN_RX_IRQHandler+0xe4>)
 8003010:	f8d3 8000 	ldr.w	r8, [r3]
		pnew->can.dlc	   = CAN_RDTxR(pctl->vcan, p->fifo);// time, data length CAN_RDTxR p 663
		pnew->can.cd.ui[0] = CAN_RDLxR(pctl->vcan, p->fifo);// Data (32b) Low
		pnew->can.cd.ui[1] = CAN_RDHxR(pctl->vcan, p->fifo);// Data (32b) High

		/* Release hardware FIFO 0 or 1 */	
		CAN_RFxR(pctl->vcan, p->rfr) = (1 << 5);	// Write bits to release FIFO msg
 8003014:	f04f 0920 	mov.w	r9, #32
	struct CAN_POOLBLOCK* pnew;	// Temp block pointer
	u32 fifo1DTW = DTWTIME;	// Save time of msg arrival

	/* While away any and all FIFO msgs.  This also prevents an interrupt 
		re-entry that has no msg from storing a duplicate msg.  */
	while ((CAN_RFxR(pctl->vcan, p->rfr) & 0x03) != 0)
 8003018:	682a      	ldr	r2, [r5, #0]
 800301a:	68b3      	ldr	r3, [r6, #8]
 800301c:	4413      	add	r3, r2
 800301e:	68db      	ldr	r3, [r3, #12]
 8003020:	4a2f      	ldr	r2, [pc, #188]	; (80030e0 <CAN_RX_IRQHandler+0xe0>)
 8003022:	f013 0f03 	tst.w	r3, #3
 8003026:	d052      	beq.n	80030ce <CAN_RX_IRQHandler+0xce>
	{ // Here, FMPx shows FIFO has one or more msgs.
		/* Get a free block from the free list. */
		disable_ints(save);	// TX or RX(other) interrupts might remove a msg from the free list.
 8003028:	4668      	mov	r0, sp
 800302a:	f7ff fb97 	bl	800275c <disable_ints>
		pnew = (struct CAN_POOLBLOCK*)frii.plinknext; // cast to stop warning that pnew not volatile
 800302e:	f8d7 a018 	ldr.w	sl, [r7, #24]
		if ((pnew == NULL) || (ptrs->bct >= ptrs->bmx))
 8003032:	f1ba 0f00 	cmp.w	sl, #0
 8003036:	d003      	beq.n	8003040 <CAN_RX_IRQHandler+0x40>
 8003038:	68a2      	ldr	r2, [r4, #8]
 800303a:	68e3      	ldr	r3, [r4, #12]
 800303c:	429a      	cmp	r2, r3
 800303e:	db0b      	blt.n	8003058 <CAN_RX_IRQHandler+0x58>
		{ // Here, either no free list blocks OR this RX reached its limit
			CAN_RFxR(pctl->vcan, p->rfr) = (1 << 5);
 8003040:	682a      	ldr	r2, [r5, #0]
 8003042:	68b3      	ldr	r3, [r6, #8]
			pctl->can_errors.can_msgovrflow += 1;	// Count overflows
			reenable_ints(save);
 8003044:	4668      	mov	r0, sp
		/* Get a free block from the free list. */
		disable_ints(save);	// TX or RX(other) interrupts might remove a msg from the free list.
		pnew = (struct CAN_POOLBLOCK*)frii.plinknext; // cast to stop warning that pnew not volatile
		if ((pnew == NULL) || (ptrs->bct >= ptrs->bmx))
		{ // Here, either no free list blocks OR this RX reached its limit
			CAN_RFxR(pctl->vcan, p->rfr) = (1 << 5);
 8003046:	4413      	add	r3, r2
 8003048:	2220      	movs	r2, #32
 800304a:	60da      	str	r2, [r3, #12]
			pctl->can_errors.can_msgovrflow += 1;	// Count overflows
 800304c:	6e2b      	ldr	r3, [r5, #96]	; 0x60
 800304e:	3301      	adds	r3, #1
 8003050:	662b      	str	r3, [r5, #96]	; 0x60
			reenable_ints(save);
 8003052:	f7ff fbb5 	bl	80027c0 <reenable_ints>
			return;	// Return failure: no space & screwed
 8003056:	e03f      	b.n	80030d8 <CAN_RX_IRQHandler+0xd8>
		}	
		frii.plinknext = pnew->plinknext;
 8003058:	f8da 3000 	ldr.w	r3, [sl]
		friict -= 1; 		// Decrement running count of free list inventory
		ptrs->bct += 1;	// Increment running count of of RX pending list
 800305c:	3201      	adds	r2, #1
			CAN_RFxR(pctl->vcan, p->rfr) = (1 << 5);
			pctl->can_errors.can_msgovrflow += 1;	// Count overflows
			reenable_ints(save);
			return;	// Return failure: no space & screwed
		}	
		frii.plinknext = pnew->plinknext;
 800305e:	61bb      	str	r3, [r7, #24]
		friict -= 1; 		// Decrement running count of free list inventory
		ptrs->bct += 1;	// Increment running count of of RX pending list
 8003060:	60a2      	str	r2, [r4, #8]
			pctl->can_errors.can_msgovrflow += 1;	// Count overflows
			reenable_ints(save);
			return;	// Return failure: no space & screwed
		}	
		frii.plinknext = pnew->plinknext;
		friict -= 1; 		// Decrement running count of free list inventory
 8003062:	68bb      	ldr	r3, [r7, #8]
		ptrs->bct += 1;	// Increment running count of of RX pending list

		/* 'pnew' points to the block that is now not linked. */

		/* Copy time stamp and CAN register data to pnew block. */
		pnew->x.xw	   = fifo1DTW;			 // DTW tick time-stamp
 8003064:	f8ca 8018 	str.w	r8, [sl, #24]
		pnew->can.id       = CAN_RIxR (pctl->vcan, p->fifo);// ID, RTR, IDE
 8003068:	6829      	ldr	r1, [r5, #0]
 800306a:	6872      	ldr	r2, [r6, #4]
			pctl->can_errors.can_msgovrflow += 1;	// Count overflows
			reenable_ints(save);
			return;	// Return failure: no space & screwed
		}	
		frii.plinknext = pnew->plinknext;
		friict -= 1; 		// Decrement running count of free list inventory
 800306c:	3b01      	subs	r3, #1
 800306e:	60bb      	str	r3, [r7, #8]

		/* 'pnew' points to the block that is now not linked. */

		/* Copy time stamp and CAN register data to pnew block. */
		pnew->x.xw	   = fifo1DTW;			 // DTW tick time-stamp
		pnew->can.id       = CAN_RIxR (pctl->vcan, p->fifo);// ID, RTR, IDE
 8003070:	188b      	adds	r3, r1, r2
 8003072:	588a      	ldr	r2, [r1, r2]
 8003074:	f8ca 2008 	str.w	r2, [sl, #8]
		pnew->can.dlc	   = CAN_RDTxR(pctl->vcan, p->fifo);// time, data length CAN_RDTxR p 663
 8003078:	685a      	ldr	r2, [r3, #4]
 800307a:	f8ca 200c 	str.w	r2, [sl, #12]
		pnew->can.cd.ui[0] = CAN_RDLxR(pctl->vcan, p->fifo);// Data (32b) Low
 800307e:	689b      	ldr	r3, [r3, #8]
 8003080:	f8ca 3010 	str.w	r3, [sl, #16]
		pnew->can.cd.ui[1] = CAN_RDHxR(pctl->vcan, p->fifo);// Data (32b) High
 8003084:	682a      	ldr	r2, [r5, #0]
 8003086:	6873      	ldr	r3, [r6, #4]
 8003088:	4413      	add	r3, r2
 800308a:	68db      	ldr	r3, [r3, #12]
 800308c:	f8ca 3014 	str.w	r3, [sl, #20]

		/* Release hardware FIFO 0 or 1 */	
		CAN_RFxR(pctl->vcan, p->rfr) = (1 << 5);	// Write bits to release FIFO msg
 8003090:	682a      	ldr	r2, [r5, #0]
 8003092:	68b3      	ldr	r3, [r6, #8]
 8003094:	4413      	add	r3, r2
 8003096:	f8c3 900c 	str.w	r9, [r3, #12]

		if (ptrs->ptail == NULL)
 800309a:	6823      	ldr	r3, [r4, #0]
 800309c:	b923      	cbnz	r3, 80030a8 <CAN_RX_IRQHandler+0xa8>
		{ // Here, list is empty
			ptrs->ptail     = pnew;	// Add to taill
 800309e:	f8c4 a000 	str.w	sl, [r4]
			pnew->plinknext = pnew; // Pt to head
 80030a2:	f8ca a000 	str.w	sl, [sl]
 80030a6:	e008      	b.n	80030ba <CAN_RX_IRQHandler+0xba>
		}		
		else
		{ // Here, one or more is on the list. */
			pnew->plinknext = ptrs->ptail->plinknext; // Move head ptr to new
 80030a8:	6823      	ldr	r3, [r4, #0]
 80030aa:	681b      	ldr	r3, [r3, #0]
 80030ac:	f8ca 3000 	str.w	r3, [sl]
			ptrs->ptail->plinknext = pnew;	// Pt to new tail previous tail block
 80030b0:	6823      	ldr	r3, [r4, #0]
 80030b2:	f8c3 a000 	str.w	sl, [r3]
			ptrs->ptail = pnew; 		// Pt to new tail
 80030b6:	f8c4 a000 	str.w	sl, [r4]
		}
		reenable_ints(save);
 80030ba:	4668      	mov	r0, sp
 80030bc:	f7ff fb80 	bl	80027c0 <reenable_ints>

		/* Extend interrupt processing, if pointer set. */
		if (ptrs->func_rx != NULL)	// Skip if no address is setup
 80030c0:	6863      	ldr	r3, [r4, #4]
 80030c2:	2b00      	cmp	r3, #0
 80030c4:	d0a8      	beq.n	8003018 <CAN_RX_IRQHandler+0x18>
			(*ptrs->func_rx)(pctl, pnew);	// Go do something (like trigger low level int)
 80030c6:	4651      	mov	r1, sl
 80030c8:	4628      	mov	r0, r5
 80030ca:	4798      	blx	r3
 80030cc:	e7a2      	b.n	8003014 <CAN_RX_IRQHandler+0x14>
	}
debugT1 += 1;
 80030ce:	f8d2 38d0 	ldr.w	r3, [r2, #2256]	; 0x8d0
 80030d2:	3301      	adds	r3, #1
 80030d4:	f8c2 38d0 	str.w	r3, [r2, #2256]	; 0x8d0
	return;
}
 80030d8:	b002      	add	sp, #8
 80030da:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80030de:	bf00      	nop
 80030e0:	20001900 	.word	0x20001900
 80030e4:	e0001004 	.word	0xe0001004

080030e8 <CAN1_TX_IRQHandler>:
static const struct RXIRQPARAM can1rx1 = {&pctl0, CAN_FIFO1, CAN_RFR1};
static const struct RXIRQPARAM can2rx0 = {&pctl1, CAN_FIFO0, CAN_RFR0};
static const struct RXIRQPARAM can2rx1 = {&pctl1, CAN_FIFO1, CAN_RFR1};
/* ################### INTERRUPT VECTORS POINT TO THESE ############################################## */
// Pass pointer to 'const' struct, plus pointer to RX0, or RX1 struct (which is not a const)
void CAN1_TX_IRQHandler(void) {return CAN_TX_IRQHandler(pctl0);}
 80030e8:	4b01      	ldr	r3, [pc, #4]	; (80030f0 <CAN1_TX_IRQHandler+0x8>)
 80030ea:	6818      	ldr	r0, [r3, #0]
 80030ec:	f7ff beb8 	b.w	8002e60 <CAN_TX_IRQHandler>
 80030f0:	20001900 	.word	0x20001900

080030f4 <CAN2_TX_IRQHandler>:
void CAN2_TX_IRQHandler(void) {return CAN_TX_IRQHandler(pctl1);}
 80030f4:	4b01      	ldr	r3, [pc, #4]	; (80030fc <CAN2_TX_IRQHandler+0x8>)
 80030f6:	6858      	ldr	r0, [r3, #4]
 80030f8:	f7ff beb2 	b.w	8002e60 <CAN_TX_IRQHandler>
 80030fc:	20001900 	.word	0x20001900

08003100 <CAN1_RX0_IRQHandler>:

void CAN1_RX0_IRQHandler(void){return CAN_RX_IRQHandler(&can1rx0, &pctl0->ptrs0); }
 8003100:	4b02      	ldr	r3, [pc, #8]	; (800310c <CAN1_RX0_IRQHandler+0xc>)
 8003102:	4803      	ldr	r0, [pc, #12]	; (8003110 <CAN1_RX0_IRQHandler+0x10>)
 8003104:	6819      	ldr	r1, [r3, #0]
 8003106:	312c      	adds	r1, #44	; 0x2c
 8003108:	f7ff bf7a 	b.w	8003000 <CAN_RX_IRQHandler>
 800310c:	20001900 	.word	0x20001900
 8003110:	0800411c 	.word	0x0800411c

08003114 <CAN1_RX1_IRQHandler>:
void CAN1_RX1_IRQHandler(void){return CAN_RX_IRQHandler(&can1rx1, &pctl0->ptrs1); }
 8003114:	4b02      	ldr	r3, [pc, #8]	; (8003120 <CAN1_RX1_IRQHandler+0xc>)
 8003116:	4803      	ldr	r0, [pc, #12]	; (8003124 <CAN1_RX1_IRQHandler+0x10>)
 8003118:	6819      	ldr	r1, [r3, #0]
 800311a:	313c      	adds	r1, #60	; 0x3c
 800311c:	f7ff bf70 	b.w	8003000 <CAN_RX_IRQHandler>
 8003120:	20001900 	.word	0x20001900
 8003124:	08004128 	.word	0x08004128

08003128 <CAN2_RX0_IRQHandler>:
void CAN2_RX0_IRQHandler(void){return CAN_RX_IRQHandler(&can2rx0, &pctl1->ptrs0); }
 8003128:	4b02      	ldr	r3, [pc, #8]	; (8003134 <CAN2_RX0_IRQHandler+0xc>)
 800312a:	4803      	ldr	r0, [pc, #12]	; (8003138 <CAN2_RX0_IRQHandler+0x10>)
 800312c:	6859      	ldr	r1, [r3, #4]
 800312e:	312c      	adds	r1, #44	; 0x2c
 8003130:	f7ff bf66 	b.w	8003000 <CAN_RX_IRQHandler>
 8003134:	20001900 	.word	0x20001900
 8003138:	08004134 	.word	0x08004134

0800313c <CAN2_RX1_IRQHandler>:
void CAN2_RX1_IRQHandler(void){return CAN_RX_IRQHandler(&can2rx1, &pctl1->ptrs1); }
 800313c:	4b02      	ldr	r3, [pc, #8]	; (8003148 <CAN2_RX1_IRQHandler+0xc>)
 800313e:	4803      	ldr	r0, [pc, #12]	; (800314c <CAN2_RX1_IRQHandler+0x10>)
 8003140:	6859      	ldr	r1, [r3, #4]
 8003142:	313c      	adds	r1, #60	; 0x3c
 8003144:	f7ff bf5c 	b.w	8003000 <CAN_RX_IRQHandler>
 8003148:	20001900 	.word	0x20001900
 800314c:	08004140 	.word	0x08004140

08003150 <can_driver_port>:
 * @param	: cannum = CAN num (0 or 1, for CAN1 or CAN2)
 * @return	: 0 = success; not zero = failed miserably.
 *		: -1 = cannum: not CAN1 
*******************************************************************************/
int can_driver_port(u8 port, u8 cannum)
{
 8003150:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (cannum != 1) return -1;	// ONLY CAN1 allowed on F103
 8003152:	2901      	cmp	r1, #1
 * @param	: cannum = CAN num (0 or 1, for CAN1 or CAN2)
 * @return	: 0 = success; not zero = failed miserably.
 *		: -1 = cannum: not CAN1 
*******************************************************************************/
int can_driver_port(u8 port, u8 cannum)
{
 8003154:	b08d      	sub	sp, #52	; 0x34
 8003156:	4684      	mov	ip, r0
	if (cannum != 1) return -1;	// ONLY CAN1 allowed on F103
 8003158:	d159      	bne.n	800320e <can_driver_port+0xbe>

	/* Enable clocking to CAN module */
	RCC_APB1ENR |= (1<<25);		// CAN1_EN p 144
 800315a:	4a30      	ldr	r2, [pc, #192]	; (800321c <can_driver_port+0xcc>)
	OLIMEX = 0x2
	*/

/* Output pins configure for alternate function output push-pull */
const struct PINCONFIGALL pa12 = {(volatile u32 *)GPIOA, 12, OUT_AF_PP, MHZ_50};
const struct PINCONFIGALL pb9  = {(volatile u32 *)GPIOB,  9, OUT_AF_PP, MHZ_50};
 800315c:	ae02      	add	r6, sp, #8
int can_driver_port(u8 port, u8 cannum)
{
	if (cannum != 1) return -1;	// ONLY CAN1 allowed on F103

	/* Enable clocking to CAN module */
	RCC_APB1ENR |= (1<<25);		// CAN1_EN p 144
 800315e:	6813      	ldr	r3, [r2, #0]
const struct PINCONFIGALL pa12 = {(volatile u32 *)GPIOA, 12, OUT_AF_PP, MHZ_50};
const struct PINCONFIGALL pb9  = {(volatile u32 *)GPIOB,  9, OUT_AF_PP, MHZ_50};
const struct PINCONFIGALL pd1  = {(volatile u32 *)GPIOD,  1, OUT_AF_PP, MHZ_50};

/* Input pins configure for input pull-up */
const struct PINCONFIGALL pa11 = {(volatile u32 *)GPIOA, 11, IN_PU, 0};
 8003160:	af06      	add	r7, sp, #24
int can_driver_port(u8 port, u8 cannum)
{
	if (cannum != 1) return -1;	// ONLY CAN1 allowed on F103

	/* Enable clocking to CAN module */
	RCC_APB1ENR |= (1<<25);		// CAN1_EN p 144
 8003162:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8003166:	6013      	str	r3, [r2, #0]

	RCC_APB2ENR |= RCC_APB2ENR_AFIOEN;	// enable clock for Alternate Function
 8003168:	f852 3c04 	ldr.w	r3, [r2, #-4]
const struct PINCONFIGALL pb9  = {(volatile u32 *)GPIOB,  9, OUT_AF_PP, MHZ_50};
const struct PINCONFIGALL pd1  = {(volatile u32 *)GPIOD,  1, OUT_AF_PP, MHZ_50};

/* Input pins configure for input pull-up */
const struct PINCONFIGALL pa11 = {(volatile u32 *)GPIOA, 11, IN_PU, 0};
const struct PINCONFIGALL pb8  = {(volatile u32 *)GPIOB,  8, IN_PU, 0};
 800316c:	ad08      	add	r5, sp, #32
	if (cannum != 1) return -1;	// ONLY CAN1 allowed on F103

	/* Enable clocking to CAN module */
	RCC_APB1ENR |= (1<<25);		// CAN1_EN p 144

	RCC_APB2ENR |= RCC_APB2ENR_AFIOEN;	// enable clock for Alternate Function
 800316e:	f043 0301 	orr.w	r3, r3, #1
 8003172:	f842 3c04 	str.w	r3, [r2, #-4]
            11: CAN_RX mapped to PD0, CAN_TX mapped to PD1 
	OLIMEX = 0x2
	*/

/* Output pins configure for alternate function output push-pull */
const struct PINCONFIGALL pa12 = {(volatile u32 *)GPIOA, 12, OUT_AF_PP, MHZ_50};
 8003176:	4b2a      	ldr	r3, [pc, #168]	; (8003220 <can_driver_port+0xd0>)
const struct PINCONFIGALL pd1  = {(volatile u32 *)GPIOD,  1, OUT_AF_PP, MHZ_50};

/* Input pins configure for input pull-up */
const struct PINCONFIGALL pa11 = {(volatile u32 *)GPIOA, 11, IN_PU, 0};
const struct PINCONFIGALL pb8  = {(volatile u32 *)GPIOB,  8, IN_PU, 0};
const struct PINCONFIGALL pd0  = {(volatile u32 *)GPIOD,  0, IN_PU, 0};
 8003178:	ac0a      	add	r4, sp, #40	; 0x28
	OLIMEX = 0x2
	*/

/* Output pins configure for alternate function output push-pull */
const struct PINCONFIGALL pa12 = {(volatile u32 *)GPIOA, 12, OUT_AF_PP, MHZ_50};
const struct PINCONFIGALL pb9  = {(volatile u32 *)GPIOB,  9, OUT_AF_PP, MHZ_50};
 800317a:	f103 0208 	add.w	r2, r3, #8
            11: CAN_RX mapped to PD0, CAN_TX mapped to PD1 
	OLIMEX = 0x2
	*/

/* Output pins configure for alternate function output push-pull */
const struct PINCONFIGALL pa12 = {(volatile u32 *)GPIOA, 12, OUT_AF_PP, MHZ_50};
 800317e:	e893 0003 	ldmia.w	r3, {r0, r1}
 8003182:	e88d 0003 	stmia.w	sp, {r0, r1}
const struct PINCONFIGALL pb9  = {(volatile u32 *)GPIOB,  9, OUT_AF_PP, MHZ_50};
 8003186:	e892 0003 	ldmia.w	r2, {r0, r1}
const struct PINCONFIGALL pd1  = {(volatile u32 *)GPIOD,  1, OUT_AF_PP, MHZ_50};
 800318a:	aa04      	add	r2, sp, #16
	OLIMEX = 0x2
	*/

/* Output pins configure for alternate function output push-pull */
const struct PINCONFIGALL pa12 = {(volatile u32 *)GPIOA, 12, OUT_AF_PP, MHZ_50};
const struct PINCONFIGALL pb9  = {(volatile u32 *)GPIOB,  9, OUT_AF_PP, MHZ_50};
 800318c:	e886 0003 	stmia.w	r6, {r0, r1}
const struct PINCONFIGALL pd1  = {(volatile u32 *)GPIOD,  1, OUT_AF_PP, MHZ_50};
 8003190:	f103 0110 	add.w	r1, r3, #16
 8003194:	c903      	ldmia	r1, {r0, r1}
 8003196:	e882 0003 	stmia.w	r2, {r0, r1}

/* Input pins configure for input pull-up */
const struct PINCONFIGALL pa11 = {(volatile u32 *)GPIOA, 11, IN_PU, 0};
 800319a:	f103 0118 	add.w	r1, r3, #24
 800319e:	c903      	ldmia	r1, {r0, r1}
const struct PINCONFIGALL pb8  = {(volatile u32 *)GPIOB,  8, IN_PU, 0};
const struct PINCONFIGALL pd0  = {(volatile u32 *)GPIOD,  0, IN_PU, 0};

	/* Setup remapping and configure port pins */
	switch (port)
 80031a0:	f1bc 0f01 	cmp.w	ip, #1
const struct PINCONFIGALL pa12 = {(volatile u32 *)GPIOA, 12, OUT_AF_PP, MHZ_50};
const struct PINCONFIGALL pb9  = {(volatile u32 *)GPIOB,  9, OUT_AF_PP, MHZ_50};
const struct PINCONFIGALL pd1  = {(volatile u32 *)GPIOD,  1, OUT_AF_PP, MHZ_50};

/* Input pins configure for input pull-up */
const struct PINCONFIGALL pa11 = {(volatile u32 *)GPIOA, 11, IN_PU, 0};
 80031a4:	e887 0003 	stmia.w	r7, {r0, r1}
const struct PINCONFIGALL pb8  = {(volatile u32 *)GPIOB,  8, IN_PU, 0};
 80031a8:	f103 0120 	add.w	r1, r3, #32
const struct PINCONFIGALL pd0  = {(volatile u32 *)GPIOD,  0, IN_PU, 0};
 80031ac:	f103 0328 	add.w	r3, r3, #40	; 0x28
const struct PINCONFIGALL pb9  = {(volatile u32 *)GPIOB,  9, OUT_AF_PP, MHZ_50};
const struct PINCONFIGALL pd1  = {(volatile u32 *)GPIOD,  1, OUT_AF_PP, MHZ_50};

/* Input pins configure for input pull-up */
const struct PINCONFIGALL pa11 = {(volatile u32 *)GPIOA, 11, IN_PU, 0};
const struct PINCONFIGALL pb8  = {(volatile u32 *)GPIOB,  8, IN_PU, 0};
 80031b0:	c903      	ldmia	r1, {r0, r1}
            11: CAN_RX mapped to PD0, CAN_TX mapped to PD1 
	OLIMEX = 0x2
	*/

/* Output pins configure for alternate function output push-pull */
const struct PINCONFIGALL pa12 = {(volatile u32 *)GPIOA, 12, OUT_AF_PP, MHZ_50};
 80031b2:	46ee      	mov	lr, sp
const struct PINCONFIGALL pb9  = {(volatile u32 *)GPIOB,  9, OUT_AF_PP, MHZ_50};
const struct PINCONFIGALL pd1  = {(volatile u32 *)GPIOD,  1, OUT_AF_PP, MHZ_50};

/* Input pins configure for input pull-up */
const struct PINCONFIGALL pa11 = {(volatile u32 *)GPIOA, 11, IN_PU, 0};
const struct PINCONFIGALL pb8  = {(volatile u32 *)GPIOB,  8, IN_PU, 0};
 80031b4:	e885 0003 	stmia.w	r5, {r0, r1}
const struct PINCONFIGALL pd0  = {(volatile u32 *)GPIOD,  0, IN_PU, 0};
 80031b8:	e893 0003 	ldmia.w	r3, {r0, r1}
 80031bc:	e884 0003 	stmia.w	r4, {r0, r1}

	/* Setup remapping and configure port pins */
	switch (port)
 80031c0:	d018      	beq.n	80031f4 <can_driver_port+0xa4>
 80031c2:	d30d      	bcc.n	80031e0 <can_driver_port+0x90>
 80031c4:	f1bc 0f02 	cmp.w	ip, #2
 80031c8:	d124      	bne.n	8003214 <can_driver_port+0xc4>
		break;

	case 2:	// CAN on port D

		/*  Setup CAN TXD: PD1 for alternate function push/pull output p 156, p 163  */
		pinconfig_all((struct PINCONFIGALL *)&pd1);
 80031ca:	4610      	mov	r0, r2
 80031cc:	f7ff f98a 	bl	80024e4 <pinconfig_all>

		/* Setup CAN RXD: PD0 for input pull up p 164, 167 */
		pinconfig_all((struct PINCONFIGALL *)&pd0);
 80031d0:	4620      	mov	r0, r4
 80031d2:	f7ff f987 	bl	80024e4 <pinconfig_all>

		AFIO_MAPR |= (0x3 << 13);	 // 00: CAN_RX mapped to PA11, CAN_TX mapped to PA12 p 179
 80031d6:	4a13      	ldr	r2, [pc, #76]	; (8003224 <can_driver_port+0xd4>)
 80031d8:	6813      	ldr	r3, [r2, #0]
 80031da:	f443 43c0 	orr.w	r3, r3, #24576	; 0x6000
 80031de:	e013      	b.n	8003208 <can_driver_port+0xb8>
	switch (port)
	{
	case 0:	// CAN on port A

		/*  Setup CAN TXD: PA12 for alternate function push/pull output p 156, p 163  */
		pinconfig_all((struct PINCONFIGALL *)&pa12);
 80031e0:	4668      	mov	r0, sp
 80031e2:	f7ff f97f 	bl	80024e4 <pinconfig_all>

		/* Setup CAN RXD: PB11 for input pull up p 164, 167 */
		pinconfig_all((struct PINCONFIGALL *)&pa11);
 80031e6:	4638      	mov	r0, r7
 80031e8:	f7ff f97c 	bl	80024e4 <pinconfig_all>

		AFIO_MAPR |= (0x0 << 13);	 // 00: CAN_RX mapped to PA11, CAN_TX mapped to PA12 p 179
 80031ec:	4b0d      	ldr	r3, [pc, #52]	; (8003224 <can_driver_port+0xd4>)
 80031ee:	681a      	ldr	r2, [r3, #0]
 80031f0:	601a      	str	r2, [r3, #0]
 80031f2:	e00a      	b.n	800320a <can_driver_port+0xba>
		break;

	case 1:	// CAN on port B

		/*  Setup CAN TXD: PB9 for alternate function push/pull output p 156, p 163  */
		pinconfig_all((struct PINCONFIGALL *)&pb9);
 80031f4:	4630      	mov	r0, r6
 80031f6:	f7ff f975 	bl	80024e4 <pinconfig_all>

		/* Setup CAN RXD: PB8 for input pull up p 164, 167 */
		pinconfig_all((struct PINCONFIGALL *)&pb8);
 80031fa:	4628      	mov	r0, r5
 80031fc:	f7ff f972 	bl	80024e4 <pinconfig_all>

		AFIO_MAPR |= (0x2 << 13);	 // 00: CAN_RX mapped to PA11, CAN_TX mapped to PA12 p 179
 8003200:	4a08      	ldr	r2, [pc, #32]	; (8003224 <can_driver_port+0xd4>)
 8003202:	6813      	ldr	r3, [r2, #0]
 8003204:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
		pinconfig_all((struct PINCONFIGALL *)&pd1);

		/* Setup CAN RXD: PD0 for input pull up p 164, 167 */
		pinconfig_all((struct PINCONFIGALL *)&pd0);

		AFIO_MAPR |= (0x3 << 13);	 // 00: CAN_RX mapped to PA11, CAN_TX mapped to PA12 p 179
 8003208:	6013      	str	r3, [r2, #0]
		break;
	default:
		return -2;
	}
	return 0;
 800320a:	2000      	movs	r0, #0

		/* Setup CAN RXD: PD0 for input pull up p 164, 167 */
		pinconfig_all((struct PINCONFIGALL *)&pd0);

		AFIO_MAPR |= (0x3 << 13);	 // 00: CAN_RX mapped to PA11, CAN_TX mapped to PA12 p 179
		break;
 800320c:	e004      	b.n	8003218 <can_driver_port+0xc8>
 * @return	: 0 = success; not zero = failed miserably.
 *		: -1 = cannum: not CAN1 
*******************************************************************************/
int can_driver_port(u8 port, u8 cannum)
{
	if (cannum != 1) return -1;	// ONLY CAN1 allowed on F103
 800320e:	f04f 30ff 	mov.w	r0, #4294967295
 8003212:	e001      	b.n	8003218 <can_driver_port+0xc8>
		pinconfig_all((struct PINCONFIGALL *)&pd0);

		AFIO_MAPR |= (0x3 << 13);	 // 00: CAN_RX mapped to PA11, CAN_TX mapped to PA12 p 179
		break;
	default:
		return -2;
 8003214:	f06f 0001 	mvn.w	r0, #1
	}
	return 0;
}
 8003218:	b00d      	add	sp, #52	; 0x34
 800321a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800321c:	4002101c 	.word	0x4002101c
 8003220:	0800414c 	.word	0x0800414c
 8003224:	40010004 	.word	0x40010004

08003228 <can_driver_filter_deactivate_one>:
 * @return	:  0 = success; 
 *		: -1 = filter number out of range
*******************************************************************************/
int can_driver_filter_deactivate_one(u8 filtbank)
{
	if ((filtbank > 27) != 0) return -1;
 8003228:	281b      	cmp	r0, #27
 800322a:	d81e      	bhi.n	800326a <can_driver_filter_deactivate_one+0x42>

	/* CAN filter master register */
	while ((CAN_FMR(CAN1) & CAN_FMR_FINIT) != 1) CAN_FMR(CAN1)  |= CAN_FMR_FINIT;	// Set initialization mode ON for setting up filter banks
 800322c:	4b10      	ldr	r3, [pc, #64]	; (8003270 <can_driver_filter_deactivate_one+0x48>)
 800322e:	681a      	ldr	r2, [r3, #0]
 8003230:	07d2      	lsls	r2, r2, #31
 8003232:	d404      	bmi.n	800323e <can_driver_filter_deactivate_one+0x16>
 8003234:	681a      	ldr	r2, [r3, #0]
 8003236:	f042 0201 	orr.w	r2, r2, #1
 800323a:	601a      	str	r2, [r3, #0]
 800323c:	e7f7      	b.n	800322e <can_driver_filter_deactivate_one+0x6>
	CAN_FA1R(CAN1) &= ~(1 << filtbank);
 800323e:	4b0d      	ldr	r3, [pc, #52]	; (8003274 <can_driver_filter_deactivate_one+0x4c>)
 8003240:	2201      	movs	r2, #1
 8003242:	6819      	ldr	r1, [r3, #0]
 8003244:	fa02 f000 	lsl.w	r0, r2, r0
 8003248:	ea21 0200 	bic.w	r2, r1, r0
 800324c:	601a      	str	r2, [r3, #0]
	CAN_FA1R(CAN1) |=  (1 << filtbank);
 800324e:	681a      	ldr	r2, [r3, #0]
	/* Remove filter registers from initialization mode */
	while ((CAN_FMR(CAN1) & CAN_FMR_FINIT) != 0) CAN_FMR(CAN1)  &= ~CAN_FMR_FINIT;	// FINIT = 0; Set initialization mode off for filter banks p 665
 8003250:	3b1c      	subs	r3, #28
	if ((filtbank > 27) != 0) return -1;

	/* CAN filter master register */
	while ((CAN_FMR(CAN1) & CAN_FMR_FINIT) != 1) CAN_FMR(CAN1)  |= CAN_FMR_FINIT;	// Set initialization mode ON for setting up filter banks
	CAN_FA1R(CAN1) &= ~(1 << filtbank);
	CAN_FA1R(CAN1) |=  (1 << filtbank);
 8003252:	4310      	orrs	r0, r2
 8003254:	61d8      	str	r0, [r3, #28]
	/* Remove filter registers from initialization mode */
	while ((CAN_FMR(CAN1) & CAN_FMR_FINIT) != 0) CAN_FMR(CAN1)  &= ~CAN_FMR_FINIT;	// FINIT = 0; Set initialization mode off for filter banks p 665
 8003256:	6818      	ldr	r0, [r3, #0]
 8003258:	f010 0001 	ands.w	r0, r0, #1
 800325c:	d004      	beq.n	8003268 <can_driver_filter_deactivate_one+0x40>
 800325e:	681a      	ldr	r2, [r3, #0]
 8003260:	f022 0201 	bic.w	r2, r2, #1
 8003264:	601a      	str	r2, [r3, #0]
 8003266:	e7f6      	b.n	8003256 <can_driver_filter_deactivate_one+0x2e>
 8003268:	4770      	bx	lr
 * @return	:  0 = success; 
 *		: -1 = filter number out of range
*******************************************************************************/
int can_driver_filter_deactivate_one(u8 filtbank)
{
	if ((filtbank > 27) != 0) return -1;
 800326a:	f04f 30ff 	mov.w	r0, #4294967295
	CAN_FA1R(CAN1) &= ~(1 << filtbank);
	CAN_FA1R(CAN1) |=  (1 << filtbank);
	/* Remove filter registers from initialization mode */
	while ((CAN_FMR(CAN1) & CAN_FMR_FINIT) != 0) CAN_FMR(CAN1)  &= ~CAN_FMR_FINIT;	// FINIT = 0; Set initialization mode off for filter banks p 665
	return 0;
}
 800326e:	4770      	bx	lr
 8003270:	40006600 	.word	0x40006600
 8003274:	4000661c 	.word	0x4000661c

08003278 <can_driver_filter_deactivate_all>:
 * @brief 	: 
 * @param	: filtbank = boundary number ( 0 to < 28d)
*******************************************************************************/
void can_driver_filter_deactivate_all(void)
{
	while ((CAN_FMR(CAN1) & CAN_FMR_FINIT) != 1) CAN_FMR(CAN1)  |= CAN_FMR_FINIT;	// Set initialization mode ON for setting up filter banks
 8003278:	4b0a      	ldr	r3, [pc, #40]	; (80032a4 <can_driver_filter_deactivate_all+0x2c>)
 800327a:	681a      	ldr	r2, [r3, #0]
 800327c:	07d1      	lsls	r1, r2, #31
 800327e:	d404      	bmi.n	800328a <can_driver_filter_deactivate_all+0x12>
 8003280:	681a      	ldr	r2, [r3, #0]
 8003282:	f042 0201 	orr.w	r2, r2, #1
 8003286:	601a      	str	r2, [r3, #0]
 8003288:	e7f7      	b.n	800327a <can_driver_filter_deactivate_all+0x2>
	CAN_FA1R(CAN1) = 0;
 800328a:	4b07      	ldr	r3, [pc, #28]	; (80032a8 <can_driver_filter_deactivate_all+0x30>)
 800328c:	2200      	movs	r2, #0
 800328e:	601a      	str	r2, [r3, #0]
	while ((CAN_FMR(CAN1) & CAN_FMR_FINIT) != 0) CAN_FMR(CAN1)  &= ~CAN_FMR_FINIT;	// FINIT = 0; Set initialization mode off for filter banks p 665
 8003290:	3b1c      	subs	r3, #28
 8003292:	681a      	ldr	r2, [r3, #0]
 8003294:	07d2      	lsls	r2, r2, #31
 8003296:	d504      	bpl.n	80032a2 <can_driver_filter_deactivate_all+0x2a>
 8003298:	681a      	ldr	r2, [r3, #0]
 800329a:	f022 0201 	bic.w	r2, r2, #1
 800329e:	601a      	str	r2, [r3, #0]
 80032a0:	e7f7      	b.n	8003292 <can_driver_filter_deactivate_all+0x1a>
	return;
}
 80032a2:	4770      	bx	lr
 80032a4:	40006600 	.word	0x40006600
 80032a8:	4000661c 	.word	0x4000661c

080032ac <can_driver_filter_setCAN2boundary>:
Setting to 28d means all filters assigned to CAN1.

*/
int can_driver_filter_setCAN2boundary(u8 filtbank)
{
	if ((filtbank > 28) != 0) return -1;
 80032ac:	281c      	cmp	r0, #28
 80032ae:	d820      	bhi.n	80032f2 <can_driver_filter_setCAN2boundary+0x46>

	/* CAN filter master register p 665 */
	while ((CAN_FMR(CAN1) & CAN_FMR_FINIT) != 1) CAN_FMR(CAN1)  |= CAN_FMR_FINIT;	// Set initialization mode ON for setting up filter banks
 80032b0:	4a11      	ldr	r2, [pc, #68]	; (80032f8 <can_driver_filter_setCAN2boundary+0x4c>)
 80032b2:	6811      	ldr	r1, [r2, #0]
 80032b4:	4b10      	ldr	r3, [pc, #64]	; (80032f8 <can_driver_filter_setCAN2boundary+0x4c>)
 80032b6:	07c9      	lsls	r1, r1, #31
 80032b8:	d404      	bmi.n	80032c4 <can_driver_filter_setCAN2boundary+0x18>
 80032ba:	6813      	ldr	r3, [r2, #0]
 80032bc:	f043 0301 	orr.w	r3, r3, #1
 80032c0:	6013      	str	r3, [r2, #0]
 80032c2:	e7f6      	b.n	80032b2 <can_driver_filter_setCAN2boundary+0x6>

	CAN_FMR(CAN1)  &= ~(31 << 8);		// Clear existing boundary
 80032c4:	681a      	ldr	r2, [r3, #0]
 80032c6:	f422 52f8 	bic.w	r2, r2, #7936	; 0x1f00
 80032ca:	601a      	str	r2, [r3, #0]
	CAN_FMR(CAN1)  |= ~( (filtbank & 31) << 8); // Insert new boundary
 80032cc:	6819      	ldr	r1, [r3, #0]
 80032ce:	0202      	lsls	r2, r0, #8
 80032d0:	f402 52f8 	and.w	r2, r2, #7936	; 0x1f00
 80032d4:	ea61 0202 	orn	r2, r1, r2
 80032d8:	601a      	str	r2, [r3, #0]
	filtnum2 = filtbank;		// Working bank number
 80032da:	4a08      	ldr	r2, [pc, #32]	; (80032fc <can_driver_filter_setCAN2boundary+0x50>)
 80032dc:	6010      	str	r0, [r2, #0]
	filtcan2sb = filtbank;		// Update CAN2 start number

	/* Remove filter registers from initialization mode */
	while ((CAN_FMR(CAN1) & CAN_FMR_FINIT) != 0) CAN_FMR(CAN1)  &= ~CAN_FMR_FINIT;	// FINIT = 0; Set initialization mode off for filter banks p 665
 80032de:	6818      	ldr	r0, [r3, #0]
 80032e0:	f010 0001 	ands.w	r0, r0, #1
 80032e4:	d004      	beq.n	80032f0 <can_driver_filter_setCAN2boundary+0x44>
 80032e6:	681a      	ldr	r2, [r3, #0]
 80032e8:	f022 0201 	bic.w	r2, r2, #1
 80032ec:	601a      	str	r2, [r3, #0]
 80032ee:	e7f6      	b.n	80032de <can_driver_filter_setCAN2boundary+0x32>
 80032f0:	4770      	bx	lr
Setting to 28d means all filters assigned to CAN1.

*/
int can_driver_filter_setCAN2boundary(u8 filtbank)
{
	if ((filtbank > 28) != 0) return -1;
 80032f2:	f04f 30ff 	mov.w	r0, #4294967295
	filtcan2sb = filtbank;		// Update CAN2 start number

	/* Remove filter registers from initialization mode */
	while ((CAN_FMR(CAN1) & CAN_FMR_FINIT) != 0) CAN_FMR(CAN1)  &= ~CAN_FMR_FINIT;	// FINIT = 0; Set initialization mode off for filter banks p 665
	return 0;
}
 80032f6:	4770      	bx	lr
 80032f8:	40006600 	.word	0x40006600
 80032fc:	20000848 	.word	0x20000848

08003300 <can_driver_filter_insert>:
NOTE: Caller has to keep track of filter numbers.  This routine inserts the arguments
  without regard to prior use and therefore could overwrite 

*/
int can_driver_filter_insert(struct CANFILTERPARAM* p)
{
 8003300:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (p->filtbank > 27) return -1;	// Out of range
 8003302:	7a43      	ldrb	r3, [r0, #9]
 8003304:	2b1b      	cmp	r3, #27
 8003306:	d87e      	bhi.n	8003406 <can_driver_filter_insert+0x106>
	if (p->filttype >  7) return -2;	// Out of range
 8003308:	7a03      	ldrb	r3, [r0, #8]
 800330a:	2b07      	cmp	r3, #7
 800330c:	d87e      	bhi.n	800340c <can_driver_filter_insert+0x10c>

	/* Extract bits */
	u8 fifo  = (p->filttype >> 2) & 1;	// FIFO 0|1
 800330e:	0899      	lsrs	r1, r3, #2
	u8 scale = (p->filttype >> 1) & 1; 	// 16b|32b mode
 8003310:	f3c3 0540 	ubfx	r5, r3, #1, #1
	u8 mode  = (p->filttype >> 0) & 1;	// mask-id or id-id
 8003314:	f003 0401 	and.w	r4, r3, #1

	/* CAN filter master register */
	// Set initialization mode ON for setting up filter banks
	while ((CAN_FMR(CAN1) & CAN_FMR_FINIT) != 1) CAN_FMR(CAN1)  |= CAN_FMR_FINIT;	
 8003318:	4b3f      	ldr	r3, [pc, #252]	; (8003418 <can_driver_filter_insert+0x118>)
 800331a:	681a      	ldr	r2, [r3, #0]
 800331c:	07d2      	lsls	r2, r2, #31
 800331e:	d404      	bmi.n	800332a <can_driver_filter_insert+0x2a>
 8003320:	681a      	ldr	r2, [r3, #0]
 8003322:	f042 0201 	orr.w	r2, r2, #1
 8003326:	601a      	str	r2, [r3, #0]
 8003328:	e7f7      	b.n	800331a <can_driver_filter_insert+0x1a>
	
	/* Set assigned filter to FIFO 1 or 2. */
	CAN_FFA1R(CAN1) &= ~(   1 << p->filtbank);	// Clear old bit
 800332a:	4a3c      	ldr	r2, [pc, #240]	; (800341c <can_driver_filter_insert+0x11c>)
 800332c:	7a46      	ldrb	r6, [r0, #9]
 800332e:	6817      	ldr	r7, [r2, #0]
 8003330:	2301      	movs	r3, #1
 8003332:	fa03 f606 	lsl.w	r6, r3, r6
 8003336:	ea27 0606 	bic.w	r6, r7, r6
 800333a:	6016      	str	r6, [r2, #0]
	CAN_FFA1R(CAN1) |=  (fifo << p->filtbank);	// Set new bit
 800333c:	7a47      	ldrb	r7, [r0, #9]
 800333e:	6816      	ldr	r6, [r2, #0]
 8003340:	40b9      	lsls	r1, r7
 8003342:	4331      	orrs	r1, r6
 8003344:	6011      	str	r1, [r2, #0]

	/* Set 16 or 32 bit mode */
	CAN_FS1R(CAN1) &= ~(    1 << p->filtbank);	// Clear old bit
 8003346:	7a41      	ldrb	r1, [r0, #9]
 8003348:	f852 6c08 	ldr.w	r6, [r2, #-8]
 800334c:	fa03 f101 	lsl.w	r1, r3, r1
 8003350:	ea26 0101 	bic.w	r1, r6, r1
 8003354:	f842 1c08 	str.w	r1, [r2, #-8]
	CAN_FS1R(CAN1) |=  (scale << p->filtbank);	// Set new bit
 8003358:	7a41      	ldrb	r1, [r0, #9]
 800335a:	f852 6c08 	ldr.w	r6, [r2, #-8]
 800335e:	fa05 f101 	lsl.w	r1, r5, r1
 8003362:	4331      	orrs	r1, r6
 8003364:	f842 1c08 	str.w	r1, [r2, #-8]

	/* Set mode (id mask) or (id id) */
	CAN_FM1R(CAN1) &= ~(   1 << p->filtbank);	// Clear old bit
 8003368:	7a46      	ldrb	r6, [r0, #9]
 800336a:	f852 1c10 	ldr.w	r1, [r2, #-16]
 800336e:	40b3      	lsls	r3, r6
 8003370:	ea21 0303 	bic.w	r3, r1, r3
 8003374:	f842 3c10 	str.w	r3, [r2, #-16]
	CAN_FM1R(CAN1) |=  (mode << p->filtbank);	// Set new bit
 8003378:	7a43      	ldrb	r3, [r0, #9]
 800337a:	f852 1c10 	ldr.w	r1, [r2, #-16]
 800337e:	fa04 f303 	lsl.w	r3, r4, r3
 8003382:	430b      	orrs	r3, r1
 8003384:	f842 3c10 	str.w	r3, [r2, #-16]
 8003388:	7a43      	ldrb	r3, [r0, #9]
 800338a:	6802      	ldr	r2, [r0, #0]

	/* Insert ID and ID/MASK into filter bank. */
	if (scale == 0)
 800338c:	b9ad      	cbnz	r5, 80033ba <can_driver_filter_insert+0xba>
	{ // Here, 16b dual filtering
		if (p->odd != CANFILT_ODD)
 800338e:	7a81      	ldrb	r1, [r0, #10]
		{ // Here, use even 32b register
			CAN_FiR1(CAN1, p->filtbank) = (p->id << 16) | (p->id & 0xffff);
 8003390:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 8003394:	f603 43c8 	addw	r3, r3, #3272	; 0xcc8
	CAN_FM1R(CAN1) |=  (mode << p->filtbank);	// Set new bit

	/* Insert ID and ID/MASK into filter bank. */
	if (scale == 0)
	{ // Here, 16b dual filtering
		if (p->odd != CANFILT_ODD)
 8003398:	2901      	cmp	r1, #1
		{ // Here, use even 32b register
			CAN_FiR1(CAN1, p->filtbank) = (p->id << 16) | (p->id & 0xffff);
 800339a:	b291      	uxth	r1, r2
 800339c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80033a0:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
	CAN_FM1R(CAN1) |=  (mode << p->filtbank);	// Set new bit

	/* Insert ID and ID/MASK into filter bank. */
	if (scale == 0)
	{ // Here, 16b dual filtering
		if (p->odd != CANFILT_ODD)
 80033a4:	d016      	beq.n	80033d4 <can_driver_filter_insert+0xd4>
		{ // Here, use even 32b register
			CAN_FiR1(CAN1, p->filtbank) = (p->id << 16) | (p->id & 0xffff);
 80033a6:	601a      	str	r2, [r3, #0]
			CAN_FiR2(CAN1, p->filtbank) = CAN_NEVERUSEID; // Mask all
 80033a8:	7a43      	ldrb	r3, [r0, #9]
 80033aa:	f04f 32ff 	mov.w	r2, #4294967295
 80033ae:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 80033b2:	f603 43c8 	addw	r3, r3, #3272	; 0xcc8
 80033b6:	00db      	lsls	r3, r3, #3
 80033b8:	e00c      	b.n	80033d4 <can_driver_filter_insert+0xd4>
			CAN_FiR2(CAN1, p->filtbank) = (p->id << 16) | (p->id & 0xffff);
		}
	}
	else
	{ // Here, 32b filtering
		CAN_FiR1(CAN1, p->filtbank) = p->id;		
 80033ba:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 80033be:	f603 43c8 	addw	r3, r3, #3272	; 0xcc8
 80033c2:	00db      	lsls	r3, r3, #3
 80033c4:	601a      	str	r2, [r3, #0]
		CAN_FiR2(CAN1, p->filtbank) = p->idmsk;		
 80033c6:	7a43      	ldrb	r3, [r0, #9]
 80033c8:	6842      	ldr	r2, [r0, #4]
 80033ca:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 80033ce:	f603 43c8 	addw	r3, r3, #3272	; 0xcc8
 80033d2:	00db      	lsls	r3, r3, #3
 80033d4:	605a      	str	r2, [r3, #4]
	}

	/* Activate filter bank */
	CAN_FA1R(CAN1) |=  (1 << p->filtbank);
 80033d6:	4912      	ldr	r1, [pc, #72]	; (8003420 <can_driver_filter_insert+0x120>)
 80033d8:	7a44      	ldrb	r4, [r0, #9]
 80033da:	680a      	ldr	r2, [r1, #0]
 80033dc:	2301      	movs	r3, #1
 80033de:	40a3      	lsls	r3, r4
 80033e0:	4313      	orrs	r3, r2

	/* Remove filter registers from initialization mode */
	// FINIT = 0; Set initialization mode off for filter banks
	while ((CAN_FMR(CAN1) & CAN_FMR_FINIT) != 0) CAN_FMR(CAN1)  &= ~CAN_FMR_FINIT;
 80033e2:	4a0d      	ldr	r2, [pc, #52]	; (8003418 <can_driver_filter_insert+0x118>)
		CAN_FiR1(CAN1, p->filtbank) = p->id;		
		CAN_FiR2(CAN1, p->filtbank) = p->idmsk;		
	}

	/* Activate filter bank */
	CAN_FA1R(CAN1) |=  (1 << p->filtbank);
 80033e4:	600b      	str	r3, [r1, #0]

	/* Remove filter registers from initialization mode */
	// FINIT = 0; Set initialization mode off for filter banks
	while ((CAN_FMR(CAN1) & CAN_FMR_FINIT) != 0) CAN_FMR(CAN1)  &= ~CAN_FMR_FINIT;
 80033e6:	6813      	ldr	r3, [r2, #0]
 80033e8:	f013 0301 	ands.w	r3, r3, #1
 80033ec:	d004      	beq.n	80033f8 <can_driver_filter_insert+0xf8>
 80033ee:	6813      	ldr	r3, [r2, #0]
 80033f0:	f023 0301 	bic.w	r3, r3, #1
 80033f4:	6013      	str	r3, [r2, #0]
 80033f6:	e7f6      	b.n	80033e6 <can_driver_filter_insert+0xe6>

	if (p->filtbank > filtnum1) filtnum1 = p->filtbank;
 80033f8:	4a0a      	ldr	r2, [pc, #40]	; (8003424 <can_driver_filter_insert+0x124>)
 80033fa:	7a41      	ldrb	r1, [r0, #9]
 80033fc:	6810      	ldr	r0, [r2, #0]
 80033fe:	4281      	cmp	r1, r0
 8003400:	d907      	bls.n	8003412 <can_driver_filter_insert+0x112>
 8003402:	6011      	str	r1, [r2, #0]
 8003404:	e005      	b.n	8003412 <can_driver_filter_insert+0x112>
  without regard to prior use and therefore could overwrite 

*/
int can_driver_filter_insert(struct CANFILTERPARAM* p)
{
	if (p->filtbank > 27) return -1;	// Out of range
 8003406:	f04f 30ff 	mov.w	r0, #4294967295
 800340a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (p->filttype >  7) return -2;	// Out of range
 800340c:	f06f 0001 	mvn.w	r0, #1
 8003410:	bdf0      	pop	{r4, r5, r6, r7, pc}
	// FINIT = 0; Set initialization mode off for filter banks
	while ((CAN_FMR(CAN1) & CAN_FMR_FINIT) != 0) CAN_FMR(CAN1)  &= ~CAN_FMR_FINIT;

	if (p->filtbank > filtnum1) filtnum1 = p->filtbank;

	return 0;
 8003412:	4618      	mov	r0, r3
}
 8003414:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003416:	bf00      	nop
 8003418:	40006600 	.word	0x40006600
 800341c:	40006614 	.word	0x40006614
 8003420:	4000661c 	.word	0x4000661c
 8003424:	200021e4 	.word	0x200021e4

08003428 <can_driver_filter_add_one_32b_id>:
*******************************************************************************/
int can_driver_filter_add_one_32b_id(u32 CANnum, u32 id1, u32 fifo)
{
	u32 filtnum;

	if (CANnum > 1) return -2; // Be sure index is reasonable
 8003428:	2801      	cmp	r0, #1
 *		: -2 = CANnum out of bounds
 *		: -3 = fifo out of bounds
 * NOTE: FIFO 0|1 applies to pairs of CAN IDs for the "list mode" (ID-ID)
*******************************************************************************/
int can_driver_filter_add_one_32b_id(u32 CANnum, u32 id1, u32 fifo)
{
 800342a:	b5f0      	push	{r4, r5, r6, r7, lr}
	u32 filtnum;

	if (CANnum > 1) return -2; // Be sure index is reasonable
 800342c:	d849      	bhi.n	80034c2 <can_driver_filter_add_one_32b_id+0x9a>
	if (CANnum == 0) filtnum = filtnum1;
 800342e:	2800      	cmp	r0, #0
 8003430:	d14d      	bne.n	80034ce <can_driver_filter_add_one_32b_id+0xa6>
 8003432:	4b29      	ldr	r3, [pc, #164]	; (80034d8 <can_driver_filter_add_one_32b_id+0xb0>)
 8003434:	681c      	ldr	r4, [r3, #0]
	if (CANnum == 1) filtnum = filtnum2; // CAN2 starts as an offset

	// Set initialization mode ON for setting up filter banks
	while ((CAN_FMR(CAN1) & CAN_FMR_FINIT) != 1) CAN_FMR(CAN1)  |= CAN_FMR_FINIT;		
 8003436:	4b29      	ldr	r3, [pc, #164]	; (80034dc <can_driver_filter_add_one_32b_id+0xb4>)
 8003438:	681d      	ldr	r5, [r3, #0]
 800343a:	07ed      	lsls	r5, r5, #31
 800343c:	d404      	bmi.n	8003448 <can_driver_filter_add_one_32b_id+0x20>
 800343e:	681d      	ldr	r5, [r3, #0]
 8003440:	f045 0501 	orr.w	r5, r5, #1
 8003444:	601d      	str	r5, [r3, #0]
 8003446:	e7f7      	b.n	8003438 <can_driver_filter_add_one_32b_id+0x10>

	if (oe == 0)
 8003448:	4d23      	ldr	r5, [pc, #140]	; (80034d8 <can_driver_filter_add_one_32b_id+0xb0>)
 800344a:	f104 6300 	add.w	r3, r4, #134217728	; 0x8000000
 800344e:	686e      	ldr	r6, [r5, #4]
 8003450:	f603 43c8 	addw	r3, r3, #3272	; 0xcc8
	{ // Load first slot and set 2nd to dummy
		CAN_FiR1(CAN1, filtnum) = id1;
 8003454:	00db      	lsls	r3, r3, #3
	if (CANnum == 1) filtnum = filtnum2; // CAN2 starts as an offset

	// Set initialization mode ON for setting up filter banks
	while ((CAN_FMR(CAN1) & CAN_FMR_FINIT) != 1) CAN_FMR(CAN1)  |= CAN_FMR_FINIT;		

	if (oe == 0)
 8003456:	b916      	cbnz	r6, 800345e <can_driver_filter_add_one_32b_id+0x36>
	{ // Load first slot and set 2nd to dummy
		CAN_FiR1(CAN1, filtnum) = id1;
 8003458:	6019      	str	r1, [r3, #0]
		CAN_FiR2(CAN1, filtnum) = DUMMY;
 800345a:	f06f 0103 	mvn.w	r1, #3
	{ // Load 2nd slot
		CAN_FiR2(CAN1, filtnum) = id1;
	}

	/* Set assigned filter to FIFO 1 or 2. */
	if (fifo > 1) return -3;
 800345e:	2a01      	cmp	r2, #1
		CAN_FiR1(CAN1, filtnum) = id1;
		CAN_FiR2(CAN1, filtnum) = DUMMY;
	}
	else
	{ // Load 2nd slot
		CAN_FiR2(CAN1, filtnum) = id1;
 8003460:	6059      	str	r1, [r3, #4]
	}

	/* Set assigned filter to FIFO 1 or 2. */
	if (fifo > 1) return -3;
 8003462:	d831      	bhi.n	80034c8 <can_driver_filter_add_one_32b_id+0xa0>
	CAN_FFA1R(CAN1) &= ~(1 << filtnum);	// Clear old bit
 8003464:	491e      	ldr	r1, [pc, #120]	; (80034e0 <can_driver_filter_add_one_32b_id+0xb8>)
 8003466:	2601      	movs	r6, #1
 8003468:	680f      	ldr	r7, [r1, #0]
 800346a:	fa06 f304 	lsl.w	r3, r6, r4
 800346e:	ea27 0703 	bic.w	r7, r7, r3
 8003472:	600f      	str	r7, [r1, #0]
	CAN_FFA1R(CAN1) |=  (fifo << filtnum);	// Set new bit
 8003474:	680f      	ldr	r7, [r1, #0]
 8003476:	40a2      	lsls	r2, r4
 8003478:	433a      	orrs	r2, r7
 800347a:	600a      	str	r2, [r1, #0]

	/* Set 32 bit mode */
	CAN_FS1R(CAN1) |= (1 << filtnum);
 800347c:	f851 2c08 	ldr.w	r2, [r1, #-8]
 8003480:	431a      	orrs	r2, r3
 8003482:	f841 2c08 	str.w	r2, [r1, #-8]

	/* Set mode to (id id) */
	CAN_FM1R(CAN1) |= (1 << filtnum);
 8003486:	f851 2c10 	ldr.w	r2, [r1, #-16]
 800348a:	431a      	orrs	r2, r3
 800348c:	f841 2c10 	str.w	r2, [r1, #-16]

	/* Activate filter bank */
	CAN_FA1R(CAN1) |= (1 << filtnum);
 8003490:	688a      	ldr	r2, [r1, #8]
 8003492:	4313      	orrs	r3, r2
 8003494:	608b      	str	r3, [r1, #8]

	/* Next bank number when 2nd slot filled. */
	if (oe != 0)
 8003496:	686a      	ldr	r2, [r5, #4]
 8003498:	4b0f      	ldr	r3, [pc, #60]	; (80034d8 <can_driver_filter_add_one_32b_id+0xb0>)
 800349a:	b132      	cbz	r2, 80034aa <can_driver_filter_add_one_32b_id+0x82>
	{ // Here, 2nd slot was filled, so advance bank number
		oe = 0;
 800349c:	2200      	movs	r2, #0
 800349e:	605a      	str	r2, [r3, #4]
		filtnum += 1;	// Next filter bank
 80034a0:	4434      	add	r4, r6
		if (CANnum == 0) filtnum1 = filtnum; // Update
 80034a2:	b9b0      	cbnz	r0, 80034d2 <can_driver_filter_add_one_32b_id+0xaa>
 80034a4:	601c      	str	r4, [r3, #0]
		oe = 1;	// 2nd slot next
	}

	/* Remove filter registers from initialization mode */
	// FINIT = 0; Set initialization mode off for filter banks
	while ((CAN_FMR(CAN1) & CAN_FMR_FINIT) != 0) CAN_FMR(CAN1)  &= ~CAN_FMR_FINIT;
 80034a6:	4b0d      	ldr	r3, [pc, #52]	; (80034dc <can_driver_filter_add_one_32b_id+0xb4>)
 80034a8:	e001      	b.n	80034ae <can_driver_filter_add_one_32b_id+0x86>
		if (CANnum == 0) filtnum1 = filtnum; // Update
		if (CANnum == 1) filtnum2 = filtnum;
	}
	else
	{ // Here, 1st slot was filled and 2nd has a dummy
		oe = 1;	// 2nd slot next
 80034aa:	605e      	str	r6, [r3, #4]
 80034ac:	e7fb      	b.n	80034a6 <can_driver_filter_add_one_32b_id+0x7e>
	}

	/* Remove filter registers from initialization mode */
	// FINIT = 0; Set initialization mode off for filter banks
	while ((CAN_FMR(CAN1) & CAN_FMR_FINIT) != 0) CAN_FMR(CAN1)  &= ~CAN_FMR_FINIT;
 80034ae:	6818      	ldr	r0, [r3, #0]
 80034b0:	f010 0001 	ands.w	r0, r0, #1
 80034b4:	d004      	beq.n	80034c0 <can_driver_filter_add_one_32b_id+0x98>
 80034b6:	681a      	ldr	r2, [r3, #0]
 80034b8:	f022 0201 	bic.w	r2, r2, #1
 80034bc:	601a      	str	r2, [r3, #0]
 80034be:	e7f6      	b.n	80034ae <can_driver_filter_add_one_32b_id+0x86>
 80034c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
*******************************************************************************/
int can_driver_filter_add_one_32b_id(u32 CANnum, u32 id1, u32 fifo)
{
	u32 filtnum;

	if (CANnum > 1) return -2; // Be sure index is reasonable
 80034c2:	f06f 0001 	mvn.w	r0, #1
 80034c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	{ // Load 2nd slot
		CAN_FiR2(CAN1, filtnum) = id1;
	}

	/* Set assigned filter to FIFO 1 or 2. */
	if (fifo > 1) return -3;
 80034c8:	f06f 0002 	mvn.w	r0, #2
 80034cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
{
	u32 filtnum;

	if (CANnum > 1) return -2; // Be sure index is reasonable
	if (CANnum == 0) filtnum = filtnum1;
	if (CANnum == 1) filtnum = filtnum2; // CAN2 starts as an offset
 80034ce:	4b05      	ldr	r3, [pc, #20]	; (80034e4 <can_driver_filter_add_one_32b_id+0xbc>)
 80034d0:	e7b0      	b.n	8003434 <can_driver_filter_add_one_32b_id+0xc>
	if (oe != 0)
	{ // Here, 2nd slot was filled, so advance bank number
		oe = 0;
		filtnum += 1;	// Next filter bank
		if (CANnum == 0) filtnum1 = filtnum; // Update
		if (CANnum == 1) filtnum2 = filtnum;
 80034d2:	4b04      	ldr	r3, [pc, #16]	; (80034e4 <can_driver_filter_add_one_32b_id+0xbc>)
 80034d4:	e7e6      	b.n	80034a4 <can_driver_filter_add_one_32b_id+0x7c>
 80034d6:	bf00      	nop
 80034d8:	200021e4 	.word	0x200021e4
 80034dc:	40006600 	.word	0x40006600
 80034e0:	40006614 	.word	0x40006614
 80034e4:	20000848 	.word	0x20000848

080034e8 <can_driver_filter_add_two_32b_id>:
 * @param	: banknum = filter bank number
 * @return	:  0 = success; 
 *		: -1 = filter edit failed
*******************************************************************************/
int can_driver_filter_add_two_32b_id(u32 id1, u32 id2, u32 fifo, u32 banknum)
{
 80034e8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80034ea:	4614      	mov	r4, r2
 80034ec:	4607      	mov	r7, r0
 80034ee:	460e      	mov	r6, r1
 80034f0:	b085      	sub	sp, #20
	/* Default definition for pair of CAN IDs */
	struct CANFILTERPARAM filt = {DUMMY, DUMMY, 0, 2, 0};
 80034f2:	4a0c      	ldr	r2, [pc, #48]	; (8003524 <can_driver_filter_add_two_32b_id+0x3c>)
	int ret;

	filt.id = id1;
	filt.idmsk = id2;
	filt.filttype = CANFILT_FIFO0_32b_ID_ID | ((fifo & 0x1) << 2);
 80034f4:	00a4      	lsls	r4, r4, #2
 *		: -1 = filter edit failed
*******************************************************************************/
int can_driver_filter_add_two_32b_id(u32 id1, u32 id2, u32 fifo, u32 banknum)
{
	/* Default definition for pair of CAN IDs */
	struct CANFILTERPARAM filt = {DUMMY, DUMMY, 0, 2, 0};
 80034f6:	ad01      	add	r5, sp, #4

	filt.id = id1;
	filt.idmsk = id2;
	filt.filttype = CANFILT_FIFO0_32b_ID_ID | ((fifo & 0x1) << 2);
	if (banknum > 28) banknum = 28;
	filt.filtbank = banknum;
 80034f8:	2b1c      	cmp	r3, #28
	struct CANFILTERPARAM filt = {DUMMY, DUMMY, 0, 2, 0};
	int ret;

	filt.id = id1;
	filt.idmsk = id2;
	filt.filttype = CANFILT_FIFO0_32b_ID_ID | ((fifo & 0x1) << 2);
 80034fa:	f004 0404 	and.w	r4, r4, #4
 *		: -1 = filter edit failed
*******************************************************************************/
int can_driver_filter_add_two_32b_id(u32 id1, u32 id2, u32 fifo, u32 banknum)
{
	/* Default definition for pair of CAN IDs */
	struct CANFILTERPARAM filt = {DUMMY, DUMMY, 0, 2, 0};
 80034fe:	ca07      	ldmia	r2, {r0, r1, r2}

	filt.id = id1;
	filt.idmsk = id2;
	filt.filttype = CANFILT_FIFO0_32b_ID_ID | ((fifo & 0x1) << 2);
	if (banknum > 28) banknum = 28;
	filt.filtbank = banknum;
 8003500:	bf28      	it	cs
 8003502:	231c      	movcs	r3, #28
 *		: -1 = filter edit failed
*******************************************************************************/
int can_driver_filter_add_two_32b_id(u32 id1, u32 id2, u32 fifo, u32 banknum)
{
	/* Default definition for pair of CAN IDs */
	struct CANFILTERPARAM filt = {DUMMY, DUMMY, 0, 2, 0};
 8003504:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	int ret;

	filt.id = id1;
	filt.idmsk = id2;
	filt.filttype = CANFILT_FIFO0_32b_ID_ID | ((fifo & 0x1) << 2);
 8003508:	f044 0403 	orr.w	r4, r4, #3
	if (banknum > 28) banknum = 28;
	filt.filtbank = banknum;
	ret  = can_driver_filter_insert((struct CANFILTERPARAM*)&filt);
 800350c:	4628      	mov	r0, r5
{
	/* Default definition for pair of CAN IDs */
	struct CANFILTERPARAM filt = {DUMMY, DUMMY, 0, 2, 0};
	int ret;

	filt.id = id1;
 800350e:	9701      	str	r7, [sp, #4]
	filt.idmsk = id2;
 8003510:	9602      	str	r6, [sp, #8]
	filt.filttype = CANFILT_FIFO0_32b_ID_ID | ((fifo & 0x1) << 2);
 8003512:	f88d 400c 	strb.w	r4, [sp, #12]
	if (banknum > 28) banknum = 28;
	filt.filtbank = banknum;
 8003516:	f88d 300d 	strb.w	r3, [sp, #13]
	ret  = can_driver_filter_insert((struct CANFILTERPARAM*)&filt);
 800351a:	f7ff fef1 	bl	8003300 <can_driver_filter_insert>
	return ret;
}
 800351e:	b005      	add	sp, #20
 8003520:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003522:	bf00      	nop
 8003524:	0800417c 	.word	0x0800417c

08003528 <can_driver_filter_add_param_tbl>:
 * @param	: dummy = CAN ID that is a non-table entry, i.e. skip
 * @return	:  0 = success; 
 *		: -1 = filter edit failed
*******************************************************************************/
int can_driver_filter_add_param_tbl(u32* p, u32 CANnum, u32 size, u32 dummy)
{
 8003528:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	unsigned int i;
	int ret = 0;	// return error code
 800352c:	2400      	movs	r4, #0
 * @param	: dummy = CAN ID that is a non-table entry, i.e. skip
 * @return	:  0 = success; 
 *		: -1 = filter edit failed
*******************************************************************************/
int can_driver_filter_add_param_tbl(u32* p, u32 CANnum, u32 size, u32 dummy)
{
 800352e:	4607      	mov	r7, r0
 8003530:	4688      	mov	r8, r1
 8003532:	4616      	mov	r6, r2
 8003534:	4699      	mov	r9, r3
	unsigned int i;
	int ret = 0;	// return error code

	for (i = 0; i < size; i++)
 8003536:	4625      	mov	r5, r4
 8003538:	42b5      	cmp	r5, r6
 800353a:	d00a      	beq.n	8003552 <can_driver_filter_add_param_tbl+0x2a>
	{
		if (*p != dummy) // Skip dummy entries in array
 800353c:	f857 1025 	ldr.w	r1, [r7, r5, lsl #2]
 8003540:	4549      	cmp	r1, r9
 8003542:	d004      	beq.n	800354e <can_driver_filter_add_param_tbl+0x26>
		{
			ret |= can_driver_filter_add_one_32b_id(CANnum, *p, 0);
 8003544:	2200      	movs	r2, #0
 8003546:	4640      	mov	r0, r8
 8003548:	f7ff ff6e 	bl	8003428 <can_driver_filter_add_one_32b_id>
 800354c:	4304      	orrs	r4, r0
int can_driver_filter_add_param_tbl(u32* p, u32 CANnum, u32 size, u32 dummy)
{
	unsigned int i;
	int ret = 0;	// return error code

	for (i = 0; i < size; i++)
 800354e:	3501      	adds	r5, #1
 8003550:	e7f2      	b.n	8003538 <can_driver_filter_add_param_tbl+0x10>
			ret |= can_driver_filter_add_one_32b_id(CANnum, *p, 0);
		}
		p++;
	}
	return ret;
}
 8003552:	4620      	mov	r0, r4
 8003554:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08003558 <can_driver_filter_setbanknum>:
 * @param	: CANnum = 0 for CAN1; 1 for CAN2
 * @param	: oe: 0 = even, 1 = odd (for 32b slot pairs)
 * @param	: banknum = bank number 0-14/28)
*******************************************************************************/
void can_driver_filter_setbanknum(u32 CANnum, u32 setoe, u32 banknum)
{
 8003558:	4b05      	ldr	r3, [pc, #20]	; (8003570 <can_driver_filter_setbanknum+0x18>)
	if (CANnum == 0) filtnum1 = banknum; // Update
 800355a:	b908      	cbnz	r0, 8003560 <can_driver_filter_setbanknum+0x8>
 800355c:	601a      	str	r2, [r3, #0]
 800355e:	e003      	b.n	8003568 <can_driver_filter_setbanknum+0x10>
	if (CANnum == 1) filtnum2 = banknum;
 8003560:	2801      	cmp	r0, #1
 8003562:	bf04      	itt	eq
 8003564:	4803      	ldreq	r0, [pc, #12]	; (8003574 <can_driver_filter_setbanknum+0x1c>)
 8003566:	6002      	streq	r2, [r0, #0]
	oe = setoe & 1;
 8003568:	f001 0101 	and.w	r1, r1, #1
 800356c:	6059      	str	r1, [r3, #4]
 800356e:	4770      	bx	lr
 8003570:	200021e4 	.word	0x200021e4
 8003574:	20000848 	.word	0x20000848

08003578 <can_driver_filter_getbanknum>:
 * @brief 	: Get the current bank number & oe
 * @param	: CANnum = 0 for CAN1; 1 for CAN2
 * @return	: high byte = bank number; low byte = odd/even
*******************************************************************************/
u32 can_driver_filter_getbanknum(u32 CANnum)
{
 8003578:	4a06      	ldr	r2, [pc, #24]	; (8003594 <can_driver_filter_getbanknum+0x1c>)
	u32 filtnum = 0;
	if (CANnum == 0) filtnum = filtnum1;
 800357a:	b908      	cbnz	r0, 8003580 <can_driver_filter_getbanknum+0x8>
 800357c:	6813      	ldr	r3, [r2, #0]
 800357e:	e004      	b.n	800358a <can_driver_filter_getbanknum+0x12>
	if (CANnum == 1) filtnum = filtnum2; // CAN2 starts as an offset
 8003580:	2801      	cmp	r0, #1
 8003582:	bf0a      	itet	eq
 8003584:	4b04      	ldreq	r3, [pc, #16]	; (8003598 <can_driver_filter_getbanknum+0x20>)
 * @param	: CANnum = 0 for CAN1; 1 for CAN2
 * @return	: high byte = bank number; low byte = odd/even
*******************************************************************************/
u32 can_driver_filter_getbanknum(u32 CANnum)
{
	u32 filtnum = 0;
 8003586:	2300      	movne	r3, #0
	if (CANnum == 0) filtnum = filtnum1;
	if (CANnum == 1) filtnum = filtnum2; // CAN2 starts as an offset
 8003588:	681b      	ldreq	r3, [r3, #0]
	return ((filtnum << 8) | oe);
 800358a:	6850      	ldr	r0, [r2, #4]
}
 800358c:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
 8003590:	4770      	bx	lr
 8003592:	bf00      	nop
 8003594:	200021e4 	.word	0x200021e4
 8003598:	20000848 	.word	0x20000848

0800359c <can_driver_hw_filter_list>:
 * @param	: oe = 0 = odd; 1 = even
 * @return	: value
*******************************************************************************/
uint32_t can_driver_hw_filter_list(uint8_t cannumber, int8_t banknum, uint8_t oe)
{
	if (banknum < 0)
 800359c:	2900      	cmp	r1, #0
 800359e:	da07      	bge.n	80035b0 <can_driver_hw_filter_list+0x14>
	{
		if (cannumber == 1) return (filtnum1<<1)|oe;
 80035a0:	2801      	cmp	r0, #1
 80035a2:	bf0c      	ite	eq
 80035a4:	4b0a      	ldreq	r3, [pc, #40]	; (80035d0 <can_driver_hw_filter_list+0x34>)
		return (filtnum2<<1)|oe;
 80035a6:	4b0b      	ldrne	r3, [pc, #44]	; (80035d4 <can_driver_hw_filter_list+0x38>)
 80035a8:	6818      	ldr	r0, [r3, #0]
 80035aa:	ea42 0040 	orr.w	r0, r2, r0, lsl #1
 80035ae:	4770      	bx	lr
 80035b0:	f101 6100 	add.w	r1, r1, #134217728	; 0x8000000
	}

	if (cannumber == 0)
 80035b4:	b920      	cbnz	r0, 80035c0 <can_driver_hw_filter_list+0x24>
	{
		if (oe == 0)
		{
			return CAN_FiR1(CAN1, banknum);
 80035b6:	f601 41c8 	addw	r1, r1, #3272	; 0xcc8
 80035ba:	00c9      	lsls	r1, r1, #3
		return (filtnum2<<1)|oe;
	}

	if (cannumber == 0)
	{
		if (oe == 0)
 80035bc:	b932      	cbnz	r2, 80035cc <can_driver_hw_filter_list+0x30>
 80035be:	e003      	b.n	80035c8 <can_driver_hw_filter_list+0x2c>
		return CAN_FiR2(CAN1, banknum);
	}

		if (oe != 0)
		{
			return CAN_FiR1(CAN2, banknum);
 80035c0:	f601 5148 	addw	r1, r1, #3400	; 0xd48
 80035c4:	00c9      	lsls	r1, r1, #3
			return CAN_FiR1(CAN1, banknum);
		}
		return CAN_FiR2(CAN1, banknum);
	}

		if (oe != 0)
 80035c6:	b10a      	cbz	r2, 80035cc <can_driver_hw_filter_list+0x30>
		{
			return CAN_FiR1(CAN2, banknum);
 80035c8:	6808      	ldr	r0, [r1, #0]
 80035ca:	4770      	bx	lr
		}
		return CAN_FiR2(CAN2, banknum);	
 80035cc:	6848      	ldr	r0, [r1, #4]
}
 80035ce:	4770      	bx	lr
 80035d0:	200021e4 	.word	0x200021e4
 80035d4:	20000848 	.word	0x20000848

080035d8 <can_msg_reset_msg>:
{
	__attribute__((__unused__)) void* x = pctl;	// Get rid of unused warning.

	/* Compare the CAN ID in the msg just received with the UNIT id, and execute a software
   	   forced system reset if they match. */
	if (pblk->can.id == myunitid_local)	// Msg for this unit?
 80035d8:	4b0b      	ldr	r3, [pc, #44]	; (8003608 <can_msg_reset_msg+0x30>)
}
/*#######################################################################################
 * Callled from can_driver.c RX0 or RX1 IRQHandler
 *####################################################################################### */
static void can_msg_reset_msg(void* pctl, struct CAN_POOLBLOCK* pblk)
{
 80035da:	b410      	push	{r4}
	__attribute__((__unused__)) void* x = pctl;	// Get rid of unused warning.

	/* Compare the CAN ID in the msg just received with the UNIT id, and execute a software
   	   forced system reset if they match. */
	if (pblk->can.id == myunitid_local)	// Msg for this unit?
 80035dc:	681a      	ldr	r2, [r3, #0]
 80035de:	688c      	ldr	r4, [r1, #8]
 80035e0:	4294      	cmp	r4, r2
 80035e2:	d10a      	bne.n	80035fa <can_msg_reset_msg+0x22>
	{ // Here, a loader command (data type) for our unitid.  Is this a forced reset to this unit only?
		if ( ((pblk->can.dlc & 0xf) == 1) && (pblk->can.cd.u8[0] == LDR_RESET) )
 80035e4:	68ca      	ldr	r2, [r1, #12]
 80035e6:	f002 020f 	and.w	r2, r2, #15
 80035ea:	2a01      	cmp	r2, #1
 80035ec:	d105      	bne.n	80035fa <can_msg_reset_msg+0x22>
 80035ee:	7c0a      	ldrb	r2, [r1, #16]
 80035f0:	2a08      	cmp	r2, #8
			SCB_AIRCR = (0x5FA << 16) | SCB_AIRCR_SYSRESETREQ;	// Cause a RESET
 80035f2:	bf02      	ittt	eq
 80035f4:	4c05      	ldreq	r4, [pc, #20]	; (800360c <can_msg_reset_msg+0x34>)
 80035f6:	4a06      	ldreq	r2, [pc, #24]	; (8003610 <can_msg_reset_msg+0x38>)
 80035f8:	6014      	streq	r4, [r2, #0]
	}

	/* Call other routines if an address is set up, (e.g. 'can_gps_phasing' that saves the
           DTW tick count stored  in CAN_POOLBLOCK). */
	if (can_msg_reset_ptr != NULL)	// Option here is to chain to other routines
 80035fa:	685b      	ldr	r3, [r3, #4]
 80035fc:	b10b      	cbz	r3, 8003602 <can_msg_reset_msg+0x2a>
		(*can_msg_reset_ptr)(pctl, pblk);	// Go do something else (in a timely manner!)

	return;	
}
 80035fe:	bc10      	pop	{r4}
	}

	/* Call other routines if an address is set up, (e.g. 'can_gps_phasing' that saves the
           DTW tick count stored  in CAN_POOLBLOCK). */
	if (can_msg_reset_ptr != NULL)	// Option here is to chain to other routines
		(*can_msg_reset_ptr)(pctl, pblk);	// Go do something else (in a timely manner!)
 8003600:	4718      	bx	r3

	return;	
}
 8003602:	bc10      	pop	{r4}
 8003604:	4770      	bx	lr
 8003606:	bf00      	nop
 8003608:	200021ec 	.word	0x200021ec
 800360c:	05fa0004 	.word	0x05fa0004
 8003610:	e000ed0c 	.word	0xe000ed0c

08003614 <can_msg_reset_init>:
 * @return	: 0 = OK, -1 failed: RX ptr was not NULL
********************************************************************************/

int can_msg_reset_init (struct CAN_CTLBLOCK* pctl, u32 canid)
{
	myunitid_local = canid;		// Save unit id used for causing RESET
 8003614:	4b02      	ldr	r3, [pc, #8]	; (8003620 <can_msg_reset_init+0xc>)
 8003616:	6019      	str	r1, [r3, #0]

	// 'can_driver.c' 'CAN_RX_IRQHandler' will call to this address
	pctl->ptrs1.func_rx = (void*)&can_msg_reset_msg; // Callback address for CAN RX0 or RX1 handler
 8003618:	4b02      	ldr	r3, [pc, #8]	; (8003624 <can_msg_reset_init+0x10>)
 800361a:	6403      	str	r3, [r0, #64]	; 0x40

	return 0;
}
 800361c:	2000      	movs	r0, #0
 800361e:	4770      	bx	lr
 8003620:	200021ec 	.word	0x200021ec
 8003624:	080035d9 	.word	0x080035d9

08003628 <calloc>:
 8003628:	4b02      	ldr	r3, [pc, #8]	; (8003634 <calloc+0xc>)
 800362a:	460a      	mov	r2, r1
 800362c:	4601      	mov	r1, r0
 800362e:	6818      	ldr	r0, [r3, #0]
 8003630:	f000 b802 	b.w	8003638 <_calloc_r>
 8003634:	20000430 	.word	0x20000430

08003638 <_calloc_r>:
 8003638:	b510      	push	{r4, lr}
 800363a:	fb02 f101 	mul.w	r1, r2, r1
 800363e:	f7fd fd4d 	bl	80010dc <_malloc_r>
 8003642:	4604      	mov	r4, r0
 8003644:	b1d8      	cbz	r0, 800367e <_calloc_r+0x46>
 8003646:	f850 2c04 	ldr.w	r2, [r0, #-4]
 800364a:	f022 0203 	bic.w	r2, r2, #3
 800364e:	3a04      	subs	r2, #4
 8003650:	2a24      	cmp	r2, #36	; 0x24
 8003652:	d818      	bhi.n	8003686 <_calloc_r+0x4e>
 8003654:	2a13      	cmp	r2, #19
 8003656:	d914      	bls.n	8003682 <_calloc_r+0x4a>
 8003658:	2300      	movs	r3, #0
 800365a:	2a1b      	cmp	r2, #27
 800365c:	6003      	str	r3, [r0, #0]
 800365e:	6043      	str	r3, [r0, #4]
 8003660:	d916      	bls.n	8003690 <_calloc_r+0x58>
 8003662:	2a24      	cmp	r2, #36	; 0x24
 8003664:	6083      	str	r3, [r0, #8]
 8003666:	60c3      	str	r3, [r0, #12]
 8003668:	bf11      	iteee	ne
 800366a:	f100 0210 	addne.w	r2, r0, #16
 800366e:	6103      	streq	r3, [r0, #16]
 8003670:	6143      	streq	r3, [r0, #20]
 8003672:	f100 0218 	addeq.w	r2, r0, #24
 8003676:	2300      	movs	r3, #0
 8003678:	6013      	str	r3, [r2, #0]
 800367a:	6053      	str	r3, [r2, #4]
 800367c:	6093      	str	r3, [r2, #8]
 800367e:	4620      	mov	r0, r4
 8003680:	bd10      	pop	{r4, pc}
 8003682:	4602      	mov	r2, r0
 8003684:	e7f7      	b.n	8003676 <_calloc_r+0x3e>
 8003686:	2100      	movs	r1, #0
 8003688:	f000 f806 	bl	8003698 <memset>
 800368c:	4620      	mov	r0, r4
 800368e:	bd10      	pop	{r4, pc}
 8003690:	f100 0208 	add.w	r2, r0, #8
 8003694:	e7ef      	b.n	8003676 <_calloc_r+0x3e>
 8003696:	bf00      	nop

08003698 <memset>:
 8003698:	b470      	push	{r4, r5, r6}
 800369a:	0784      	lsls	r4, r0, #30
 800369c:	d046      	beq.n	800372c <memset+0x94>
 800369e:	1e54      	subs	r4, r2, #1
 80036a0:	2a00      	cmp	r2, #0
 80036a2:	d041      	beq.n	8003728 <memset+0x90>
 80036a4:	b2cd      	uxtb	r5, r1
 80036a6:	4603      	mov	r3, r0
 80036a8:	e002      	b.n	80036b0 <memset+0x18>
 80036aa:	1e62      	subs	r2, r4, #1
 80036ac:	b3e4      	cbz	r4, 8003728 <memset+0x90>
 80036ae:	4614      	mov	r4, r2
 80036b0:	f803 5b01 	strb.w	r5, [r3], #1
 80036b4:	079a      	lsls	r2, r3, #30
 80036b6:	d1f8      	bne.n	80036aa <memset+0x12>
 80036b8:	2c03      	cmp	r4, #3
 80036ba:	d92e      	bls.n	800371a <memset+0x82>
 80036bc:	b2cd      	uxtb	r5, r1
 80036be:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 80036c2:	2c0f      	cmp	r4, #15
 80036c4:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 80036c8:	d919      	bls.n	80036fe <memset+0x66>
 80036ca:	4626      	mov	r6, r4
 80036cc:	f103 0210 	add.w	r2, r3, #16
 80036d0:	3e10      	subs	r6, #16
 80036d2:	2e0f      	cmp	r6, #15
 80036d4:	f842 5c10 	str.w	r5, [r2, #-16]
 80036d8:	f842 5c0c 	str.w	r5, [r2, #-12]
 80036dc:	f842 5c08 	str.w	r5, [r2, #-8]
 80036e0:	f842 5c04 	str.w	r5, [r2, #-4]
 80036e4:	f102 0210 	add.w	r2, r2, #16
 80036e8:	d8f2      	bhi.n	80036d0 <memset+0x38>
 80036ea:	f1a4 0210 	sub.w	r2, r4, #16
 80036ee:	f022 020f 	bic.w	r2, r2, #15
 80036f2:	f004 040f 	and.w	r4, r4, #15
 80036f6:	3210      	adds	r2, #16
 80036f8:	2c03      	cmp	r4, #3
 80036fa:	4413      	add	r3, r2
 80036fc:	d90d      	bls.n	800371a <memset+0x82>
 80036fe:	461e      	mov	r6, r3
 8003700:	4622      	mov	r2, r4
 8003702:	3a04      	subs	r2, #4
 8003704:	2a03      	cmp	r2, #3
 8003706:	f846 5b04 	str.w	r5, [r6], #4
 800370a:	d8fa      	bhi.n	8003702 <memset+0x6a>
 800370c:	1f22      	subs	r2, r4, #4
 800370e:	f022 0203 	bic.w	r2, r2, #3
 8003712:	3204      	adds	r2, #4
 8003714:	4413      	add	r3, r2
 8003716:	f004 0403 	and.w	r4, r4, #3
 800371a:	b12c      	cbz	r4, 8003728 <memset+0x90>
 800371c:	b2c9      	uxtb	r1, r1
 800371e:	441c      	add	r4, r3
 8003720:	f803 1b01 	strb.w	r1, [r3], #1
 8003724:	42a3      	cmp	r3, r4
 8003726:	d1fb      	bne.n	8003720 <memset+0x88>
 8003728:	bc70      	pop	{r4, r5, r6}
 800372a:	4770      	bx	lr
 800372c:	4614      	mov	r4, r2
 800372e:	4603      	mov	r3, r0
 8003730:	e7c2      	b.n	80036b8 <memset+0x20>
 8003732:	bf00      	nop
 8003734:	0a0a0a0d 	.word	0x0a0a0a0d
 8003738:	23232320 	.word	0x23232320
 800373c:	2e2e2023 	.word	0x2e2e2023
 8003740:	52444c2f 	.word	0x52444c2f
 8003744:	45584946 	.word	0x45584946
 8003748:	444f5044 	.word	0x444f5044
 800374c:	5552542f 	.word	0x5552542f
 8003750:	4c2f4b4e 	.word	0x4c2f4b4e
 8003754:	23205244 	.word	0x23205244
 8003758:	20232323 	.word	0x20232323
 800375c:	322f3330 	.word	0x322f3330
 8003760:	30322f39 	.word	0x30322f39
 8003764:	76203831 	.word	0x76203831
 8003768:	0d0a2030 	.word	0x0d0a2030
 800376c:	68202000 	.word	0x68202000
 8003770:	5f6b6c63 	.word	0x5f6b6c63
 8003774:	71657266 	.word	0x71657266
 8003778:	484d2820 	.word	0x484d2820
 800377c:	3a20297a 	.word	0x3a20297a
 8003780:	75392520 	.word	0x75392520
 8003784:	20000d0a 	.word	0x20000d0a
 8003788:	6b6c6370 	.word	0x6b6c6370
 800378c:	72665f31 	.word	0x72665f31
 8003790:	28207165 	.word	0x28207165
 8003794:	297a484d 	.word	0x297a484d
 8003798:	25203a20 	.word	0x25203a20
 800379c:	0d0a7539 	.word	0x0d0a7539
 80037a0:	63702000 	.word	0x63702000
 80037a4:	5f326b6c 	.word	0x5f326b6c
 80037a8:	71657266 	.word	0x71657266
 80037ac:	484d2820 	.word	0x484d2820
 80037b0:	3a20297a 	.word	0x3a20297a
 80037b4:	75392520 	.word	0x75392520
 80037b8:	73000d0a 	.word	0x73000d0a
 80037bc:	6c637379 	.word	0x6c637379
 80037c0:	72665f6b 	.word	0x72665f6b
 80037c4:	28207165 	.word	0x28207165
 80037c8:	297a484d 	.word	0x297a484d
 80037cc:	25203a20 	.word	0x25203a20
 80037d0:	0d0a7539 	.word	0x0d0a7539
 80037d4:	430d0a00 	.word	0x430d0a00
 80037d8:	72746e6f 	.word	0x72746e6f
 80037dc:	732f6c6f 	.word	0x732f6c6f
 80037e0:	75746174 	.word	0x75746174
 80037e4:	65722073 	.word	0x65722073
 80037e8:	74736967 	.word	0x74736967
 80037ec:	28207265 	.word	0x28207265
 80037f0:	5f434352 	.word	0x5f434352
 80037f4:	29525343 	.word	0x29525343
 80037f8:	25203a20 	.word	0x25203a20
 80037fc:	0a783830 	.word	0x0a783830
 8003800:	6f43000d 	.word	0x6f43000d
 8003804:	6f72746e 	.word	0x6f72746e
 8003808:	74732f6c 	.word	0x74732f6c
 800380c:	73757461 	.word	0x73757461
 8003810:	67657220 	.word	0x67657220
 8003814:	65747369 	.word	0x65747369
 8003818:	52282072 	.word	0x52282072
 800381c:	435f4343 	.word	0x435f4343
 8003820:	20295253 	.word	0x20295253
 8003824:	3025203a 	.word	0x3025203a
 8003828:	41207838 	.word	0x41207838
 800382c:	72657466 	.word	0x72657466
 8003830:	564d5220 	.word	0x564d5220
 8003834:	72772046 	.word	0x72772046
 8003838:	65747469 	.word	0x65747469
 800383c:	0a0d0a6e 	.word	0x0a0d0a6e
 8003840:	6e6f4300 	.word	0x6e6f4300
 8003844:	6c6f7274 	.word	0x6c6f7274
 8003848:	6174732f 	.word	0x6174732f
 800384c:	20737574 	.word	0x20737574
 8003850:	69676572 	.word	0x69676572
 8003854:	72657473 	.word	0x72657473
 8003858:	43522820 	.word	0x43522820
 800385c:	53435f43 	.word	0x53435f43
 8003860:	3a202952 	.word	0x3a202952
 8003864:	38302520 	.word	0x38302520
 8003868:	66412078 	.word	0x66412078
 800386c:	20726574 	.word	0x20726574
 8003870:	5257504c 	.word	0x5257504c
 8003874:	69727720 	.word	0x69727720
 8003878:	6e657474 	.word	0x6e657474
 800387c:	000a0d0a 	.word	0x000a0d0a
 8003880:	314e4143 	.word	0x314e4143
 8003884:	696e6920 	.word	0x696e6920
 8003888:	61662074 	.word	0x61662074
 800388c:	64656c69 	.word	0x64656c69
 8003890:	554e203a 	.word	0x554e203a
 8003894:	70204c4c 	.word	0x70204c4c
 8003898:	0d0a7274 	.word	0x0d0a7274
 800389c:	4e414300 	.word	0x4e414300
 80038a0:	696e6920 	.word	0x696e6920
 80038a4:	61662074 	.word	0x61662074
 80038a8:	64656c69 	.word	0x64656c69
 80038ac:	6572203a 	.word	0x6572203a
 80038b0:	6e727574 	.word	0x6e727574
 80038b4:	646f6320 	.word	0x646f6320
 80038b8:	203d2065 	.word	0x203d2065
 80038bc:	0d0a6425 	.word	0x0d0a6425
 80038c0:	69202000 	.word	0x69202000
 80038c4:	202e652e 	.word	0x202e652e
 80038c8:	74696e75 	.word	0x74696e75
 80038cc:	25203a23 	.word	0x25203a23
 80038d0:	000d0a64 	.word	0x000d0a64
 80038d4:	53414c46 	.word	0x53414c46
 80038d8:	49532048 	.word	0x49532048
 80038dc:	203a455a 	.word	0x203a455a
 80038e0:	0d0a6425 	.word	0x0d0a6425
 80038e4:	33752800 	.word	0x33752800
 80038e8:	702a2932 	.word	0x702a2932
 80038ec:	62637263 	.word	0x62637263
 80038f0:	203a6b6c 	.word	0x203a6b6c
 80038f4:	58383025 	.word	0x58383025
 80038f8:	0a000d0a 	.word	0x0a000d0a
 80038fc:	23230a0d 	.word	0x23230a0d
 8003900:	41202323 	.word	0x41202323
 8003904:	666f2074 	.word	0x666f2074
 8003908:	74657366 	.word	0x74657366
 800390c:	38302520 	.word	0x38302520
 8003910:	64612058 	.word	0x64612058
 8003914:	73657264 	.word	0x73657264
 8003918:	30252073 	.word	0x30252073
 800391c:	69205838 	.word	0x69205838
 8003920:	6f622073 	.word	0x6f622073
 8003924:	20737567 	.word	0x20737567
 8003928:	23232323 	.word	0x23232323
 800392c:	000a0d0a 	.word	0x000a0d0a
 8003930:	74697865 	.word	0x74697865
 8003934:	000a      	.short	0x000a
 8003936:	7277      	.short	0x7277
 8003938:	3a6b6c62 	.word	0x3a6b6c62
 800393c:	20642520 	.word	0x20642520
 8003940:	25205825 	.word	0x25205825
 8003944:	30252058 	.word	0x30252058
 8003948:	25205838 	.word	0x25205838
 800394c:	0a583830 	.word	0x0a583830
 8003950:	7277000d 	.word	0x7277000d
 8003954:	3a6b6c62 	.word	0x3a6b6c62
 8003958:	53414320 	.word	0x53414320
 800395c:	3a302045 	.word	0x3a302045
 8003960:	206f6e20 	.word	0x206f6e20
 8003964:	6465656e 	.word	0x6465656e
 8003968:	206f7420 	.word	0x206f7420
 800396c:	74697277 	.word	0x74697277
 8003970:	6c622065 	.word	0x6c622065
 8003974:	0a6b636f 	.word	0x0a6b636f
 8003978:	7277000d 	.word	0x7277000d
 800397c:	3a6b6c62 	.word	0x3a6b6c62
 8003980:	53414320 	.word	0x53414320
 8003984:	3a322045 	.word	0x3a322045
 8003988:	61726520 	.word	0x61726520
 800398c:	62206573 	.word	0x62206573
 8003990:	6b636f6c 	.word	0x6b636f6c
 8003994:	66656220 	.word	0x66656220
 8003998:	2065726f 	.word	0x2065726f
 800399c:	74697277 	.word	0x74697277
 80039a0:	0a676e69 	.word	0x0a676e69
 80039a4:	7277000d 	.word	0x7277000d
 80039a8:	3a6b6c62 	.word	0x3a6b6c62
 80039ac:	53414320 	.word	0x53414320
 80039b0:	3a312045 	.word	0x3a312045
 80039b4:	69727720 	.word	0x69727720
 80039b8:	676e6974 	.word	0x676e6974
 80039bc:	6f6c6220 	.word	0x6f6c6220
 80039c0:	0d0a6b63 	.word	0x0d0a6b63
 80039c4:	62727700 	.word	0x62727700
 80039c8:	203a6b6c 	.word	0x203a6b6c
 80039cc:	5b796170 	.word	0x5b796170
 80039d0:	25205d31 	.word	0x25205d31
 80039d4:	61702058 	.word	0x61702058
 80039d8:	5d325b79 	.word	0x5d325b79
 80039dc:	0a582520 	.word	0x0a582520
 80039e0:	7277000d 	.word	0x7277000d
 80039e4:	3a6b6c62 	.word	0x3a6b6c62
 80039e8:	66656420 	.word	0x66656420
 80039ec:	746c7561 	.word	0x746c7561
 80039f0:	6425203a 	.word	0x6425203a
 80039f4:	46000d0a 	.word	0x46000d0a
 80039f8:	4853414c 	.word	0x4853414c
 80039fc:	4b4c4220 	.word	0x4b4c4220
 8003a00:	455a5320 	.word	0x455a5320
 8003a04:	6425203a 	.word	0x6425203a
 8003a08:	0d0a4b20 	.word	0x0d0a4b20
 8003a0c:	414c4600 	.word	0x414c4600
 8003a10:	48204853 	.word	0x48204853
 8003a14:	44412049 	.word	0x44412049
 8003a18:	203a5244 	.word	0x203a5244
 8003a1c:	58383025 	.word	0x58383025
 8003a20:	43000d0a 	.word	0x43000d0a
 8003a24:	49204e41 	.word	0x49204e41
 8003a28:	0a732744 	.word	0x0a732744
 8003a2c:	4d43000d 	.word	0x4d43000d
 8003a30:	25203a44 	.word	0x25203a44
 8003a34:	0a583830 	.word	0x0a583830
 8003a38:	4452000d 	.word	0x4452000d
 8003a3c:	25203a20 	.word	0x25203a20
 8003a40:	0a583830 	.word	0x0a583830
 8003a44:	5257000d 	.word	0x5257000d
 8003a48:	25203a20 	.word	0x25203a20
 8003a4c:	0a583830 	.word	0x0a583830
 8003a50:	414e000d 	.word	0x414e000d
 8003a54:	3a304b43 	.word	0x3a304b43
 8003a58:	20642520 	.word	0x20642520
 8003a5c:	25205825 	.word	0x25205825
 8003a60:	58252064 	.word	0x58252064
 8003a64:	38302520 	.word	0x38302520
 8003a68:	30252058 	.word	0x30252058
 8003a6c:	0d0a5838 	.word	0x0d0a5838
 8003a70:	43414e00 	.word	0x43414e00
 8003a74:	203a4b31 	.word	0x203a4b31
 8003a78:	25206425 	.word	0x25206425
 8003a7c:	64252058 	.word	0x64252058
 8003a80:	20582520 	.word	0x20582520
 8003a84:	58383025 	.word	0x58383025
 8003a88:	38302520 	.word	0x38302520
 8003a8c:	000d0a58 	.word	0x000d0a58
 8003a90:	64646170 	.word	0x64646170
 8003a94:	6f726320 	.word	0x6f726320
 8003a98:	64657373 	.word	0x64657373
 8003a9c:	6f6c6220 	.word	0x6f6c6220
 8003aa0:	62206b63 	.word	0x62206b63
 8003aa4:	646e756f 	.word	0x646e756f
 8003aa8:	3a797261 	.word	0x3a797261
 8003aac:	38302520 	.word	0x38302520
 8003ab0:	70202058 	.word	0x70202058
 8003ab4:	3a646461 	.word	0x3a646461
 8003ab8:	38302520 	.word	0x38302520
 8003abc:	000d0a78 	.word	0x000d0a78
 8003ac0:	646e6553 	.word	0x646e6553
 8003ac4:	43414e20 	.word	0x43414e20
 8003ac8:	64203a4b 	.word	0x64203a4b
 8003acc:	6e20636c 	.word	0x6e20636c
 8003ad0:	3820746f 	.word	0x3820746f
 8003ad4:	6425203a 	.word	0x6425203a
 8003ad8:	53000d0a 	.word	0x53000d0a
 8003adc:	20646e65 	.word	0x20646e65
 8003ae0:	4b43414e 	.word	0x4b43414e
 8003ae4:	61747320 	.word	0x61747320
 8003ae8:	61207472 	.word	0x61207472
 8003aec:	20726464 	.word	0x20726464
 8003af0:	2074756f 	.word	0x2074756f
 8003af4:	7220666f 	.word	0x7220666f
 8003af8:	65676e61 	.word	0x65676e61
 8003afc:	3025203a 	.word	0x3025203a
 8003b00:	25205838 	.word	0x25205838
 8003b04:	30252058 	.word	0x30252058
 8003b08:	25205838 	.word	0x25205838
 8003b0c:	0a583830 	.word	0x0a583830
 8003b10:	6148000d 	.word	0x6148000d
 8003b14:	43206472 	.word	0x43206472
 8003b18:	6465646f 	.word	0x6465646f
 8003b1c:	64646120 	.word	0x64646120
 8003b20:	73736572 	.word	0x73736572
 8003b24:	65686320 	.word	0x65686320
 8003b28:	6f206b63 	.word	0x6f206b63
 8003b2c:	6f2d7475 	.word	0x6f2d7475
 8003b30:	61722d66 	.word	0x61722d66
 8003b34:	3a65676e 	.word	0x3a65676e
 8003b38:	5f637200 	.word	0x5f637200
 8003b3c:	33637263 	.word	0x33637263
 8003b40:	25203a32 	.word	0x25203a32
 8003b44:	20583830 	.word	0x20583830
 8003b48:	58383025 	.word	0x58383025
 8003b4c:	38302520 	.word	0x38302520
 8003b50:	000d0a58 	.word	0x000d0a58
 8003b54:	646e6553 	.word	0x646e6553
 8003b58:	63726320 	.word	0x63726320
 8003b5c:	3a32332d 	.word	0x3a32332d
 8003b60:	38302520 	.word	0x38302520
 8003b64:	000d0a58 	.word	0x000d0a58
 8003b68:	66203a58 	.word	0x66203a58
 8003b6c:	6873616c 	.word	0x6873616c
 8003b70:	636f6c62 	.word	0x636f6c62
 8003b74:	7a69736b 	.word	0x7a69736b
 8003b78:	25203a65 	.word	0x25203a65
 8003b7c:	58252058 	.word	0x58252058
 8003b80:	20582520 	.word	0x20582520
 8003b84:	0d0a5825 	.word	0x0d0a5825
 8003b88:	3a345200 	.word	0x3a345200
 8003b8c:	61657220 	.word	0x61657220
 8003b90:	64612064 	.word	0x64612064
 8003b94:	203a7264 	.word	0x203a7264
 8003b98:	25205825 	.word	0x25205825
 8003b9c:	58252058 	.word	0x58252058
 8003ba0:	20582520 	.word	0x20582520
 8003ba4:	25205825 	.word	0x25205825
 8003ba8:	000d0a58 	.word	0x000d0a58
 8003bac:	675f6f64 	.word	0x675f6f64
 8003bb0:	72667465 	.word	0x72667465
 8003bb4:	61646d6f 	.word	0x61646d6f
 8003bb8:	65726464 	.word	0x65726464
 8003bbc:	203a7373 	.word	0x203a7373
 8003bc0:	72646461 	.word	0x72646461
 8003bc4:	746f6e20 	.word	0x746f6e20
 8003bc8:	3a4b4f20 	.word	0x3a4b4f20
 8003bcc:	38302520 	.word	0x38302520
 8003bd0:	000d0a58 	.word	0x000d0a58
 8003bd4:	41544547 	.word	0x41544547
 8003bd8:	3a524444 	.word	0x3a524444
 8003bdc:	61657220 	.word	0x61657220
 8003be0:	64612064 	.word	0x64612064
 8003be4:	203a7264 	.word	0x203a7264
 8003be8:	25205825 	.word	0x25205825
 8003bec:	58252058 	.word	0x58252058
 8003bf0:	20582520 	.word	0x20582520
 8003bf4:	0d0a5825 	.word	0x0d0a5825
 8003bf8:	6e657300 	.word	0x6e657300
 8003bfc:	203a3464 	.word	0x203a3464
 8003c00:	25205825 	.word	0x25205825
 8003c04:	58252058 	.word	0x58252058
 8003c08:	20582520 	.word	0x20582520
 8003c0c:	25205825 	.word	0x25205825
 8003c10:	000d0a58 	.word	0x000d0a58
 8003c14:	20544547 	.word	0x20544547
 8003c18:	53414c46 	.word	0x53414c46
 8003c1c:	61205048 	.word	0x61205048
 8003c20:	20726464 	.word	0x20726464
 8003c24:	58252000 	.word	0x58252000
 8003c28:	474f4200 	.word	0x474f4200
 8003c2c:	43205355 	.word	0x43205355
 8003c30:	4320444d 	.word	0x4320444d
 8003c34:	3a45444f 	.word	0x3a45444f
 8003c38:	20582520 	.word	0x20582520
 8003c3c:	58383025 	.word	0x58383025
 8003c40:	20582520 	.word	0x20582520
 8003c44:	38302520 	.word	0x38302520
 8003c48:	30252058 	.word	0x30252058
 8003c4c:	0d0a5838 	.word	0x0d0a5838
	...

08003c58 <msginit>:
 8003c58:	00000060 00000020 00000010 00000008     `... ...........

08003c68 <can_ldr_ready>:
 8003c68:	02a00000 00000001 00000008 00000000     ................

08003c78 <table>:
 8003c78:	08040402 02020202 04040402 02020202     ................

08003c88 <pllmulxtbl>:
 8003c88:	0a080202 12100e0c 1a181614 20201e1c     ..............  

08003c98 <ahbtbl>:
 8003c98:	00010001 00010001 00010001 00010001     ................
 8003ca8:	00040002 00100008 00800040 02000100     ........@.......

08003cb8 <crctable>:
 8003cb8:	00000000 77073096 ee0e612c 990951ba     .....0.w,a...Q..
 8003cc8:	076dc419 706af48f e963a535 9e6495a3     ..m...jp5.c...d.
 8003cd8:	0edb8832 79dcb8a4 e0d5e91e 97d2d988     2......y........
 8003ce8:	09b64c2b 7eb17cbd e7b82d07 90bf1d91     +L...|.~.-......
 8003cf8:	1db71064 6ab020f2 f3b97148 84be41de     d.... .jHq...A..
 8003d08:	1adad47d 6ddde4eb f4d4b551 83d385c7     }......mQ.......
 8003d18:	136c9856 646ba8c0 fd62f97a 8a65c9ec     V.l...kdz.b...e.
 8003d28:	14015c4f 63066cd9 fa0f3d63 8d080df5     O\...l.cc=......
 8003d38:	3b6e20c8 4c69105e d56041e4 a2677172     . n;^.iL.A`.rqg.
 8003d48:	3c03e4d1 4b04d447 d20d85fd a50ab56b     ...<G..K....k...
 8003d58:	35b5a8fa 42b2986c dbbbc9d6 acbcf940     ...5l..B....@...
 8003d68:	32d86ce3 45df5c75 dcd60dcf abd13d59     .l.2u\.E....Y=..
 8003d78:	26d930ac 51de003a c8d75180 bfd06116     .0.&:..Q.Q...a..
 8003d88:	21b4f4b5 56b3c423 cfba9599 b8bda50f     ...!#..V........
 8003d98:	2802b89e 5f058808 c60cd9b2 b10be924     ...(..._....$...
 8003da8:	2f6f7c87 58684c11 c1611dab b6662d3d     .|o/.LhX..a.=-f.
 8003db8:	76dc4190 01db7106 98d220bc efd5102a     .A.v.q... ..*...
 8003dc8:	71b18589 06b6b51f 9fbfe4a5 e8b8d433     ...q........3...
 8003dd8:	7807c9a2 0f00f934 9609a88e e10e9818     ...x4...........
 8003de8:	7f6a0dbb 086d3d2d 91646c97 e6635c01     ..j.-=m..ld..\c.
 8003df8:	6b6b51f4 1c6c6162 856530d8 f262004e     .Qkkbal..0e.N.b.
 8003e08:	6c0695ed 1b01a57b 8208f4c1 f50fc457     ...l{.......W...
 8003e18:	65b0d9c6 12b7e950 8bbeb8ea fcb9887c     ...eP.......|...
 8003e28:	62dd1ddf 15da2d49 8cd37cf3 fbd44c65     ...bI-...|..eL..
 8003e38:	4db26158 3ab551ce a3bc0074 d4bb30e2     Xa.M.Q.:t....0..
 8003e48:	4adfa541 3dd895d7 a4d1c46d d3d6f4fb     A..J...=m.......
 8003e58:	4369e96a 346ed9fc ad678846 da60b8d0     j.iC..n4F.g...`.
 8003e68:	44042d73 33031de5 aa0a4c5f dd0d7cc9     s-.D...3_L...|..
 8003e78:	5005713c 270241aa be0b1010 c90c2086     <q.P.A.'..... ..
 8003e88:	5768b525 206f85b3 b966d409 ce61e49f     %.hW..o ..f...a.
 8003e98:	5edef90e 29d9c998 b0d09822 c7d7a8b4     ...^...)".......
 8003ea8:	59b33d17 2eb40d81 b7bd5c3b c0ba6cad     .=.Y....;\...l..
 8003eb8:	edb88320 9abfb3b6 03b6e20c 74b1d29a      ..............t
 8003ec8:	ead54739 9dd277af 04db2615 73dc1683     9G...w...&.....s
 8003ed8:	e3630b12 94643b84 0d6d6a3e 7a6a5aa8     ..c..;d.>jm..Zjz
 8003ee8:	e40ecf0b 9309ff9d 0a00ae27 7d079eb1     ........'......}
 8003ef8:	f00f9344 8708a3d2 1e01f268 6906c2fe     D.......h......i
 8003f08:	f762575d 806567cb 196c3671 6e6b06e7     ]Wb..ge.q6l...kn
 8003f18:	fed41b76 89d32be0 10da7a5a 67dd4acc     v....+..Zz...J.g
 8003f28:	f9b9df6f 8ebeeff9 17b7be43 60b08ed5     o.......C......`
 8003f38:	d6d6a3e8 a1d1937e 38d8c2c4 4fdff252     ....~......8R..O
 8003f48:	d1bb67f1 a6bc5767 3fb506dd 48b2364b     .g..gW.....?K6.H
 8003f58:	d80d2bda af0a1b4c 36034af6 41047a60     .+..L....J.6`z.A
 8003f68:	df60efc3 a867df55 316e8eef 4669be79     ..`.U.g...n1y.iF
 8003f78:	cb61b38c bc66831a 256fd2a0 5268e236     ..a...f...o%6.hR
 8003f88:	cc0c7795 bb0b4703 220216b9 5505262f     .w...G....."/&.U
 8003f98:	c5ba3bbe b2bd0b28 2bb45a92 5cb36a04     .;..(....Z.+.j.\
 8003fa8:	c2d7ffa7 b5d0cf31 2cd99e8b 5bdeae1d     ....1......,...[
 8003fb8:	9b64c2b0 ec63f226 756aa39c 026d930a     ..d.&.c...ju..m.
 8003fc8:	9c0906a9 eb0e363f 72076785 05005713     ....?6...g.r.W..
 8003fd8:	95bf4a82 e2b87a14 7bb12bae 0cb61b38     .J...z...+.{8...
 8003fe8:	92d28e9b e5d5be0d 7cdcefb7 0bdbdf21     ...........|!...
 8003ff8:	86d3d2d4 f1d4e242 68ddb3f8 1fda836e     ....B......hn...
 8004008:	81be16cd f6b9265b 6fb077e1 18b74777     ....[&...w.owG..
 8004018:	88085ae6 ff0f6a70 66063bca 11010b5c     .Z..pj...;.f\...
 8004028:	8f659eff f862ae69 616bffd3 166ccf45     ..e.i.b...kaE.l.
 8004038:	a00ae278 d70dd2ee 4e048354 3903b3c2     x.......T..N...9
 8004048:	a7672661 d06016f7 4969474d 3e6e77db     a&g...`.MGiI.wn>
 8004058:	aed16a4a d9d65adc 40df0b66 37d83bf0     Jj...Z..f..@.;.7
 8004068:	a9bcae53 debb9ec5 47b2cf7f 30b5ffe9     S..........G...0
 8004078:	bdbdf21c cabac28a 53b39330 24b4a3a6     ........0..S...$
 8004088:	bad03605 cdd70693 54de5729 23d967bf     .6......)W.T.g.#
 8004098:	b3667a2e c4614ab8 5d681b02 2a6f2b94     .zf..Ja...h].+o*
 80040a8:	b40bbe37 c30c8ea1 5a05df1b 2d02ef8d     7..........Z...-

080040b8 <clocks>:
 80040b8:	00010601 00000004 007a1200              ..........z.

080040c4 <params>:
 80040c4:	0007a120 00000001 010d0201 00000100      ...............
 80040d4:	00000013 00000070 00000014 00000070     ....p.......p...
 80040e4:	00000015 00000070                       ....p...

080040ec <fb0>:
 80040ec:	00000000 ff800000 00000006              ............

080040f8 <fb2>:
	...
 8004100:	00000202                                ....

08004104 <led21green>:
 8004104:	40010c00 0002000f                       ...@....

0800410c <led20red>:
 800410c:	40011000 00020005                       ...@....

08004114 <led19red>:
 8004114:	40011000 00020004                       ...@....

0800411c <can1rx0>:
 800411c:	20001900 000001b0 00000000              ... ........

08004128 <can1rx1>:
 8004128:	20001900 000001c0 00000004              ... ........

08004134 <can2rx0>:
 8004134:	20001904 000001b0 00000000              ... ........

08004140 <can2rx1>:
 8004140:	20001904 000001c0 00000004 40010800     ... ...........@
 8004150:	0003020c 40010c00 00030209 40011400     .......@.......@
 8004160:	00030201 40010800 0000070b 40010c00     .......@.......@
 8004170:	00000708 40011400 00000700 fffffffc     .......@........
 8004180:	fffffffc 00000200                       ........
