
ldr:     file format elf32-littlearm


Disassembly of section .flash:

08000000 <vector_table>:
 8000000:	fc 4f 00 20 b5 1b 00 08 69 01 00 08 63 01 00 08     .O. ....i...c...
 8000010:	5d 01 00 08 57 01 00 08 51 01 00 08 00 00 00 00     ]...W...Q.......
	...
 800002c:	69 01 00 08 69 01 00 08 00 00 00 00 69 01 00 08     i...i.......i...
 800003c:	69 01 00 08 69 01 00 08 69 01 00 08 69 01 00 08     i...i...i...i...
 800004c:	00 00 00 00 69 01 00 08 69 01 00 08 69 01 00 08     ....i...i...i...
 800005c:	69 01 00 08 69 01 00 08 69 01 00 08 69 01 00 08     i...i...i...i...
 800006c:	69 01 00 08 00 00 00 00 69 01 00 08 69 01 00 08     i.......i...i...
 800007c:	00 00 00 00 69 01 00 08 69 01 00 08 69 01 00 08     ....i...i...i...
 800008c:	09 2f 00 08 21 2f 00 08 35 2f 00 08 69 01 00 08     ./..!/..5/..i...
 800009c:	69 01 00 08 69 01 00 08 69 01 00 08 69 01 00 08     i...i...i...i...
 80000ac:	69 01 00 08 69 01 00 08 00 00 00 00 69 01 00 08     i...i.......i...
 80000bc:	69 01 00 08 69 01 00 08 69 01 00 08 69 01 00 08     i...i...i...i...
 80000cc:	69 01 00 08 00 00 00 00 81 1c 00 08 69 01 00 08     i...........i...
 80000dc:	69 01 00 08 69 01 00 08 00 00 00 00 69 01 00 08     i...i.......i...
 80000ec:	69 01 00 08 69 01 00 08 69 01 00 08 69 01 00 08     i...i...i...i...
 80000fc:	69 01 00 08 69 01 00 08 69 01 00 08 69 01 00 08     i...i...i...i...
 800010c:	69 01 00 08 00 00 00 00 00 00 00 00 69 01 00 08     i...........i...
 800011c:	69 01 00 08 69 01 00 08 69 01 00 08 69 01 00 08     i...i...i...i...
 800012c:	00 00 00 00                                         ....

08000130 <unique_can_block>:
extern const void* __appoffset;

__attribute__ ((section(".vectors")))

void unique_can_block(void)
{
 8000130:	b508      	push	{r3, lr}
	Reset_Handler();
 8000132:	f001 fd3f 	bl	8001bb4 <Reset_Handler>
 8000136:	e7fe      	b.n	8000136 <unique_can_block+0x6>

08000138 <fixedaddress>:
 8000138:	0000 0240 0003 0000 2199 0800 0000 0000     ..@......!......
	...

08000150 <usage_fault_handler>:
	panic_leds_pod(3);
//	while (1) ;
}
void usage_fault_handler(void)
{
	panic_leds_pod(4);
 8000150:	2004      	movs	r0, #4
 8000152:	f002 b89c 	b.w	800228e <panic_leds_pod>

08000156 <bus_fault_handler>:
	panic_leds_pod(2);
//	while (1) ;
}
void bus_fault_handler(void)
{
	panic_leds_pod(3);
 8000156:	2003      	movs	r0, #3
 8000158:	f002 b899 	b.w	800228e <panic_leds_pod>

0800015c <mem_manage_handler>:
	panic_leds_pod(1);
//	while (1) ;
}
void mem_manage_handler(void)
{
	panic_leds_pod(2);
 800015c:	2002      	movs	r0, #2
 800015e:	f002 b896 	b.w	800228e <panic_leds_pod>

08000162 <hard_fault_handler>:
	DMA2CH4_IRQHandler,	//dma2_channel4_5_isr,
};

void hard_fault_handler(void)
{
	panic_leds_pod(1);
 8000162:	2001      	movs	r0, #1
 8000164:	f002 b893 	b.w	800228e <panic_leds_pod>

08000168 <null_handler>:
//	while (1) ;
}

void null_handler(void)
{
	panic_leds_pod(5);
 8000168:	2005      	movs	r0, #5
 800016a:	f002 b890 	b.w	800228e <panic_leds_pod>

0800016e <relocate_vector>:
//	{
//		*pram++ = *pflash++;
//	}
	
	/* Disable all interrupts */
	NVIC_ICER(0) = -1;
 800016e:	4a05      	ldr	r2, [pc, #20]	; (8000184 <relocate_vector+0x16>)
 8000170:	f04f 33ff 	mov.w	r3, #4294967295
 8000174:	6013      	str	r3, [r2, #0]
	NVIC_ICER(1) = -1;
 8000176:	6053      	str	r3, [r2, #4]
	NVIC_ICER(2) = -1;
 8000178:	6093      	str	r3, [r2, #8]

	/* Reset stack pointer */
	
	/* Move vector to beginning of sram*/
//	SCB_VTOR  = (1<<29);
	SCB_VTOR = (unsigned int)vector_table;
 800017a:	4b03      	ldr	r3, [pc, #12]	; (8000188 <relocate_vector+0x1a>)
 800017c:	4a03      	ldr	r2, [pc, #12]	; (800018c <relocate_vector+0x1e>)
 800017e:	601a      	str	r2, [r3, #0]

	return;
}
 8000180:	4770      	bx	lr
 8000182:	bf00      	nop
 8000184:	e000e180 	.word	0xe000e180
 8000188:	e000ed08 	.word	0xe000ed08
 800018c:	08000000 	.word	0x08000000

08000190 <putc>:
// Note: the compiler will give a warning about conflicting types
// for the built in function 'putc'.  Use ' -fno-builtin-putc' to eliminate compile warning.
void putc ( void* p, char c)
	{
		p=p;	// Get rid of the unused variable compiler warning
		USART1_txint_putc(c);
 8000190:	4608      	mov	r0, r1
 8000192:	f001 bdab 	b.w	8001cec <USART1_txint_putc>

08000196 <system_reset>:
      This bit reads as 0.
      0: No system reset request
      1: Asserts a signal to the outer system that requests a reset.
*/
//	SCB_AIRCR = (0x5FA << 16) | SCB_AIRCR_SYSRESETREQ;	// Cause a RESET
	SCB_AIRCR = (0x5FA << 16) | 0x4;	// Cause a RESET
 8000196:	4a02      	ldr	r2, [pc, #8]	; (80001a0 <system_reset+0xa>)
 8000198:	4b02      	ldr	r3, [pc, #8]	; (80001a4 <system_reset+0xe>)
 800019a:	601a      	str	r2, [r3, #0]
 800019c:	e7fe      	b.n	800019c <system_reset+0x6>
 800019e:	bf00      	nop
 80001a0:	05fa0004 	.word	0x05fa0004
 80001a4:	e000ed0c 	.word	0xe000ed0c

080001a8 <toggle_1led>:
5 green   ADC1   black    0   LED5
6 yellow  ADC1   white    1   LED6
  --------------------------------------*/
void toggle_1led(int led)
{
	if ((GPIO_ODR(GPIOE) & (1<<led)) == 0)
 80001a8:	2201      	movs	r2, #1
 80001aa:	4082      	lsls	r2, r0
 80001ac:	4b04      	ldr	r3, [pc, #16]	; (80001c0 <toggle_1led+0x18>)
 80001ae:	681b      	ldr	r3, [r3, #0]
 80001b0:	421a      	tst	r2, r3
	{ // Here, LED bit was off
		GPIO_BSRR(GPIOE) = (1<<led);	// Set bits = all four LEDs off
 80001b2:	bf0b      	itete	eq
 80001b4:	4b03      	ldreq	r3, [pc, #12]	; (80001c4 <toggle_1led+0x1c>)
	}
	else
	{ // HEre, LED bit was on
		GPIO_BRR(GPIOE) = (1<<led);	// Reset bits = all four LEDs on
 80001b6:	4b04      	ldrne	r3, [pc, #16]	; (80001c8 <toggle_1led+0x20>)
  --------------------------------------*/
void toggle_1led(int led)
{
	if ((GPIO_ODR(GPIOE) & (1<<led)) == 0)
	{ // Here, LED bit was off
		GPIO_BSRR(GPIOE) = (1<<led);	// Set bits = all four LEDs off
 80001b8:	601a      	streq	r2, [r3, #0]
	}
	else
	{ // HEre, LED bit was on
		GPIO_BRR(GPIOE) = (1<<led);	// Reset bits = all four LEDs on
 80001ba:	801a      	strhne	r2, [r3, #0]
 80001bc:	4770      	bx	lr
 80001be:	bf00      	nop
 80001c0:	4001180c 	.word	0x4001180c
 80001c4:	40011810 	.word	0x40011810
 80001c8:	40011814 	.word	0x40011814

080001cc <main>:
	u32 j;
//	struct TWO32 canid
	u32 flashblocksize1;
/* --------------------- Type of RESET detection and dispatch ------------------------------------- */
	/* Check type of RESET and set us on the correct journey. */
	u32 rcc_csr = RCC_CSR;	// Get reset flags
 80001cc:	4b81      	ldr	r3, [pc, #516]	; (80003d4 <main+0x208>)

/*#################################################################################################
And now for the main routine 
  #################################################################################################*/
int main(void)
{
 80001ce:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	u32 j;
//	struct TWO32 canid
	u32 flashblocksize1;
/* --------------------- Type of RESET detection and dispatch ------------------------------------- */
	/* Check type of RESET and set us on the correct journey. */
	u32 rcc_csr = RCC_CSR;	// Get reset flags
 80001d2:	681a      	ldr	r2, [r3, #0]
	RCC_CSR |= (1 << 24);	// Clear flags in RCC_CSR (prep for next RESET)
 80001d4:	6819      	ldr	r1, [r3, #0]
	if (rcc_csr & (1 << 29))	// Was it Independent watchdog reset flag?
 80001d6:	f012 5f00 	tst.w	r2, #536870912	; 0x20000000
//	struct TWO32 canid
	u32 flashblocksize1;
/* --------------------- Type of RESET detection and dispatch ------------------------------------- */
	/* Check type of RESET and set us on the correct journey. */
	u32 rcc_csr = RCC_CSR;	// Get reset flags
	RCC_CSR |= (1 << 24);	// Clear flags in RCC_CSR (prep for next RESET)
 80001da:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
 80001de:	6019      	str	r1, [r3, #0]
	if (rcc_csr & (1 << 29))	// Was it Independent watchdog reset flag?
 80001e0:	d002      	beq.n	80001e8 <main+0x1c>
	{ // Here, yes.
		/* Jump to the application. */
//		(*(  (void (**)(void))APPJUMP)  )();	// Indirect via address common_can.h
		(*(  (void (*)(void))__appjump)  )();	// Indirect via label in .ld file (better)
 80001e2:	4b7d      	ldr	r3, [pc, #500]	; (80003d8 <main+0x20c>)
 80001e4:	681b      	ldr	r3, [r3, #0]
 80001e6:	4798      	blx	r3
	}
	/* Here, not the IWDG flag, so printf some stuff and wait for possible download, before app jump. */

/* --------------------- Begin setting things up -------------------------------------------------- */ 
	// Start system clocks using parameters matching CAN setup parameters for F103 boards
	clockspecifysetup(canwinch_setup_F103_pod_clocks() );
 80001e8:	f002 f816 	bl	8002218 <canwinch_setup_F103_pod_clocks>
 80001ec:	f001 fa9c 	bl	8001728 <clockspecifysetup>
/* ---------------------- Set up pins ------------------------------------------------------------- */
	PODgpiopins_default();	// Set gpio port register bits for low power
 80001f0:	f002 fa84 	bl	80026fc <PODgpiopins_default>
	PODgpiopins_Config();	// Now, configure pins
 80001f4:	f002 fa14 	bl	8002620 <PODgpiopins_Config>
	MAX3232SW_on;		// Turn on RS-232 level converter (if doesn't work--no RS-232 chars seen)
 80001f8:	4b78      	ldr	r3, [pc, #480]	; (80003dc <main+0x210>)
 80001fa:	2280      	movs	r2, #128	; 0x80
 80001fc:	801a      	strh	r2, [r3, #0]
/* ---------------------- Set up 32b DTW system counter ------------------------------------------- */
	DTW_counter_init();
 80001fe:	f001 fb4f 	bl	80018a0 <DTW_counter_init>
		rx line buffer size, (long enough for the longest line)
		number of rx line buffers, (must be > 1)
		tx line buffer size, (long enough for the longest line)
		number of tx line buffers, (must be > 1)
*/
	USART1_rxinttxint_init(115200,96,4,96,4); // Initialize USART and setup control blocks and pointers
 8000202:	2160      	movs	r1, #96	; 0x60
 8000204:	2204      	movs	r2, #4
 8000206:	460b      	mov	r3, r1
 8000208:	f44f 30e1 	mov.w	r0, #115200	; 0x1c200
 800020c:	9200      	str	r2, [sp, #0]
 800020e:	f001 fcf1 	bl	8001bf4 <USART1_rxinttxint_init>

	/* Announce who we are */
	USART1_txint_puts("\r\n\n\n #### ../LDRFIXEDPOD/TRUNK/LDR #### 04/20/2016 v0 \n\r");
 8000212:	4873      	ldr	r0, [pc, #460]	; (80003e0 <main+0x214>)
 8000214:	f001 fd86 	bl	8001d24 <USART1_txint_puts>

	USART1_txint_send();	// Start the line buffer sending
 8000218:	f001 fd9a 	bl	8001d50 <USART1_txint_send>

	/* Display things for to entertain the hapless op */
	init_printf(0,putc);	// This one-time initialization is needed by the tiny printf routine
 800021c:	2000      	movs	r0, #0
 800021e:	4971      	ldr	r1, [pc, #452]	; (80003e4 <main+0x218>)
 8000220:	f001 fc9a 	bl	8001b58 <init_printf>

	printf ("  hclk_freq (MHz) : %9u\n\r",  hclk_freq/1000000);	
 8000224:	4b70      	ldr	r3, [pc, #448]	; (80003e8 <main+0x21c>)
 8000226:	4d71      	ldr	r5, [pc, #452]	; (80003ec <main+0x220>)
 8000228:	6819      	ldr	r1, [r3, #0]
 800022a:	4871      	ldr	r0, [pc, #452]	; (80003f0 <main+0x224>)
 800022c:	fbb1 f1f5 	udiv	r1, r1, r5
 8000230:	f001 fc98 	bl	8001b64 <tfp_printf>
	printf (" pclk1_freq (MHz) : %9u\n\r", pclk1_freq/1000000);	USART1_txint_send();
 8000234:	4b6f      	ldr	r3, [pc, #444]	; (80003f4 <main+0x228>)
 8000236:	4870      	ldr	r0, [pc, #448]	; (80003f8 <main+0x22c>)
 8000238:	6819      	ldr	r1, [r3, #0]
	printf (" pclk2_freq (MHz) : %9u\n\r", pclk2_freq/1000000);	
	printf ("sysclk_freq (MHz) : %9u\n\r",sysclk_freq/1000000);
 800023a:	4c70      	ldr	r4, [pc, #448]	; (80003fc <main+0x230>)

	/* Display things for to entertain the hapless op */
	init_printf(0,putc);	// This one-time initialization is needed by the tiny printf routine

	printf ("  hclk_freq (MHz) : %9u\n\r",  hclk_freq/1000000);	
	printf (" pclk1_freq (MHz) : %9u\n\r", pclk1_freq/1000000);	USART1_txint_send();
 800023c:	fbb1 f1f5 	udiv	r1, r1, r5
 8000240:	f001 fc90 	bl	8001b64 <tfp_printf>
 8000244:	f001 fd84 	bl	8001d50 <USART1_txint_send>
	printf (" pclk2_freq (MHz) : %9u\n\r", pclk2_freq/1000000);	
 8000248:	4b6d      	ldr	r3, [pc, #436]	; (8000400 <main+0x234>)
 800024a:	486e      	ldr	r0, [pc, #440]	; (8000404 <main+0x238>)
 800024c:	6819      	ldr	r1, [r3, #0]
 800024e:	fbb1 f1f5 	udiv	r1, r1, r5
 8000252:	f001 fc87 	bl	8001b64 <tfp_printf>
	printf ("sysclk_freq (MHz) : %9u\n\r",sysclk_freq/1000000);
 8000256:	6821      	ldr	r1, [r4, #0]
 8000258:	486b      	ldr	r0, [pc, #428]	; (8000408 <main+0x23c>)
 800025a:	fbb1 f1f5 	udiv	r1, r1, r5

	printf ("\n\rControl/status register (RCC_CSR) : %08x\n\r",RCC_CSR);
 800025e:	4d5d      	ldr	r5, [pc, #372]	; (80003d4 <main+0x208>)
	init_printf(0,putc);	// This one-time initialization is needed by the tiny printf routine

	printf ("  hclk_freq (MHz) : %9u\n\r",  hclk_freq/1000000);	
	printf (" pclk1_freq (MHz) : %9u\n\r", pclk1_freq/1000000);	USART1_txint_send();
	printf (" pclk2_freq (MHz) : %9u\n\r", pclk2_freq/1000000);	
	printf ("sysclk_freq (MHz) : %9u\n\r",sysclk_freq/1000000);
 8000260:	f001 fc80 	bl	8001b64 <tfp_printf>

	printf ("\n\rControl/status register (RCC_CSR) : %08x\n\r",RCC_CSR);
 8000264:	6829      	ldr	r1, [r5, #0]
 8000266:	4869      	ldr	r0, [pc, #420]	; (800040c <main+0x240>)
 8000268:	f001 fc7c 	bl	8001b64 <tfp_printf>
	RCC_CSR |= (1 << 24);
 800026c:	682b      	ldr	r3, [r5, #0]
	printf ("Control/status register (RCC_CSR) : %08x After RMVF written\n\r\n",RCC_CSR);
 800026e:	4868      	ldr	r0, [pc, #416]	; (8000410 <main+0x244>)
	printf (" pclk1_freq (MHz) : %9u\n\r", pclk1_freq/1000000);	USART1_txint_send();
	printf (" pclk2_freq (MHz) : %9u\n\r", pclk2_freq/1000000);	
	printf ("sysclk_freq (MHz) : %9u\n\r",sysclk_freq/1000000);

	printf ("\n\rControl/status register (RCC_CSR) : %08x\n\r",RCC_CSR);
	RCC_CSR |= (1 << 24);
 8000270:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8000274:	602b      	str	r3, [r5, #0]
	printf ("Control/status register (RCC_CSR) : %08x After RMVF written\n\r\n",RCC_CSR);
 8000276:	6829      	ldr	r1, [r5, #0]
 8000278:	f001 fc74 	bl	8001b64 <tfp_printf>
	RCC_CSR |= (7 << 29);
 800027c:	682b      	ldr	r3, [r5, #0]
	printf ("Control/status register (RCC_CSR) : %08x After LPWR written\n\r\n",RCC_CSR);
 800027e:	4865      	ldr	r0, [pc, #404]	; (8000414 <main+0x248>)
	printf ("sysclk_freq (MHz) : %9u\n\r",sysclk_freq/1000000);

	printf ("\n\rControl/status register (RCC_CSR) : %08x\n\r",RCC_CSR);
	RCC_CSR |= (1 << 24);
	printf ("Control/status register (RCC_CSR) : %08x After RMVF written\n\r\n",RCC_CSR);
	RCC_CSR |= (7 << 29);
 8000280:	f043 4360 	orr.w	r3, r3, #3758096384	; 0xe0000000
 8000284:	602b      	str	r3, [r5, #0]
	printf ("Control/status register (RCC_CSR) : %08x After LPWR written\n\r\n",RCC_CSR);
 8000286:	6829      	ldr	r1, [r5, #0]
 8000288:	f001 fc6c 	bl	8001b64 <tfp_printf>
/* --------------------- CAN setup ------------------------------------------------------------------- */
	/* Configure CAN criver RS pin: Sensor RxT6 board = (PB 7) */
	can_nxp_setRS(0,1); // (1st arg) 0 = high speed mode; not-zero = standby mode
 800028c:	2000      	movs	r0, #0
 800028e:	2101      	movs	r1, #1
 8000290:	f001 ff98 	bl	80021c4 <can_nxp_setRS>

	/* Initialize CAN for POD board (F103) and get control block */
	pctl1 = canwinch_setup_F103_pod(&msginit,IAMUNITNUMBER);
 8000294:	4860      	ldr	r0, [pc, #384]	; (8000418 <main+0x24c>)
 8000296:	f04f 7110 	mov.w	r1, #37748736	; 0x2400000
 800029a:	f001 ffc1 	bl	8002220 <canwinch_setup_F103_pod>
 800029e:	4a5f      	ldr	r2, [pc, #380]	; (800041c <main+0x250>)
 80002a0:	6010      	str	r0, [r2, #0]
 80002a2:	4691      	mov	r9, r2

	/* Check if initialization was successful. */
	if (pctl1 == NULL)
 80002a4:	b928      	cbnz	r0, 80002b2 <main+0xe6>
	{
		printf("CAN1 init failed: NULL ptr\n\r");USART1_txint_send(); 
 80002a6:	485e      	ldr	r0, [pc, #376]	; (8000420 <main+0x254>)
 80002a8:	f001 fc5c 	bl	8001b64 <tfp_printf>
 80002ac:	f001 fd50 	bl	8001d50 <USART1_txint_send>
 80002b0:	e7fe      	b.n	80002b0 <main+0xe4>
		while (1==1);
	}
	if (pctl1->ret < 0)
 80002b2:	f990 1090 	ldrsb.w	r1, [r0, #144]	; 0x90
 80002b6:	2900      	cmp	r1, #0
 80002b8:	da05      	bge.n	80002c6 <main+0xfa>
	{
		printf("CAN init failed: return code = %d\n\r",pctl1->ret);USART1_txint_send(); 
 80002ba:	485a      	ldr	r0, [pc, #360]	; (8000424 <main+0x258>)
 80002bc:	f001 fc52 	bl	8001b64 <tfp_printf>
 80002c0:	f001 fd46 	bl	8001d50 <USART1_txint_send>
 80002c4:	e7fe      	b.n	80002c4 <main+0xf8>
		while (1==1);
	}
/* ----------------------- Header for columns of CAN error printf ------------------------------------- */
//canwinch_pod_common_systick2048_printerr_header();
/* ---------------- When CAN interrupts are enabled reception of msgs begins! ------------------------ */
	can_msg_reset_init(pctl1, IAMUNITNUMBER);	// Specify CAN ID for this unit for msg caused RESET
 80002c6:	f04f 7110 	mov.w	r1, #37748736	; 0x2400000
 80002ca:	f003 f88b 	bl	80033e4 <can_msg_reset_init>

// RX msgs begin immediately following enabling CAN interrupts.  Get 'peek' 'toss' of RX msgs going soon.
	can_driver_enable_interrupts();	// Enable CAN interrupts
 80002ce:	f002 fc87 	bl	8002be0 <can_driver_enable_interrupts>
/* -------------- Get the program loader stuff setup -------------------------------------- */
	canwinch_ldrproto_init(IAMUNITNUMBER);
 80002d2:	f04f 7010 	mov.w	r0, #37748736	; 0x2400000
 80002d6:	f000 f9fb 	bl	80006d0 <canwinch_ldrproto_init>
printf(  "BOARD_TYP : %08X\n\r", pfixedaddress->board_typ); 	USART1_txint_send();
printf(  "rc_crc32  : %08X\n\r", (u32)pfixedaddress->func1);
printf(  "MY CAN ID : %08X\n\r", IAMUNITNUMBER);	
*/
// Right justify to show unit number (based on a basic 11 bit CAN id, though 29 bit might be used 
printf(  "  i.e. unit#: %d\n\r", IAMUNITNUMBER); USART1_txint_send();
 80002da:	f04f 7110 	mov.w	r1, #37748736	; 0x2400000
 80002de:	4852      	ldr	r0, [pc, #328]	; (8000428 <main+0x25c>)
 80002e0:	f001 fc40 	bl	8001b64 <tfp_printf>
 80002e4:	f001 fd34 	bl	8001d50 <USART1_txint_send>

	flashblocksize1 = (*(u16*)(0x1FFFF7E0)); // Get size of flash in Kbytes
 80002e8:	4b50      	ldr	r3, [pc, #320]	; (800042c <main+0x260>)

printf(  "FLASH SIZE: %d\n\r",flashblocksize1);USART1_txint_send();


	u32* pcrcblk = (u32*)((u32)((u8*)*&__appjump + 7 + 0));	// First table entry = number of crcblocks	
	printf(  "(u32)*pcrcblk: %08X\n\r", (u32)*pcrcblk++ );	USART1_txint_send();
 80002ea:	4d3b      	ldr	r5, [pc, #236]	; (80003d8 <main+0x20c>)
*/
// Right justify to show unit number (based on a basic 11 bit CAN id, though 29 bit might be used 
printf(  "  i.e. unit#: %d\n\r", IAMUNITNUMBER); USART1_txint_send();

	flashblocksize1 = (*(u16*)(0x1FFFF7E0)); // Get size of flash in Kbytes
	if (flashblocksize1 > 256) 
 80002ec:	881b      	ldrh	r3, [r3, #0]
		flashblocksize1 = 2048;	// XL series flash block size
	else
		flashblocksize1 = 1024;	// Med, and High series flash block size

printf(  "FLASH SIZE: %d\n\r",flashblocksize1);USART1_txint_send();
 80002ee:	4850      	ldr	r0, [pc, #320]	; (8000430 <main+0x264>)
*/
// Right justify to show unit number (based on a basic 11 bit CAN id, though 29 bit might be used 
printf(  "  i.e. unit#: %d\n\r", IAMUNITNUMBER); USART1_txint_send();

	flashblocksize1 = (*(u16*)(0x1FFFF7E0)); // Get size of flash in Kbytes
	if (flashblocksize1 > 256) 
 80002f0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
		flashblocksize1 = 2048;	// XL series flash block size
 80002f4:	bf8c      	ite	hi
 80002f6:	f44f 6100 	movhi.w	r1, #2048	; 0x800
	else
		flashblocksize1 = 1024;	// Med, and High series flash block size
 80002fa:	f44f 6180 	movls.w	r1, #1024	; 0x400

printf(  "FLASH SIZE: %d\n\r",flashblocksize1);USART1_txint_send();
 80002fe:	f001 fc31 	bl	8001b64 <tfp_printf>
 8000302:	f001 fd25 	bl	8001d50 <USART1_txint_send>


	u32* pcrcblk = (u32*)((u32)((u8*)*&__appjump + 7 + 0));	// First table entry = number of crcblocks	
	printf(  "(u32)*pcrcblk: %08X\n\r", (u32)*pcrcblk++ );	USART1_txint_send();
 8000306:	682b      	ldr	r3, [r5, #0]
 8000308:	484a      	ldr	r0, [pc, #296]	; (8000434 <main+0x268>)
 800030a:	f8d3 1007 	ldr.w	r1, [r3, #7]

	u32 flashincrement = sysclk_freq/6;

	// for debug multipy the increment to give the hapless Op time to think
	u32 can_waitdelay_ct = (DTWTIME + 5*sysclk_freq); // Set number secs to wait before jumping to app
 800030e:	4f4a      	ldr	r7, [pc, #296]	; (8000438 <main+0x26c>)

printf(  "FLASH SIZE: %d\n\r",flashblocksize1);USART1_txint_send();


	u32* pcrcblk = (u32*)((u32)((u8*)*&__appjump + 7 + 0));	// First table entry = number of crcblocks	
	printf(  "(u32)*pcrcblk: %08X\n\r", (u32)*pcrcblk++ );	USART1_txint_send();
 8000310:	f001 fc28 	bl	8001b64 <tfp_printf>
 8000314:	f001 fd1c 	bl	8001d50 <USART1_txint_send>

	u32 flashincrement = sysclk_freq/6;
 8000318:	6823      	ldr	r3, [r4, #0]

	// for debug multipy the increment to give the hapless Op time to think
	u32 can_waitdelay_ct = (DTWTIME + 5*sysclk_freq); // Set number secs to wait before jumping to app
 800031a:	683a      	ldr	r2, [r7, #0]


	u32* pcrcblk = (u32*)((u32)((u8*)*&__appjump + 7 + 0));	// First table entry = number of crcblocks	
	printf(  "(u32)*pcrcblk: %08X\n\r", (u32)*pcrcblk++ );	USART1_txint_send();

	u32 flashincrement = sysclk_freq/6;
 800031c:	2606      	movs	r6, #6
 800031e:	fbb3 f6f6 	udiv	r6, r3, r6

	// for debug multipy the increment to give the hapless Op time to think
	u32 can_waitdelay_ct = (DTWTIME + 5*sysclk_freq); // Set number secs to wait before jumping to app
 8000322:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8000326:	eb03 0802 	add.w	r8, r3, r2
/* --------------------- Endless Stuff ----------------------------------------------- */

	/* If PC is listening this will tell it that unit is running the loader program. */
//int i; for (i = 0; i < 10; i++)
	can_driver_put(pctl1, (struct CANRCVBUF*)&can_ldr_ready, 8, 0); // Send msg that ldr is running
 800032a:	f8d9 0000 	ldr.w	r0, [r9]
 800032e:	2208      	movs	r2, #8
 8000330:	2300      	movs	r3, #0
 8000332:	4942      	ldr	r1, [pc, #264]	; (800043c <main+0x270>)
 8000334:	f002 fc84 	bl	8002c40 <can_driver_put>

	ldr_phase = 0;	// /Switch to prevent jumping to app once loading starts
 8000338:	4b41      	ldr	r3, [pc, #260]	; (8000440 <main+0x274>)
 800033a:	2200      	movs	r2, #0
 800033c:	601a      	str	r2, [r3, #0]

	u32 dwt = (DTWTIME + flashincrement); // DWT_CYCNT
 800033e:	683f      	ldr	r7, [r7, #0]
 8000340:	4699      	mov	r9, r3
 8000342:	19f7      	adds	r7, r6, r7
	while (1==1)
	{
		/* Wait for time to expire. */
		if (  ( (int)dwt - (int)(DTWTIME)) < 0 )
 8000344:	4b3c      	ldr	r3, [pc, #240]	; (8000438 <main+0x26c>)
 8000346:	681b      	ldr	r3, [r3, #0]
 8000348:	1afb      	subs	r3, r7, r3
 800034a:	2b00      	cmp	r3, #0
 800034c:	da03      	bge.n	8000356 <main+0x18a>
		{
			dwt += flashincrement;	// Set next LED toggle time
			toggle_1led(LEDGREEN1);
 800034e:	2003      	movs	r0, #3
	while (1==1)
	{
		/* Wait for time to expire. */
		if (  ( (int)dwt - (int)(DTWTIME)) < 0 )
		{
			dwt += flashincrement;	// Set next LED toggle time
 8000350:	19bf      	adds	r7, r7, r6
			toggle_1led(LEDGREEN1);
 8000352:	f7ff ff29 	bl	80001a8 <toggle_1led>
		}

		/* Do loader'ing, if there are applicable msgs. */
		canwinch_ldrproto_poll();
 8000356:	f000 fd45 	bl	8000de4 <canwinch_ldrproto_poll>

		/* Have we written to flash?  If so, don't jump to the the app unless commanded. */
		if (ldr_phase == 0)
 800035a:	f8d9 3000 	ldr.w	r3, [r9]
 800035e:	2b00      	cmp	r3, #0
 8000360:	d1f0      	bne.n	8000344 <main+0x178>
		{ // Here, we haven't done anything to disturb the integrity of the app
			if (  ((int)can_waitdelay_ct - (int)(DTWTIME)) < 0 )
 8000362:	4b35      	ldr	r3, [pc, #212]	; (8000438 <main+0x26c>)
 8000364:	681b      	ldr	r3, [r3, #0]
 8000366:	ebc3 0308 	rsb	r3, r3, r8
 800036a:	2b00      	cmp	r3, #0
 800036c:	daea      	bge.n	8000344 <main+0x178>
			{ // We timed out.
				if (((u32)&__appjump > (u32)__appjump) || ((u32)__appjump > (u32)0x08040000))
 800036e:	682a      	ldr	r2, [r5, #0]
 8000370:	42aa      	cmp	r2, r5
 8000372:	d302      	bcc.n	800037a <main+0x1ae>
 8000374:	4b33      	ldr	r3, [pc, #204]	; (8000444 <main+0x278>)
 8000376:	429a      	cmp	r2, r3
 8000378:	d911      	bls.n	800039e <main+0x1d2>
				{ // Here, jump address is bogus
					printf("\n\r\n#### At offset %08X address %08X is bogus ####\n\r\n",(u32)&__appjump, __appjump);
 800037a:	4833      	ldr	r0, [pc, #204]	; (8000448 <main+0x27c>)
 800037c:	4916      	ldr	r1, [pc, #88]	; (80003d8 <main+0x20c>)
 800037e:	f001 fbf1 	bl	8001b64 <tfp_printf>
					USART1_txint_send();
 8000382:	f001 fce5 	bl	8001d50 <USART1_txint_send>
					dwt = (DTWTIME + sysclk_freq/2);
 8000386:	4b2c      	ldr	r3, [pc, #176]	; (8000438 <main+0x26c>)
 8000388:	6822      	ldr	r2, [r4, #0]
 800038a:	681b      	ldr	r3, [r3, #0]
 800038c:	eb03 0352 	add.w	r3, r3, r2, lsr #1
					while (  ((int)dwt - (int)(DTWTIME)) > 0 );
 8000390:	4a29      	ldr	r2, [pc, #164]	; (8000438 <main+0x26c>)
 8000392:	6812      	ldr	r2, [r2, #0]
 8000394:	1a9a      	subs	r2, r3, r2
 8000396:	2a00      	cmp	r2, #0
 8000398:	dcfa      	bgt.n	8000390 <main+0x1c4>
					system_reset();	// Software reset
 800039a:	f7ff fefc 	bl	8000196 <system_reset>
				}
				/* Set Indpendent Watch Dog and let it cause a reset. */
				RCC_CSR |= (1<<0);			// LSI enable, necessary for IWDG
 800039e:	4b0d      	ldr	r3, [pc, #52]	; (80003d4 <main+0x208>)
 80003a0:	681a      	ldr	r2, [r3, #0]
 80003a2:	f042 0201 	orr.w	r2, r2, #1
 80003a6:	601a      	str	r2, [r3, #0]
				while ((RCC_CSR & (1<<1)) == 0);	// wait till LSI is ready
 80003a8:	4b0a      	ldr	r3, [pc, #40]	; (80003d4 <main+0x208>)
 80003aa:	681b      	ldr	r3, [r3, #0]
 80003ac:	f013 0f02 	tst.w	r3, #2
 80003b0:	d0fa      	beq.n	80003a8 <main+0x1dc>
  				IWDG_KR  = 0x5555;			// enable write to PR, RLR
 80003b2:	4b26      	ldr	r3, [pc, #152]	; (800044c <main+0x280>)
 80003b4:	f245 5255 	movw	r2, #21845	; 0x5555
 80003b8:	601a      	str	r2, [r3, #0]
  				IWDG_PR  = 0;				// Init prescaler
 80003ba:	4a25      	ldr	r2, [pc, #148]	; (8000450 <main+0x284>)
 80003bc:	2100      	movs	r1, #0
 80003be:	6011      	str	r1, [r2, #0]
  				IWDG_RLR = 0x02;			// Init RLR
 80003c0:	3102      	adds	r1, #2
 80003c2:	6051      	str	r1, [r2, #4]
  				IWDG_KR  = 0xAAAA;			// Reload the watchdog
 80003c4:	f64a 22aa 	movw	r2, #43690	; 0xaaaa
 80003c8:	601a      	str	r2, [r3, #0]
  				IWDG_KR  = 0xCCCC;			// Start the watchdog
 80003ca:	f64c 42cc 	movw	r2, #52428	; 0xcccc
 80003ce:	601a      	str	r2, [r3, #0]
 80003d0:	e7fe      	b.n	80003d0 <main+0x204>
 80003d2:	bf00      	nop
 80003d4:	40021024 	.word	0x40021024
 80003d8:	08005004 	.word	0x08005004
 80003dc:	40011414 	.word	0x40011414
 80003e0:	0800351c 	.word	0x0800351c
 80003e4:	08000191 	.word	0x08000191
 80003e8:	20000dd8 	.word	0x20000dd8
 80003ec:	000f4240 	.word	0x000f4240
 80003f0:	08003555 	.word	0x08003555
 80003f4:	20000dd4 	.word	0x20000dd4
 80003f8:	0800356f 	.word	0x0800356f
 80003fc:	20000dcc 	.word	0x20000dcc
 8000400:	20000dd0 	.word	0x20000dd0
 8000404:	08003589 	.word	0x08003589
 8000408:	080035a3 	.word	0x080035a3
 800040c:	080035bd 	.word	0x080035bd
 8000410:	080035ea 	.word	0x080035ea
 8000414:	08003629 	.word	0x08003629
 8000418:	08003a40 	.word	0x08003a40
 800041c:	20000518 	.word	0x20000518
 8000420:	08003668 	.word	0x08003668
 8000424:	08003685 	.word	0x08003685
 8000428:	080036a9 	.word	0x080036a9
 800042c:	1ffff7e0 	.word	0x1ffff7e0
 8000430:	080036bc 	.word	0x080036bc
 8000434:	080036cd 	.word	0x080036cd
 8000438:	e0001004 	.word	0xe0001004
 800043c:	08003a50 	.word	0x08003a50
 8000440:	20000d80 	.word	0x20000d80
 8000444:	08040000 	.word	0x08040000
 8000448:	080036e3 	.word	0x080036e3
 800044c:	40003000 	.word	0x40003000
 8000450:	40003004 	.word	0x40003004

08000454 <_close>:
}

int _close(int file) {
	file=file;
    return -1;
}
 8000454:	f04f 30ff 	mov.w	r0, #4294967295
 8000458:	4770      	bx	lr

0800045a <_execve>:
 execve
 Transfer control to a new process. Minimal implementation (for a system without processes):
 */
int _execve(char *name, char **argv, char **env) {
	name=name; argv=argv; env=env;
    errno = ENOMEM;
 800045a:	4b03      	ldr	r3, [pc, #12]	; (8000468 <_execve+0xe>)
 800045c:	220c      	movs	r2, #12
 800045e:	601a      	str	r2, [r3, #0]
    return -1;
}
 8000460:	f04f 30ff 	mov.w	r0, #4294967295
 8000464:	4770      	bx	lr
 8000466:	bf00      	nop
 8000468:	20001654 	.word	0x20001654

0800046c <_fork>:
 fork
 Create a new process. Minimal implementation (for a system without processes):
 */

int _fork(void) {
    errno = EAGAIN;
 800046c:	4b02      	ldr	r3, [pc, #8]	; (8000478 <_fork+0xc>)
 800046e:	220b      	movs	r2, #11
 8000470:	601a      	str	r2, [r3, #0]
    return -1;
}
 8000472:	f04f 30ff 	mov.w	r0, #4294967295
 8000476:	4770      	bx	lr
 8000478:	20001654 	.word	0x20001654

0800047c <_fstat>:
 all files are regarded as character special devices.
 The `sys/stat.h' header file required is distributed in the `include' subdirectory for this C library.
 */
int _fstat(int file, struct stat *st) {
	file=file;
    st->st_mode = S_IFCHR;
 800047c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8000480:	604b      	str	r3, [r1, #4]
    return 0;
}
 8000482:	2000      	movs	r0, #0
 8000484:	4770      	bx	lr

08000486 <_getpid>:
 Process-ID; this is sometimes used to generate strings unlikely to conflict with other processes. Minimal implementation, for a system without processes:
 */

int _getpid(void) {
    return 1;
}
 8000486:	2001      	movs	r0, #1
 8000488:	4770      	bx	lr

0800048a <_isatty>:
/*
 isatty
 Query whether output stream is a terminal. For consistency with the other minimal implementations,
 */
int _isatty(int file) {
    switch (file){
 800048a:	2802      	cmp	r0, #2
 800048c:	d904      	bls.n	8000498 <_isatty+0xe>
    case STDERR_FILENO:
    case STDIN_FILENO:
        return 1;
    default:
        //errno = ENOTTY;
        errno = EBADF;
 800048e:	4b03      	ldr	r3, [pc, #12]	; (800049c <_isatty+0x12>)
 8000490:	2209      	movs	r2, #9
 8000492:	601a      	str	r2, [r3, #0]
        return 0;
 8000494:	2000      	movs	r0, #0
 8000496:	4770      	bx	lr
int _isatty(int file) {
    switch (file){
    case STDOUT_FILENO:
    case STDERR_FILENO:
    case STDIN_FILENO:
        return 1;
 8000498:	2001      	movs	r0, #1
    default:
        //errno = ENOTTY;
        errno = EBADF;
        return 0;
    }
}
 800049a:	4770      	bx	lr
 800049c:	20001654 	.word	0x20001654

080004a0 <_kill>:
 kill
 Send a signal. Minimal implementation:
 */
int _kill(int pid, int sig) {
	pid=pid; sig=sig;
    errno = EINVAL;
 80004a0:	4b02      	ldr	r3, [pc, #8]	; (80004ac <_kill+0xc>)
 80004a2:	2216      	movs	r2, #22
 80004a4:	601a      	str	r2, [r3, #0]
    return (-1);
}
 80004a6:	f04f 30ff 	mov.w	r0, #4294967295
 80004aa:	4770      	bx	lr
 80004ac:	20001654 	.word	0x20001654

080004b0 <_link>:
 Establish a new name for an existing file. Minimal implementation:
 */

int _link(char *old, char *new) {
	old=old; new=new;
    errno = EMLINK;
 80004b0:	4b02      	ldr	r3, [pc, #8]	; (80004bc <_link+0xc>)
 80004b2:	221f      	movs	r2, #31
 80004b4:	601a      	str	r2, [r3, #0]
    return -1;
}
 80004b6:	f04f 30ff 	mov.w	r0, #4294967295
 80004ba:	4770      	bx	lr
 80004bc:	20001654 	.word	0x20001654

080004c0 <_lseek>:
 Set position in a file. Minimal implementation:
 */
int _lseek(int file, int ptr, int dir) {
	file=file; ptr=ptr; dir=dir;
    return 0;
}
 80004c0:	2000      	movs	r0, #0
 80004c2:	4770      	bx	lr

080004c4 <_sbrk>:

caddr_t _sbrk(int incr) 
{
    char *prev_heap_end;

    if (heap_end == 0) {
 80004c4:	4b04      	ldr	r3, [pc, #16]	; (80004d8 <_sbrk+0x14>)
 80004c6:	681a      	ldr	r2, [r3, #0]
 80004c8:	b90a      	cbnz	r2, 80004ce <_sbrk+0xa>
        heap_end = &_ebss;
 80004ca:	4a04      	ldr	r2, [pc, #16]	; (80004dc <_sbrk+0x18>)
 80004cc:	601a      	str	r2, [r3, #0]
    }
    prev_heap_end = heap_end;
 80004ce:	681a      	ldr	r2, [r3, #0]
//         errno = ENOMEM;
//         return  (caddr_t) -1;
//         //abort ();
//     }

    heap_end += incr;
 80004d0:	1810      	adds	r0, r2, r0
 80004d2:	6018      	str	r0, [r3, #0]
    return (caddr_t) prev_heap_end;

}
 80004d4:	4610      	mov	r0, r2
 80004d6:	4770      	bx	lr
 80004d8:	2000051c 	.word	0x2000051c
 80004dc:	20001658 	.word	0x20001658

080004e0 <_read>:


int _read(int file, char *ptr, int len) {
    int num = 0;
 ptr=ptr; len=len;
    switch (file) {
 80004e0:	b120      	cbz	r0, 80004ec <_read+0xc>
    case STDIN_FILENO:
        break;
    default:
        errno = EBADF;
 80004e2:	4b03      	ldr	r3, [pc, #12]	; (80004f0 <_read+0x10>)
 80004e4:	2209      	movs	r2, #9
 80004e6:	601a      	str	r2, [r3, #0]
        return -1;
 80004e8:	f04f 30ff 	mov.w	r0, #4294967295
    }
    return num;
}
 80004ec:	4770      	bx	lr
 80004ee:	bf00      	nop
 80004f0:	20001654 	.word	0x20001654

080004f4 <_stat>:
 int    _EXFUN(stat,( const char *__path, struct stat *__sbuf ));
 */

int _stat(const char *filepath, struct stat *st) {
	filepath=filepath;
    st->st_mode = S_IFCHR;
 80004f4:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80004f8:	604b      	str	r3, [r1, #4]
    return 0;
}
 80004fa:	2000      	movs	r0, #0
 80004fc:	4770      	bx	lr

080004fe <_times>:
 */

clock_t _times(struct tms *buf) {
	buf=buf;
    return -1;
}
 80004fe:	f04f 30ff 	mov.w	r0, #4294967295
 8000502:	4770      	bx	lr

08000504 <_unlink>:
 unlink
 Remove a file's directory entry. Minimal implementation:
 */
int _unlink(char *name) {
	name=name;
    errno = ENOENT;
 8000504:	4b02      	ldr	r3, [pc, #8]	; (8000510 <_unlink+0xc>)
 8000506:	2202      	movs	r2, #2
 8000508:	601a      	str	r2, [r3, #0]
    return -1;
}
 800050a:	f04f 30ff 	mov.w	r0, #4294967295
 800050e:	4770      	bx	lr
 8000510:	20001654 	.word	0x20001654

08000514 <_wait>:
 wait
 Wait for a child process. Minimal implementation:
 */
int _wait(int *status) {
	status=status;
    errno = ECHILD;
 8000514:	4b02      	ldr	r3, [pc, #8]	; (8000520 <_wait+0xc>)
 8000516:	220a      	movs	r2, #10
 8000518:	601a      	str	r2, [r3, #0]
    return -1;
}
 800051a:	f04f 30ff 	mov.w	r0, #4294967295
 800051e:	4770      	bx	lr
 8000520:	20001654 	.word	0x20001654

08000524 <_write>:
 Write a character to a file. `libc' subroutines will use this system routine for output to all files, including stdout
 Returns -1 on error or number of bytes sent
 */
int _write(int file, char *ptr, int len) {
    int n;
    switch (file) {
 8000524:	2801      	cmp	r0, #1
/*
 write
 Write a character to a file. `libc' subroutines will use this system routine for output to all files, including stdout
 Returns -1 on error or number of bytes sent
 */
int _write(int file, char *ptr, int len) {
 8000526:	b570      	push	{r4, r5, r6, lr}
 8000528:	460c      	mov	r4, r1
 800052a:	4616      	mov	r6, r2
    int n;
    switch (file) {
 800052c:	d003      	beq.n	8000536 <_write+0x12>
 800052e:	2802      	cmp	r0, #2
 8000530:	d121      	bne.n	8000576 <_write+0x52>
 8000532:	2500      	movs	r5, #0
 8000534:	e01c      	b.n	8000570 <_write+0x4c>
 8000536:	2500      	movs	r5, #0
 8000538:	e00b      	b.n	8000552 <_write+0x2e>

    case STDOUT_FILENO: /*stdout*/
        for (n = 0; n < len; n++) 
	{
		USART1_txint_putc(*ptr);
 800053a:	5d60      	ldrb	r0, [r4, r5]
 800053c:	f001 fbd6 	bl	8001cec <USART1_txint_putc>
		if (*ptr++ == '\n') 	
 8000540:	5d63      	ldrb	r3, [r4, r5]
 8000542:	2b0a      	cmp	r3, #10
 8000544:	d104      	bne.n	8000550 <_write+0x2c>
		{			
			USART1_txint_putc('\r');
 8000546:	200d      	movs	r0, #13
 8000548:	f001 fbd0 	bl	8001cec <USART1_txint_putc>
			USART1_txint_send();
 800054c:	f001 fc00 	bl	8001d50 <USART1_txint_send>
int _write(int file, char *ptr, int len) {
    int n;
    switch (file) {

    case STDOUT_FILENO: /*stdout*/
        for (n = 0; n < len; n++) 
 8000550:	3501      	adds	r5, #1
 8000552:	42b5      	cmp	r5, r6
 8000554:	dbf1      	blt.n	800053a <_write+0x16>
 8000556:	e013      	b.n	8000580 <_write+0x5c>
        break;

    case STDERR_FILENO: /* stderr */
        for (n = 0; n < len; n++) 
	{
		USART1_txint_putc(*ptr);
 8000558:	5d60      	ldrb	r0, [r4, r5]
 800055a:	f001 fbc7 	bl	8001cec <USART1_txint_putc>
		if (*ptr++ == '\n') 	
 800055e:	5d63      	ldrb	r3, [r4, r5]
 8000560:	2b0a      	cmp	r3, #10
 8000562:	d104      	bne.n	800056e <_write+0x4a>
		{			
			USART1_txint_putc('\r');
 8000564:	200d      	movs	r0, #13
 8000566:	f001 fbc1 	bl	8001cec <USART1_txint_putc>
			USART1_txint_send();
 800056a:	f001 fbf1 	bl	8001d50 <USART1_txint_send>
		}
      }
        break;

    case STDERR_FILENO: /* stderr */
        for (n = 0; n < len; n++) 
 800056e:	3501      	adds	r5, #1
 8000570:	42b5      	cmp	r5, r6
 8000572:	dbf1      	blt.n	8000558 <_write+0x34>
 8000574:	e004      	b.n	8000580 <_write+0x5c>
			USART1_txint_send();
		}
        }
        break;
    default:
        errno = EBADF;
 8000576:	4b03      	ldr	r3, [pc, #12]	; (8000584 <_write+0x60>)
 8000578:	2209      	movs	r2, #9
 800057a:	601a      	str	r2, [r3, #0]
        return -1;
 800057c:	f04f 36ff 	mov.w	r6, #4294967295
    }
    return len;
}
 8000580:	4630      	mov	r0, r6
 8000582:	bd70      	pop	{r4, r5, r6, pc}
 8000584:	20001654 	.word	0x20001654

08000588 <_exit>:
char *__env[1] = { 0 };
char **environ = __env;

int _write(int file, char *ptr, int len);

void _exit(int status) {
 8000588:	b508      	push	{r3, lr}
	status = status;
    _write(1, "exit\n", 4);
 800058a:	2001      	movs	r0, #1
 800058c:	4902      	ldr	r1, [pc, #8]	; (8000598 <_exit+0x10>)
 800058e:	2204      	movs	r2, #4
 8000590:	f7ff ffc8 	bl	8000524 <_write>
 8000594:	e7fe      	b.n	8000594 <_exit+0xc>
 8000596:	bf00      	nop
 8000598:	08003718 	.word	0x08003718

0800059c <flashblockinit>:
	u64* pt1;	// Beginning address of flash block
	u64* pt2;	// Beginning address of RAM buff
	u64* ptend;	// End+1 of RAM buff

	/* Load block that padd points to into RAM. */
	pt1 = (u64*)((u32)(padd) & ~(flashblocksize - 1)); 	// Block addr of STM32 memory to be loaded
 800059c:	4a0f      	ldr	r2, [pc, #60]	; (80005dc <flashblockinit+0x40>)
 800059e:	4b10      	ldr	r3, [pc, #64]	; (80005e0 <flashblockinit+0x44>)
 80005a0:	6811      	ldr	r1, [r2, #0]
 80005a2:	f8d3 0810 	ldr.w	r0, [r3, #2064]	; 0x810
 80005a6:	424a      	negs	r2, r1
 80005a8:	ea00 0202 	and.w	r2, r0, r2
	flblkbuff.base = (u8*)pt1;				// Pointer to beginning of flash block
	flblkbuff.end = flblkbuff.base + flashblocksize;	// End + 1
	flblkbuff.p = &flblkbuff.fb.u8[0] + (padd - (u8*)pt1); 	// Pointer to where payload begins storing
 80005ac:	1a80      	subs	r0, r0, r2
 80005ae:	1818      	adds	r0, r3, r0
/* **************************************************************************************
 * static void flashblockinit(void);
 * @brief	: Read in flash block to sram buffer
 * ************************************************************************************** */
static void flashblockinit(void)
{
 80005b0:	b530      	push	{r4, r5, lr}
	u64* ptend;	// End+1 of RAM buff

	/* Load block that padd points to into RAM. */
	pt1 = (u64*)((u32)(padd) & ~(flashblocksize - 1)); 	// Block addr of STM32 memory to be loaded
	flblkbuff.base = (u8*)pt1;				// Pointer to beginning of flash block
	flblkbuff.end = flblkbuff.base + flashblocksize;	// End + 1
 80005b2:	1854      	adds	r4, r2, r1
	flblkbuff.p = &flblkbuff.fb.u8[0] + (padd - (u8*)pt1); 	// Pointer to where payload begins storing
 80005b4:	f8c3 0808 	str.w	r0, [r3, #2056]	; 0x808
	flblkbuff.sw = 0;					// Switch for write/erase
	pt2 = &flblkbuff.fb.u64[0];				// RAM buffer for block
	ptend = pt2 + (flashblocksize/sizeof(u64)); 		// End+1 of RAM buffer
 80005b8:	f021 0107 	bic.w	r1, r1, #7
	/* Load block that padd points to into RAM. */
	pt1 = (u64*)((u32)(padd) & ~(flashblocksize - 1)); 	// Block addr of STM32 memory to be loaded
	flblkbuff.base = (u8*)pt1;				// Pointer to beginning of flash block
	flblkbuff.end = flblkbuff.base + flashblocksize;	// End + 1
	flblkbuff.p = &flblkbuff.fb.u8[0] + (padd - (u8*)pt1); 	// Pointer to where payload begins storing
	flblkbuff.sw = 0;					// Switch for write/erase
 80005bc:	2000      	movs	r0, #0
	u64* pt2;	// Beginning address of RAM buff
	u64* ptend;	// End+1 of RAM buff

	/* Load block that padd points to into RAM. */
	pt1 = (u64*)((u32)(padd) & ~(flashblocksize - 1)); 	// Block addr of STM32 memory to be loaded
	flblkbuff.base = (u8*)pt1;				// Pointer to beginning of flash block
 80005be:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
	flblkbuff.end = flblkbuff.base + flashblocksize;	// End + 1
 80005c2:	f8c3 4804 	str.w	r4, [r3, #2052]	; 0x804
	flblkbuff.p = &flblkbuff.fb.u8[0] + (padd - (u8*)pt1); 	// Pointer to where payload begins storing
	flblkbuff.sw = 0;					// Switch for write/erase
 80005c6:	f8a3 080c 	strh.w	r0, [r3, #2060]	; 0x80c
	pt2 = &flblkbuff.fb.u64[0];				// RAM buffer for block
	ptend = pt2 + (flashblocksize/sizeof(u64)); 		// End+1 of RAM buffer
 80005ca:	1859      	adds	r1, r3, r1
//printf("P0: %X %X %X\n\r",pt1, pt2, ptend);USART1_txint_send();
	while (pt2 < ptend) *pt2++ = *pt1++; 			// Copy flash to RAM buffer
 80005cc:	e003      	b.n	80005d6 <flashblockinit+0x3a>
 80005ce:	e8f2 4502 	ldrd	r4, r5, [r2], #8
 80005d2:	e8e3 4502 	strd	r4, r5, [r3], #8
 80005d6:	428b      	cmp	r3, r1
 80005d8:	d3f9      	bcc.n	80005ce <flashblockinit+0x32>
//printf("P1: %X %X %X\n\r",pt1, pt2, ptend);USART1_txint_send();
	return;
}
 80005da:	bd30      	pop	{r4, r5, pc}
 80005dc:	20000004 	.word	0x20000004
 80005e0:	20000528 	.word	0x20000528

080005e4 <can_msg_put>:
 * @brief	: send a CAN msg
 * @param	: pcan = pointer to CAN msg
 ******************************************************************************/
static void can_msg_put(struct CANRCVBUF* pcan)
{
	can_driver_put(pctl1, pcan, 4, 0);
 80005e4:	4b03      	ldr	r3, [pc, #12]	; (80005f4 <can_msg_put+0x10>)
 * static void can_msg_put(struct CANRCVBUF* pcan);
 * @brief	: send a CAN msg
 * @param	: pcan = pointer to CAN msg
 ******************************************************************************/
static void can_msg_put(struct CANRCVBUF* pcan)
{
 80005e6:	4601      	mov	r1, r0
	can_driver_put(pctl1, pcan, 4, 0);
 80005e8:	6818      	ldr	r0, [r3, #0]
 80005ea:	2204      	movs	r2, #4
 80005ec:	2300      	movs	r3, #0
 80005ee:	f002 bb27 	b.w	8002c40 <can_driver_put>
 80005f2:	bf00      	nop
 80005f4:	20000518 	.word	0x20000518

080005f8 <sendcanCMD>:
 * @param	: cmd = command code
 ******************************************************************************/
static void sendcanCMD(u8 cmd)
{
	
	can_msg_cmd.dlc = 1;
 80005f8:	4b04      	ldr	r3, [pc, #16]	; (800060c <sendcanCMD+0x14>)
 80005fa:	2201      	movs	r2, #1
	can_msg_cmd.cd.uc[0] = cmd;
 80005fc:	f883 0820 	strb.w	r0, [r3, #2080]	; 0x820
	can_msg_put(&can_msg_cmd);
 8000600:	f503 6000 	add.w	r0, r3, #2048	; 0x800
 8000604:	3018      	adds	r0, #24
 * @param	: cmd = command code
 ******************************************************************************/
static void sendcanCMD(u8 cmd)
{
	
	can_msg_cmd.dlc = 1;
 8000606:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
	can_msg_cmd.cd.uc[0] = cmd;
	can_msg_put(&can_msg_cmd);
 800060a:	e7eb      	b.n	80005e4 <can_msg_put>
 800060c:	20000528 	.word	0x20000528

08000610 <wrblk>:
/* **************************************************************************************
 * static void wrblk(struct CANRCVBUF* pcan);
 * @brief	: Write RAM buffer out to flash
 * ************************************************************************************** */
static void wrblk(struct CANRCVBUF* pcan)
{
 8000610:	b537      	push	{r0, r1, r2, r4, r5, lr}
printf("wrblk: %d %X %X %08X %08X\n\r",debugPctr, padd, pcan->dlc, pcan->cd.ui[0], pcan->cd.ui[1]);USART1_txint_send();
 8000612:	6882      	ldr	r2, [r0, #8]
 8000614:	4c25      	ldr	r4, [pc, #148]	; (80006ac <wrblk+0x9c>)
 8000616:	9200      	str	r2, [sp, #0]
 8000618:	68c2      	ldr	r2, [r0, #12]
/* **************************************************************************************
 * static void wrblk(struct CANRCVBUF* pcan);
 * @brief	: Write RAM buffer out to flash
 * ************************************************************************************** */
static void wrblk(struct CANRCVBUF* pcan)
{
 800061a:	4603      	mov	r3, r0
printf("wrblk: %d %X %X %08X %08X\n\r",debugPctr, padd, pcan->dlc, pcan->cd.ui[0], pcan->cd.ui[1]);USART1_txint_send();
 800061c:	9201      	str	r2, [sp, #4]
 800061e:	f8d4 1828 	ldr.w	r1, [r4, #2088]	; 0x828
 8000622:	4823      	ldr	r0, [pc, #140]	; (80006b0 <wrblk+0xa0>)
 8000624:	f8d4 2810 	ldr.w	r2, [r4, #2064]	; 0x810
 8000628:	685b      	ldr	r3, [r3, #4]
 800062a:	f001 fa9b 	bl	8001b64 <tfp_printf>
 800062e:	f001 fb8f 	bl	8001d50 <USART1_txint_send>

	switch (flblkbuff.sw) 
 8000632:	f8b4 180c 	ldrh.w	r1, [r4, #2060]	; 0x80c
 8000636:	2903      	cmp	r1, #3
 8000638:	d82f      	bhi.n	800069a <wrblk+0x8a>
 800063a:	e8df f001 	tbb	[pc, r1]
 800063e:	1102      	.short	0x1102
 8000640:	0606      	.short	0x0606
	{
	case 0:	// Need to write or erase & write?
printf("wrblk: CASE 0: no need to write block\n\r");USART1_txint_send();
 8000642:	481c      	ldr	r0, [pc, #112]	; (80006b4 <wrblk+0xa4>)
 8000644:	f001 fa8e 	bl	8001b64 <tfp_printf>
 8000648:	e02a      	b.n	80006a0 <wrblk+0x90>
		break;	// No need to write the block

	case 2:
	case 3: // Erase block, then write
printf("wrblk: CASE 2: erase block before writing\n\r");USART1_txint_send();
 800064a:	481b      	ldr	r0, [pc, #108]	; (80006b8 <wrblk+0xa8>)
 800064c:	f001 fa8a 	bl	8001b64 <tfp_printf>
 8000650:	f001 fb7e 	bl	8001d50 <USART1_txint_send>
		can_msg_cmd.cd.uc[2] = flash_erase((u16*)flblkbuff.base);
 8000654:	f8d4 0800 	ldr.w	r0, [r4, #2048]	; 0x800
 8000658:	f001 ff08 	bl	800246c <flash_erase>
 800065c:	f884 0822 	strb.w	r0, [r4, #2082]	; 0x822

	case 1: // Write, but no need for erase
		can_msg_cmd.cd.uc[1] = flash_write( (u16*)flblkbuff.base, &flblkbuff.fb.u16[0], flashblocksize );
 8000660:	4b16      	ldr	r3, [pc, #88]	; (80006bc <wrblk+0xac>)
 8000662:	4d12      	ldr	r5, [pc, #72]	; (80006ac <wrblk+0x9c>)
 8000664:	681a      	ldr	r2, [r3, #0]
 8000666:	4629      	mov	r1, r5
 8000668:	f8d4 0800 	ldr.w	r0, [r4, #2048]	; 0x800
 800066c:	f001 fe92 	bl	8002394 <flash_write>
 8000670:	f884 0821 	strb.w	r0, [r4, #2081]	; 0x821
printf("wrblk: CASE 1: writing block\n\r");USART1_txint_send();
 8000674:	4812      	ldr	r0, [pc, #72]	; (80006c0 <wrblk+0xb0>)
 8000676:	f001 fa75 	bl	8001b64 <tfp_printf>
 800067a:	f001 fb69 	bl	8001d50 <USART1_txint_send>

if ((can_msg_cmd.cd.uc[1] != 0) || (can_msg_cmd.cd.uc[2] != 0))
 800067e:	f8d4 2820 	ldr.w	r2, [r4, #2080]	; 0x820
 8000682:	4b10      	ldr	r3, [pc, #64]	; (80006c4 <wrblk+0xb4>)
 8000684:	ea02 0303 	and.w	r3, r2, r3
 8000688:	b153      	cbz	r3, 80006a0 <wrblk+0x90>
 printf("wrblk: pay[1] %X pay[2] %X\n\r",can_msg_cmd.cd.uc[1], can_msg_cmd.cd.uc[2]);USART1_txint_send();
 800068a:	480f      	ldr	r0, [pc, #60]	; (80006c8 <wrblk+0xb8>)
 800068c:	f895 1821 	ldrb.w	r1, [r5, #2081]	; 0x821
 8000690:	f895 2822 	ldrb.w	r2, [r5, #2082]	; 0x822
 8000694:	f001 fa66 	bl	8001b64 <tfp_printf>
 8000698:	e002      	b.n	80006a0 <wrblk+0x90>
		break;	
	default:
printf("wrblk: default: %d\n\r",flblkbuff.sw);USART1_txint_send();
 800069a:	480c      	ldr	r0, [pc, #48]	; (80006cc <wrblk+0xbc>)
 800069c:	f001 fa62 	bl	8001b64 <tfp_printf>
	}
	return;
}
 80006a0:	b003      	add	sp, #12
 80006a2:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}

if ((can_msg_cmd.cd.uc[1] != 0) || (can_msg_cmd.cd.uc[2] != 0))
 printf("wrblk: pay[1] %X pay[2] %X\n\r",can_msg_cmd.cd.uc[1], can_msg_cmd.cd.uc[2]);USART1_txint_send();
		break;	
	default:
printf("wrblk: default: %d\n\r",flblkbuff.sw);USART1_txint_send();
 80006a6:	f001 bb53 	b.w	8001d50 <USART1_txint_send>
 80006aa:	bf00      	nop
 80006ac:	20000528 	.word	0x20000528
 80006b0:	0800371e 	.word	0x0800371e
 80006b4:	0800373a 	.word	0x0800373a
 80006b8:	08003762 	.word	0x08003762
 80006bc:	20000004 	.word	0x20000004
 80006c0:	0800378e 	.word	0x0800378e
 80006c4:	00ffff00 	.word	0x00ffff00
 80006c8:	080037ad 	.word	0x080037ad
 80006cc:	080037ca 	.word	0x080037ca

080006d0 <canwinch_ldrproto_init>:
 * void canwinch_ldrproto_init(u32 iamunitnumber);
 * @brief	: Initialization for loader
 * @param	: Unit number 
 * ************************************************************************************** */
void canwinch_ldrproto_init(u32 iamunitnumber)
{
 80006d0:	b570      	push	{r4, r5, r6, lr}
	padd = (u8*)(0x08000000);	// Set to something that doesn't give a bad address error
 80006d2:	4c23      	ldr	r4, [pc, #140]	; (8000760 <canwinch_ldrproto_init+0x90>)
 80006d4:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 80006d8:	f8c4 3810 	str.w	r3, [r4, #2064]	; 0x810

	/* Flash block size */
	flashblocksize = (*(u16*)(0x1FFFF7E0)); // Get size of flash in Kbytes
 80006dc:	4b21      	ldr	r3, [pc, #132]	; (8000764 <canwinch_ldrproto_init+0x94>)
 * void canwinch_ldrproto_init(u32 iamunitnumber);
 * @brief	: Initialization for loader
 * @param	: Unit number 
 * ************************************************************************************** */
void canwinch_ldrproto_init(u32 iamunitnumber)
{
 80006de:	4605      	mov	r5, r0
	padd = (u8*)(0x08000000);	// Set to something that doesn't give a bad address error

	/* Flash block size */
	flashblocksize = (*(u16*)(0x1FFFF7E0)); // Get size of flash in Kbytes
 80006e0:	881a      	ldrh	r2, [r3, #0]
 80006e2:	4b21      	ldr	r3, [pc, #132]	; (8000768 <canwinch_ldrproto_init+0x98>)
	if (flashblocksize > 256) 
 80006e4:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
		flashblocksize = 2048;	// XL series flash block size
 80006e8:	bf8c      	ite	hi
 80006ea:	f44f 6100 	movhi.w	r1, #2048	; 0x800
	else
		flashblocksize = 1024;	// Med, and High series flash block size
 80006ee:	f44f 6180 	movls.w	r1, #1024	; 0x400
 80006f2:	6019      	str	r1, [r3, #0]
 * ************************************************************************************** */
static void flbblkbuff_init(void)
{

	/* Assure start address for block is on an even boundary */
	flblkbuff.base = (u8*)((u32)(padd) & (flashblocksize - 1));
 80006f4:	6819      	ldr	r1, [r3, #0]
		flashblocksize = 2048;	// XL series flash block size
	else
		flashblocksize = 1024;	// Med, and High series flash block size

	/* Highest flash address plus one = lowest + (flash size(kbytes) * 1024)  */
	flash_hi = (u8*)(0x08000000 + (u32)((*(u16*)(0x1FFFF7E0)) << 10) );
 80006f6:	0292      	lsls	r2, r2, #10
 * ************************************************************************************** */
static void flbblkbuff_init(void)
{

	/* Assure start address for block is on an even boundary */
	flblkbuff.base = (u8*)((u32)(padd) & (flashblocksize - 1));
 80006f8:	1e4b      	subs	r3, r1, #1
 80006fa:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
		flashblocksize = 2048;	// XL series flash block size
	else
		flashblocksize = 1024;	// Med, and High series flash block size

	/* Highest flash address plus one = lowest + (flash size(kbytes) * 1024)  */
	flash_hi = (u8*)(0x08000000 + (u32)((*(u16*)(0x1FFFF7E0)) << 10) );
 80006fe:	f102 6200 	add.w	r2, r2, #134217728	; 0x8000000
 * ************************************************************************************** */
static void flbblkbuff_init(void)
{

	/* Assure start address for block is on an even boundary */
	flblkbuff.base = (u8*)((u32)(padd) & (flashblocksize - 1));
 8000702:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800
	/* Highest flash address plus one = lowest + (flash size(kbytes) * 1024)  */
	flash_hi = (u8*)(0x08000000 + (u32)((*(u16*)(0x1FFFF7E0)) << 10) );

	flbblkbuff_init(); // Set initial pointer.

printf("FLASH BLK SZE: %d K\n\r",flashblocksize);
 8000706:	4819      	ldr	r0, [pc, #100]	; (800076c <canwinch_ldrproto_init+0x9c>)

	/* Assure start address for block is on an even boundary */
	flblkbuff.base = (u8*)((u32)(padd) & (flashblocksize - 1));

	flblkbuff.p = &flblkbuff.fb.u8[0]; // Pointer into flash block
	flblkbuff.sw = 0;	// need to write, or erase and write, switch
 8000708:	2300      	movs	r3, #0
		flashblocksize = 2048;	// XL series flash block size
	else
		flashblocksize = 1024;	// Med, and High series flash block size

	/* Highest flash address plus one = lowest + (flash size(kbytes) * 1024)  */
	flash_hi = (u8*)(0x08000000 + (u32)((*(u16*)(0x1FFFF7E0)) << 10) );
 800070a:	f8c4 282c 	str.w	r2, [r4, #2092]	; 0x82c

	/* Assure start address for block is on an even boundary */
	flblkbuff.base = (u8*)((u32)(padd) & (flashblocksize - 1));

	flblkbuff.p = &flblkbuff.fb.u8[0]; // Pointer into flash block
	flblkbuff.sw = 0;	// need to write, or erase and write, switch
 800070e:	f8a4 380c 	strh.w	r3, [r4, #2060]	; 0x80c
{

	/* Assure start address for block is on an even boundary */
	flblkbuff.base = (u8*)((u32)(padd) & (flashblocksize - 1));

	flblkbuff.p = &flblkbuff.fb.u8[0]; // Pointer into flash block
 8000712:	f8c4 4808 	str.w	r4, [r4, #2056]	; 0x808
	/* Highest flash address plus one = lowest + (flash size(kbytes) * 1024)  */
	flash_hi = (u8*)(0x08000000 + (u32)((*(u16*)(0x1FFFF7E0)) << 10) );

	flbblkbuff_init(); // Set initial pointer.

printf("FLASH BLK SZE: %d K\n\r",flashblocksize);
 8000716:	f001 fa25 	bl	8001b64 <tfp_printf>
printf("FLASH HI ADDR: %08X\n\r",flash_hi);
 800071a:	f8d4 182c 	ldr.w	r1, [r4, #2092]	; 0x82c
 800071e:	4814      	ldr	r0, [pc, #80]	; (8000770 <canwinch_ldrproto_init+0xa0>)
 8000720:	f001 fa20 	bl	8001b64 <tfp_printf>

	/* Set fixed part of CAN msgs */
//	can_msg_cmd.id = iamunitnumber | (CAN_EXTRID_DATA_CMD << CAN_EXTRID_SHIFT); // Command
	can_msg_cmd.id = iamunitnumber; // Command
	can_msg_rd.id  = iamunitnumber | (CAN_EXTRID_DATA_RD  << CAN_EXTRID_SHIFT); // Read
 8000724:	f045 4330 	orr.w	r3, r5, #2952790016	; 0xb0000000
printf("FLASH BLK SZE: %d K\n\r",flashblocksize);
printf("FLASH HI ADDR: %08X\n\r",flash_hi);

	/* Set fixed part of CAN msgs */
//	can_msg_cmd.id = iamunitnumber | (CAN_EXTRID_DATA_CMD << CAN_EXTRID_SHIFT); // Command
	can_msg_cmd.id = iamunitnumber; // Command
 8000728:	f8c4 5818 	str.w	r5, [r4, #2072]	; 0x818
	can_msg_rd.id  = iamunitnumber | (CAN_EXTRID_DATA_RD  << CAN_EXTRID_SHIFT); // Read
	can_msg_wr.id  = iamunitnumber | (CAN_EXTRID_DATA_WR  << CAN_EXTRID_SHIFT); // Write

printf("CAN ID's\n\r");
 800072c:	4811      	ldr	r0, [pc, #68]	; (8000774 <canwinch_ldrproto_init+0xa4>)

	/* Set fixed part of CAN msgs */
//	can_msg_cmd.id = iamunitnumber | (CAN_EXTRID_DATA_CMD << CAN_EXTRID_SHIFT); // Command
	can_msg_cmd.id = iamunitnumber; // Command
	can_msg_rd.id  = iamunitnumber | (CAN_EXTRID_DATA_RD  << CAN_EXTRID_SHIFT); // Read
	can_msg_wr.id  = iamunitnumber | (CAN_EXTRID_DATA_WR  << CAN_EXTRID_SHIFT); // Write
 800072e:	f045 4540 	orr.w	r5, r5, #3221225472	; 0xc0000000
printf("FLASH HI ADDR: %08X\n\r",flash_hi);

	/* Set fixed part of CAN msgs */
//	can_msg_cmd.id = iamunitnumber | (CAN_EXTRID_DATA_CMD << CAN_EXTRID_SHIFT); // Command
	can_msg_cmd.id = iamunitnumber; // Command
	can_msg_rd.id  = iamunitnumber | (CAN_EXTRID_DATA_RD  << CAN_EXTRID_SHIFT); // Read
 8000732:	f8c4 3830 	str.w	r3, [r4, #2096]	; 0x830
	can_msg_wr.id  = iamunitnumber | (CAN_EXTRID_DATA_WR  << CAN_EXTRID_SHIFT); // Write
 8000736:	f8c4 5840 	str.w	r5, [r4, #2112]	; 0x840

printf("CAN ID's\n\r");
 800073a:	f001 fa13 	bl	8001b64 <tfp_printf>
printf( "CMD: %08X\n\r",can_msg_cmd.id);
 800073e:	f8d4 1818 	ldr.w	r1, [r4, #2072]	; 0x818
 8000742:	480d      	ldr	r0, [pc, #52]	; (8000778 <canwinch_ldrproto_init+0xa8>)
 8000744:	f001 fa0e 	bl	8001b64 <tfp_printf>
printf( "RD : %08X\n\r",can_msg_rd.id);
 8000748:	f8d4 1830 	ldr.w	r1, [r4, #2096]	; 0x830
 800074c:	480b      	ldr	r0, [pc, #44]	; (800077c <canwinch_ldrproto_init+0xac>)
 800074e:	f001 fa09 	bl	8001b64 <tfp_printf>
printf( "WR : %08X\n\r",can_msg_wr.id);
 8000752:	480b      	ldr	r0, [pc, #44]	; (8000780 <canwinch_ldrproto_init+0xb0>)
 8000754:	f8d4 1840 	ldr.w	r1, [r4, #2112]	; 0x840

	return;
}
 8000758:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	can_msg_wr.id  = iamunitnumber | (CAN_EXTRID_DATA_WR  << CAN_EXTRID_SHIFT); // Write

printf("CAN ID's\n\r");
printf( "CMD: %08X\n\r",can_msg_cmd.id);
printf( "RD : %08X\n\r",can_msg_rd.id);
printf( "WR : %08X\n\r",can_msg_wr.id);
 800075c:	f001 ba02 	b.w	8001b64 <tfp_printf>
 8000760:	20000528 	.word	0x20000528
 8000764:	1ffff7e0 	.word	0x1ffff7e0
 8000768:	20000004 	.word	0x20000004
 800076c:	080037df 	.word	0x080037df
 8000770:	080037f5 	.word	0x080037f5
 8000774:	0800380b 	.word	0x0800380b
 8000778:	08003816 	.word	0x08003816
 800077c:	08003822 	.word	0x08003822
 8000780:	0800382e 	.word	0x0800382e

08000784 <mv2>:
 * @brief	: Convert 2 bytes into a 1/2 word
 * u32 mv4(u8* p2);
 * @brief	: Convert 4 bytes into a word

 * ************************************************************************************** */
u16 mv2(u8* p2){ return ( *(p2+1)<<8 | *p2 ); }
 8000784:	7842      	ldrb	r2, [r0, #1]
 8000786:	7803      	ldrb	r3, [r0, #0]
 8000788:	ea43 2002 	orr.w	r0, r3, r2, lsl #8
 800078c:	4770      	bx	lr

0800078e <mv4>:
u32 mv4(u8* p2){ return ( *(p2+3)<<24 | *(p2+2)<<16 | *(p2+1)<<8 | *p2 ); }
 800078e:	7883      	ldrb	r3, [r0, #2]
 8000790:	78c2      	ldrb	r2, [r0, #3]
 8000792:	041b      	lsls	r3, r3, #16
 8000794:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8000798:	7802      	ldrb	r2, [r0, #0]
 800079a:	7840      	ldrb	r0, [r0, #1]
 800079c:	4313      	orrs	r3, r2
 800079e:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 80007a2:	4770      	bx	lr

080007a4 <do_dataread>:
 * void do_dataread(struct CANRCVBUF* p);
 * @brief	: Do something!
 * @param	: Point to message buffer
 * ************************************************************************************** */
void do_dataread(struct CANRCVBUF* p)
{
 80007a4:	b570      	push	{r4, r5, r6, lr}
	u32 i;
	/* We will assume the bozo asking for read has set a valid address.  If the address
           is not valid there might be a hard fault/invalid address crash and a power cycling \
           to recover would be needed. */
	u32 count = p->dlc & 0xf;	// Get the byte count request
 80007a6:	6844      	ldr	r4, [r0, #4]
	
	if (count > 8)
	{ // In case we got a bogus byte count
		count = 8;
	}
	for (i = 0; i < count; i++)
 80007a8:	2300      	movs	r3, #0
{
	u32 i;
	/* We will assume the bozo asking for read has set a valid address.  If the address
           is not valid there might be a hard fault/invalid address crash and a power cycling \
           to recover would be needed. */
	u32 count = p->dlc & 0xf;	// Get the byte count request
 80007aa:	f004 040f 	and.w	r4, r4, #15
 80007ae:	2c08      	cmp	r4, #8
 80007b0:	bf28      	it	cs
 80007b2:	2408      	movcs	r4, #8
	
	if (count > 8)
	{ // In case we got a bogus byte count
		count = 8;
	}
	for (i = 0; i < count; i++)
 80007b4:	e009      	b.n	80007ca <do_dataread+0x26>
	{
		p->cd.uc[i] = *padd++;
 80007b6:	4907      	ldr	r1, [pc, #28]	; (80007d4 <do_dataread+0x30>)
/* **************************************************************************************
 * void do_dataread(struct CANRCVBUF* p);
 * @brief	: Do something!
 * @param	: Point to message buffer
 * ************************************************************************************** */
void do_dataread(struct CANRCVBUF* p)
 80007b8:	18c5      	adds	r5, r0, r3
	{ // In case we got a bogus byte count
		count = 8;
	}
	for (i = 0; i < count; i++)
	{
		p->cd.uc[i] = *padd++;
 80007ba:	f8d1 2810 	ldr.w	r2, [r1, #2064]	; 0x810
	
	if (count > 8)
	{ // In case we got a bogus byte count
		count = 8;
	}
	for (i = 0; i < count; i++)
 80007be:	3301      	adds	r3, #1
	{
		p->cd.uc[i] = *padd++;
 80007c0:	f812 6b01 	ldrb.w	r6, [r2], #1
 80007c4:	722e      	strb	r6, [r5, #8]
 80007c6:	f8c1 2810 	str.w	r2, [r1, #2064]	; 0x810
	
	if (count > 8)
	{ // In case we got a bogus byte count
		count = 8;
	}
	for (i = 0; i < count; i++)
 80007ca:	42a3      	cmp	r3, r4
 80007cc:	d1f3      	bne.n	80007b6 <do_dataread+0x12>
		p->cd.uc[i] = *padd++;
	}
		can_msg_put(p);	// Set it up for tranmission
	
	return;
}
 80007ce:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	}
	for (i = 0; i < count; i++)
	{
		p->cd.uc[i] = *padd++;
	}
		can_msg_put(p);	// Set it up for tranmission
 80007d2:	e707      	b.n	80005e4 <can_msg_put>
 80007d4:	20000528 	.word	0x20000528

080007d8 <addressOK>:
 * @return	: 0 = OK, not zero = bad
 * ************************************************************************************** */
int addressOK(u8* pa)
{
	u32 p;
	if ( ((u32)pa > 0x1FFFE000) && ((u32)pa <= 0x1FFFF80F) ) return 0; // Information block
 80007d8:	4b0b      	ldr	r3, [pc, #44]	; (8000808 <addressOK+0x30>)
 80007da:	f641 020e 	movw	r2, #6158	; 0x180e
 80007de:	18c3      	adds	r3, r0, r3
 80007e0:	4293      	cmp	r3, r2
 80007e2:	d90b      	bls.n	80007fc <addressOK+0x24>
	if (  (u32)pa < 0x08000000) return -1;	// Return below any flash
 80007e4:	f1b0 6f00 	cmp.w	r0, #134217728	; 0x8000000
 80007e8:	d30a      	bcc.n	8000800 <addressOK+0x28>
	p = *(u32*)0x1FFFF7E0;			// Get size of flash in Kbytes
 80007ea:	4b08      	ldr	r3, [pc, #32]	; (800080c <addressOK+0x34>)
 80007ec:	681b      	ldr	r3, [r3, #0]
	p = (p << 10); 				// Multiply by 1024 (K)
	if ((u32)pa > p) return -1;		// Above flash for this part
 80007ee:	ebb0 2f83 	cmp.w	r0, r3, lsl #10
 80007f2:	bf94      	ite	ls
 80007f4:	2000      	movls	r0, #0
 80007f6:	f04f 30ff 	movhi.w	r0, #4294967295
 80007fa:	4770      	bx	lr
 * @return	: 0 = OK, not zero = bad
 * ************************************************************************************** */
int addressOK(u8* pa)
{
	u32 p;
	if ( ((u32)pa > 0x1FFFE000) && ((u32)pa <= 0x1FFFF80F) ) return 0; // Information block
 80007fc:	2000      	movs	r0, #0
 80007fe:	4770      	bx	lr
	if (  (u32)pa < 0x08000000) return -1;	// Return below any flash
 8000800:	f04f 30ff 	mov.w	r0, #4294967295
	p = *(u32*)0x1FFFF7E0;			// Get size of flash in Kbytes
	p = (p << 10); 				// Multiply by 1024 (K)
	if ((u32)pa > p) return -1;		// Above flash for this part
	return 0;
}
 8000804:	4770      	bx	lr
 8000806:	bf00      	nop
 8000808:	e0001fff 	.word	0xe0001fff
 800080c:	1ffff7e0 	.word	0x1ffff7e0

08000810 <do_datawrite>:
/* NOTE: The system block is in flash and is not in the flash address range, so copying it as a
memory address will not change it.  (You shouldn't be messing with it anyway!) */
void do_datawrite(u8* pc, s8 count,struct CANRCVBUF* p)
{

	if (count > 8) 			// Return if count out of range
 8000810:	2908      	cmp	r1, #8
 * @param	: p = CAN msg pointer (for printf & debugging)
 * ************************************************************************************** */
/* NOTE: The system block is in flash and is not in the flash address range, so copying it as a
memory address will not change it.  (You shouldn't be messing with it anyway!) */
void do_datawrite(u8* pc, s8 count,struct CANRCVBUF* p)
{
 8000812:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 8000816:	4605      	mov	r5, r0
 8000818:	460e      	mov	r6, r1
 800081a:	4617      	mov	r7, r2
 800081c:	4c6c      	ldr	r4, [pc, #432]	; (80009d0 <do_datawrite+0x1c0>)

	if (count > 8) 			// Return if count out of range
 800081e:	dd0a      	ble.n	8000836 <do_datawrite+0x26>
		{sendcanCMD(LDR_NACK);
 8000820:	2005      	movs	r0, #5
 8000822:	f7ff fee9 	bl	80005f8 <sendcanCMD>
printf("NACK0: %d %X %d %X %08X %08X\n\r",debugPctr, padd, count, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
 8000826:	687b      	ldr	r3, [r7, #4]
 8000828:	486a      	ldr	r0, [pc, #424]	; (80009d4 <do_datawrite+0x1c4>)
 800082a:	9300      	str	r3, [sp, #0]
 800082c:	68bb      	ldr	r3, [r7, #8]
 800082e:	9301      	str	r3, [sp, #4]
 8000830:	68fb      	ldr	r3, [r7, #12]
 8000832:	9302      	str	r3, [sp, #8]
 8000834:	e011      	b.n	800085a <do_datawrite+0x4a>
return;}

	// Return = No valid address in place
	if (sw_padd == 0) { err_novalidadd += 1; sendcanCMD(LDR_NACK);
 8000836:	f8d4 3850 	ldr.w	r3, [r4, #2128]	; 0x850
 800083a:	b9d3      	cbnz	r3, 8000872 <do_datawrite+0x62>
 800083c:	f8d4 3854 	ldr.w	r3, [r4, #2132]	; 0x854
 8000840:	2005      	movs	r0, #5
 8000842:	3301      	adds	r3, #1
 8000844:	f8c4 3854 	str.w	r3, [r4, #2132]	; 0x854
 8000848:	f7ff fed6 	bl	80005f8 <sendcanCMD>
printf("NAC1K: %d %X %d %X %08X %08X\n\r",debugPctr, padd, count, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
 800084c:	687b      	ldr	r3, [r7, #4]
 800084e:	4862      	ldr	r0, [pc, #392]	; (80009d8 <do_datawrite+0x1c8>)
 8000850:	9300      	str	r3, [sp, #0]
 8000852:	68bb      	ldr	r3, [r7, #8]
 8000854:	9301      	str	r3, [sp, #4]
 8000856:	68fb      	ldr	r3, [r7, #12]
 8000858:	9302      	str	r3, [sp, #8]
 800085a:	f8d4 1828 	ldr.w	r1, [r4, #2088]	; 0x828
 800085e:	f8d4 2810 	ldr.w	r2, [r4, #2064]	; 0x810
 8000862:	4633      	mov	r3, r6
 8000864:	f001 f97e 	bl	8001b64 <tfp_printf>
	{ // Here, not flash address.  Pray that it is a valid address
		copypayload(pc, count);
	}
debugPctr += 1;
	return;
}
 8000868:	b004      	add	sp, #16
 800086a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
printf("NACK0: %d %X %d %X %08X %08X\n\r",debugPctr, padd, count, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
return;}

	// Return = No valid address in place
	if (sw_padd == 0) { err_novalidadd += 1; sendcanCMD(LDR_NACK);
printf("NAC1K: %d %X %d %X %08X %08X\n\r",debugPctr, padd, count, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
 800086e:	f001 ba6f 	b.w	8001d50 <USART1_txint_send>
return;}	
	
	/* Is the address is within the flash bounds.  */
	if ( ((u32)padd >= 0x08000000) && ((u32)padd < (u32)flash_hi) ) 
 8000872:	f8d4 3810 	ldr.w	r3, [r4, #2064]	; 0x810
 8000876:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 800087a:	d34b      	bcc.n	8000914 <do_datawrite+0x104>
 800087c:	f8d4 282c 	ldr.w	r2, [r4, #2092]	; 0x82c
 8000880:	429a      	cmp	r2, r3
 8000882:	d947      	bls.n	8000914 <do_datawrite+0x104>
 8000884:	e043      	b.n	800090e <do_datawrite+0xfe>
static void writepayloadf1(u8* pc, s8 count,struct CANRCVBUF* p)
{
	while (count > 0)	// Loop through the payload
	{	
		/* Is this address for a different block? */
		if (((u32)padd & ~(flashblocksize - 1)) != (u32)flblkbuff.base)
 8000886:	4b55      	ldr	r3, [pc, #340]	; (80009dc <do_datawrite+0x1cc>)
 8000888:	f8d4 2810 	ldr.w	r2, [r4, #2064]	; 0x810
 800088c:	681b      	ldr	r3, [r3, #0]
 800088e:	f8d4 1800 	ldr.w	r1, [r4, #2048]	; 0x800
 8000892:	425b      	negs	r3, r3
 8000894:	ea02 0303 	and.w	r3, r2, r3
 8000898:	428b      	cmp	r3, r1
 800089a:	d009      	beq.n	80008b0 <do_datawrite+0xa0>
		{ // Here, the load address crossed a flash boundary
printf("padd crossed block boundary: %08X  padd: %08x\n\r",(u32)flblkbuff.base, padd);USART1_txint_send();
 800089c:	4850      	ldr	r0, [pc, #320]	; (80009e0 <do_datawrite+0x1d0>)
 800089e:	f001 f961 	bl	8001b64 <tfp_printf>
 80008a2:	f001 fa55 	bl	8001d50 <USART1_txint_send>
			wrblk(p);		// Write RAM buff to flash
 80008a6:	4638      	mov	r0, r7
 80008a8:	f7ff feb2 	bl	8000610 <wrblk>
			flashblockinit();	// Read in new flash block and init some pointers.
 80008ac:	f7ff fe76 	bl	800059c <flashblockinit>
		}

		/* Store one, measly, single, but valuable, byte */
		if (*pc != *padd) // Is new byte different from byte in the flash location?
 80008b0:	f8d4 1810 	ldr.w	r1, [r4, #2064]	; 0x810
 80008b4:	f815 2b01 	ldrb.w	r2, [r5], #1
 80008b8:	7808      	ldrb	r0, [r1, #0]
 80008ba:	4b45      	ldr	r3, [pc, #276]	; (80009d0 <do_datawrite+0x1c0>)
 80008bc:	4290      	cmp	r0, r2
 80008be:	d017      	beq.n	80008f0 <do_datawrite+0xe0>
		{ // Here, yes.  Flag for writing and mabye even erasing
			ldr_phase |= 0x1;	// Show we are going write flash so don't jump to the app unless commanded
 80008c0:	f8d3 2858 	ldr.w	r2, [r3, #2136]	; 0x858
			flblkbuff.sw |= 0x1;	// Show that we have to write (but may or may not need erase)
			if ( (*(u16*)((u32)padd & ~0x1)) != 0xffff)	// Is the 1/2 word already in an erased condtion?
 80008c4:	f021 0101 	bic.w	r1, r1, #1
		}

		/* Store one, measly, single, but valuable, byte */
		if (*pc != *padd) // Is new byte different from byte in the flash location?
		{ // Here, yes.  Flag for writing and mabye even erasing
			ldr_phase |= 0x1;	// Show we are going write flash so don't jump to the app unless commanded
 80008c8:	f042 0201 	orr.w	r2, r2, #1
 80008cc:	f8c3 2858 	str.w	r2, [r3, #2136]	; 0x858
			flblkbuff.sw |= 0x1;	// Show that we have to write (but may or may not need erase)
 80008d0:	f8b3 280c 	ldrh.w	r2, [r3, #2060]	; 0x80c
 80008d4:	f042 0201 	orr.w	r2, r2, #1
 80008d8:	b292      	uxth	r2, r2
 80008da:	f8a3 280c 	strh.w	r2, [r3, #2060]	; 0x80c
			if ( (*(u16*)((u32)padd & ~0x1)) != 0xffff)	// Is the 1/2 word already in an erased condtion?
 80008de:	8808      	ldrh	r0, [r1, #0]
 80008e0:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80008e4:	4288      	cmp	r0, r1
				flblkbuff.sw |= 0x2;	// No, show that we have to erase before write
 80008e6:	bf1c      	itt	ne
 80008e8:	f042 0202 	orrne.w	r2, r2, #2
 80008ec:	f8a3 280c 	strhne.w	r2, [r3, #2060]	; 0x80c
		}
		*flblkbuff.p++ = *pc++;	// Store this golden byte in the ram block buffer
 80008f0:	f815 2c01 	ldrb.w	r2, [r5, #-1]
 80008f4:	f8d4 3808 	ldr.w	r3, [r4, #2056]	; 0x808
 * @param	: count = dlc after masking
 * @param	: p = CAN msg pointer (for printf & debugging)
 * ************************************************************************************** */
/* NOTE: The system block is in flash and is not in the flash address range, so copying it as a
memory address will not change it.  (You shouldn't be messing with it anyway!) */
void do_datawrite(u8* pc, s8 count,struct CANRCVBUF* p)
 80008f8:	3e01      	subs	r6, #1
			ldr_phase |= 0x1;	// Show we are going write flash so don't jump to the app unless commanded
			flblkbuff.sw |= 0x1;	// Show that we have to write (but may or may not need erase)
			if ( (*(u16*)((u32)padd & ~0x1)) != 0xffff)	// Is the 1/2 word already in an erased condtion?
				flblkbuff.sw |= 0x2;	// No, show that we have to erase before write
		}
		*flblkbuff.p++ = *pc++;	// Store this golden byte in the ram block buffer
 80008fa:	f803 2b01 	strb.w	r2, [r3], #1
 80008fe:	f8c4 3808 	str.w	r3, [r4, #2056]	; 0x808
		padd++;			// Advance where the next byte would be placed in flash.
 8000902:	f8d4 3810 	ldr.w	r3, [r4, #2064]	; 0x810
 * @param	: count = dlc after masking
 * @param	: p = CAN msg pointer (for printf & debugging)
 * ************************************************************************************** */
/* NOTE: The system block is in flash and is not in the flash address range, so copying it as a
memory address will not change it.  (You shouldn't be messing with it anyway!) */
void do_datawrite(u8* pc, s8 count,struct CANRCVBUF* p)
 8000906:	b276      	sxtb	r6, r6
			flblkbuff.sw |= 0x1;	// Show that we have to write (but may or may not need erase)
			if ( (*(u16*)((u32)padd & ~0x1)) != 0xffff)	// Is the 1/2 word already in an erased condtion?
				flblkbuff.sw |= 0x2;	// No, show that we have to erase before write
		}
		*flblkbuff.p++ = *pc++;	// Store this golden byte in the ram block buffer
		padd++;			// Advance where the next byte would be placed in flash.
 8000908:	3301      	adds	r3, #1
 800090a:	f8c4 3810 	str.w	r3, [r4, #2064]	; 0x810
 * @param	: count = dlc after masking
 * @param	: p = CAN msg pointer (for printf & debugging)
 * ************************************************************************************** */
static void writepayloadf1(u8* pc, s8 count,struct CANRCVBUF* p)
{
	while (count > 0)	// Loop through the payload
 800090e:	2e00      	cmp	r6, #0
 8000910:	dcb9      	bgt.n	8000886 <do_datawrite+0x76>
 8000912:	e054      	b.n	80009be <do_datawrite+0x1ae>
*/
const u8 table[16] = {2,4,4,8,2,2,2,2,2,4,4,4,2,2,2,2};
static void copypayload(u8* pc, s8 count)
{
	u32 x;
	if (count < 1 ) return;
 8000914:	2e00      	cmp	r6, #0
 8000916:	dd52      	ble.n	80009be <do_datawrite+0x1ae>
	if (count > 8) count = 8;	// JIC	
	count -= 1; // (count = 0 - 7)
 8000918:	1e73      	subs	r3, r6, #1
 800091a:	e04d      	b.n	80009b8 <do_datawrite+0x1a8>

	while (count > 0)	// Loop through the payload
	{
		if ( ((count & 0x1) == 0) || ( ((u32)(padd) & 0x1) != 0) ) // Odd byte count and/or odd address requires byte moves
 800091c:	fa5f f883 	uxtb.w	r8, r3
 8000920:	f018 0f01 	tst.w	r8, #1
 8000924:	d005      	beq.n	8000932 <do_datawrite+0x122>
 8000926:	f8d4 7810 	ldr.w	r7, [r4, #2064]	; 0x810
 800092a:	4e29      	ldr	r6, [pc, #164]	; (80009d0 <do_datawrite+0x1c0>)
 800092c:	f017 0f01 	tst.w	r7, #1
 8000930:	d00a      	beq.n	8000948 <do_datawrite+0x138>
		{ // Here, if either are odd, then we must move one byte at a time.
			*padd++ = *pc++; count -= 1;
 8000932:	f8d4 3810 	ldr.w	r3, [r4, #2064]	; 0x810
 8000936:	f815 2b01 	ldrb.w	r2, [r5], #1
 800093a:	f803 2b01 	strb.w	r2, [r3], #1
 800093e:	f8c4 3810 	str.w	r3, [r4, #2064]	; 0x810
 8000942:	f108 33ff 	add.w	r3, r8, #4294967295
 8000946:	e037      	b.n	80009b8 <do_datawrite+0x1a8>
		}
		else
		{ // Here both count and address are even 
			x = ( ( ( (u32)padd << 1) & 0xc) | ((count >> 1) & 0x3) );
 8000948:	1052      	asrs	r2, r2, #1
 800094a:	0079      	lsls	r1, r7, #1
 800094c:	f001 010c 	and.w	r1, r1, #12
 8000950:	f002 0203 	and.w	r2, r2, #3
			x &= 0x0f; 	// jic!
 8000954:	430a      	orrs	r2, r1
			switch (table[x])
 8000956:	4923      	ldr	r1, [pc, #140]	; (80009e4 <do_datawrite+0x1d4>)
 8000958:	5c8a      	ldrb	r2, [r1, r2]
 800095a:	2a04      	cmp	r2, #4
 800095c:	d010      	beq.n	8000980 <do_datawrite+0x170>
 800095e:	2a08      	cmp	r2, #8
 8000960:	d019      	beq.n	8000996 <do_datawrite+0x186>
 8000962:	2a02      	cmp	r2, #2
 8000964:	d128      	bne.n	80009b8 <do_datawrite+0x1a8>
			{
			case 2:	// Move 1/2 words (2 bytes)
				*(u8*)padd = mv2(pc); padd +=2; pc +=2; count -= 2;
 8000966:	4628      	mov	r0, r5
 8000968:	f7ff ff0c 	bl	8000784 <mv2>
 800096c:	7038      	strb	r0, [r7, #0]
 800096e:	f8d6 3810 	ldr.w	r3, [r6, #2064]	; 0x810
 8000972:	3502      	adds	r5, #2
 8000974:	3302      	adds	r3, #2
 8000976:	f8c6 3810 	str.w	r3, [r6, #2064]	; 0x810
 800097a:	f1a8 0302 	sub.w	r3, r8, #2
 800097e:	e01b      	b.n	80009b8 <do_datawrite+0x1a8>
				break;

			case 4: // Move words (4 bytes)
				*(u32*)padd = mv4(pc); padd +=4; pc +=4; count -= 4;
 8000980:	4628      	mov	r0, r5
 8000982:	f7ff ff04 	bl	800078e <mv4>
 8000986:	f847 0b04 	str.w	r0, [r7], #4
 800098a:	f8c6 7810 	str.w	r7, [r6, #2064]	; 0x810
 800098e:	3504      	adds	r5, #4
 8000990:	f1a8 0304 	sub.w	r3, r8, #4
 8000994:	e010      	b.n	80009b8 <do_datawrite+0x1a8>
				break;

			case 8: // Move double word (8 bytes)
				*(u32*)padd = mv4(pc); padd +=4; pc +=4; // No need to adjust 'count' as we 'return'
 8000996:	4628      	mov	r0, r5
 8000998:	f7ff fef9 	bl	800078e <mv4>
 800099c:	46b8      	mov	r8, r7
 800099e:	f848 0b04 	str.w	r0, [r8], #4
 80009a2:	f8c6 8810 	str.w	r8, [r6, #2064]	; 0x810
				*(u32*)padd = mv4(pc); padd +=4; pc +=4;
 80009a6:	1d28      	adds	r0, r5, #4
 80009a8:	f7ff fef1 	bl	800078e <mv4>
 80009ac:	f108 0304 	add.w	r3, r8, #4
 80009b0:	6078      	str	r0, [r7, #4]
 80009b2:	f8c6 3810 	str.w	r3, [r6, #2064]	; 0x810
 80009b6:	e002      	b.n	80009be <do_datawrite+0x1ae>
	u32 x;
	if (count < 1 ) return;
	if (count > 8) count = 8;	// JIC	
	count -= 1; // (count = 0 - 7)

	while (count > 0)	// Loop through the payload
 80009b8:	b25a      	sxtb	r2, r3
 80009ba:	2a00      	cmp	r2, #0
 80009bc:	dcae      	bgt.n	800091c <do_datawrite+0x10c>
	}
	else
	{ // Here, not flash address.  Pray that it is a valid address
		copypayload(pc, count);
	}
debugPctr += 1;
 80009be:	f8d4 3828 	ldr.w	r3, [r4, #2088]	; 0x828
 80009c2:	3301      	adds	r3, #1
 80009c4:	f8c4 3828 	str.w	r3, [r4, #2088]	; 0x828
	return;
}
 80009c8:	b004      	add	sp, #16
 80009ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80009ce:	bf00      	nop
 80009d0:	20000528 	.word	0x20000528
 80009d4:	0800383a 	.word	0x0800383a
 80009d8:	08003859 	.word	0x08003859
 80009dc:	20000004 	.word	0x20000004
 80009e0:	08003878 	.word	0x08003878
 80009e4:	08003a60 	.word	0x08003a60

080009e8 <do_wrblk>:
/* **************************************************************************************
 * void do_wrblk(struct CANRCVBUF* pcan);
 * @brief	: Write RAM buffer out to flash
 * ************************************************************************************** */
void do_wrblk(struct CANRCVBUF* pcan)
{
 80009e8:	b510      	push	{r4, lr}
	wrblk(pcan);	// Write block to flash
 80009ea:	f7ff fe11 	bl	8000610 <wrblk>

	/* Let PC know the flash write is complete. Send status in payload. */
	can_msg_cmd.dlc = 3;
 80009ee:	4806      	ldr	r0, [pc, #24]	; (8000a08 <do_wrblk+0x20>)
 80009f0:	2303      	movs	r3, #3
 80009f2:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
	can_msg_cmd.cd.uc[0] = LDR_WRBLK;
 80009f6:	3304      	adds	r3, #4
 80009f8:	f880 3820 	strb.w	r3, [r0, #2080]	; 0x820
	can_msg_put(&can_msg_cmd);		// Place in CAN output buffer
 80009fc:	f500 6000 	add.w	r0, r0, #2048	; 0x800
 8000a00:	3018      	adds	r0, #24

	return;
}
 8000a02:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	wrblk(pcan);	// Write block to flash

	/* Let PC know the flash write is complete. Send status in payload. */
	can_msg_cmd.dlc = 3;
	can_msg_cmd.cd.uc[0] = LDR_WRBLK;
	can_msg_put(&can_msg_cmd);		// Place in CAN output buffer
 8000a06:	e5ed      	b.n	80005e4 <can_msg_put>
 8000a08:	20000528 	.word	0x20000528

08000a0c <do_crc>:
 * void do_crc(struct CANRCVBUF* p);
 * @brief	: Compute CRC and send it back
 * @param	: Point to message buffer holding the precious command
 * ************************************************************************************** */
void do_crc(struct CANRCVBUF* p)
{
 8000a0c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	u32 pstart;
	u32 count;
	u32 crc32;

	/* Check that the payload is the correct size: start|end addresses */
	if ((p->dlc & 0x0f) != 8)
 8000a0e:	6841      	ldr	r1, [r0, #4]
 * void do_crc(struct CANRCVBUF* p);
 * @brief	: Compute CRC and send it back
 * @param	: Point to message buffer holding the precious command
 * ************************************************************************************** */
void do_crc(struct CANRCVBUF* p)
{
 8000a10:	4604      	mov	r4, r0
	u32 pstart;
	u32 count;
	u32 crc32;

	/* Check that the payload is the correct size: start|end addresses */
	if ((p->dlc & 0x0f) != 8)
 8000a12:	f001 070f 	and.w	r7, r1, #15
 8000a16:	2f08      	cmp	r7, #8
 8000a18:	d003      	beq.n	8000a22 <do_crc+0x16>
	{ // Send NACK
printf("Send NACK: dlc not 8: %d\n\r",p->dlc);USART1_txint_send();
 8000a1a:	4827      	ldr	r0, [pc, #156]	; (8000ab8 <do_crc+0xac>)
 8000a1c:	f001 f8a2 	bl	8001b64 <tfp_printf>
 8000a20:	e01b      	b.n	8000a5a <do_crc+0x4e>
		 return;
	}
	/* Get start and end addresses from payload */
	count  = (p->cd.ui[0] >> 8);		// Number of bytes to check
 8000a22:	6885      	ldr	r5, [r0, #8]
	pstart = p->cd.ui[1];	// Address to start

	
	/* Check that we are dealing with valid start address and count */
	extern u8* __appoffset;	// Origin of application define in .ld file
	if ((pstart < (u32)(&__appoffset)) || ((u32)(&__appoffset + count) > (u32)flash_hi)) 
 8000a24:	4a25      	ldr	r2, [pc, #148]	; (8000abc <do_crc+0xb0>)
		 return;
	}
	/* Get start and end addresses from payload */
	count  = (p->cd.ui[0] >> 8);		// Number of bytes to check
	count  &= 0x000fffff; 	// Limit the size
	pstart = p->cd.ui[1];	// Address to start
 8000a26:	68c6      	ldr	r6, [r0, #12]
	{ // Send NACK
printf("Send NACK: dlc not 8: %d\n\r",p->dlc);USART1_txint_send();
		 return;
	}
	/* Get start and end addresses from payload */
	count  = (p->cd.ui[0] >> 8);		// Number of bytes to check
 8000a28:	0a2d      	lsrs	r5, r5, #8
	count  &= 0x000fffff; 	// Limit the size
 8000a2a:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
	pstart = p->cd.ui[1];	// Address to start

	
	/* Check that we are dealing with valid start address and count */
	extern u8* __appoffset;	// Origin of application define in .ld file
	if ((pstart < (u32)(&__appoffset)) || ((u32)(&__appoffset + count) > (u32)flash_hi)) 
 8000a2e:	4296      	cmp	r6, r2
printf("Send NACK: dlc not 8: %d\n\r",p->dlc);USART1_txint_send();
		 return;
	}
	/* Get start and end addresses from payload */
	count  = (p->cd.ui[0] >> 8);		// Number of bytes to check
	count  &= 0x000fffff; 	// Limit the size
 8000a30:	f425 0570 	bic.w	r5, r5, #15728640	; 0xf00000
 8000a34:	4613      	mov	r3, r2
 8000a36:	4922      	ldr	r1, [pc, #136]	; (8000ac0 <do_crc+0xb4>)
	pstart = p->cd.ui[1];	// Address to start

	
	/* Check that we are dealing with valid start address and count */
	extern u8* __appoffset;	// Origin of application define in .ld file
	if ((pstart < (u32)(&__appoffset)) || ((u32)(&__appoffset + count) > (u32)flash_hi)) 
 8000a38:	d305      	bcc.n	8000a46 <do_crc+0x3a>
 8000a3a:	f8d1 082c 	ldr.w	r0, [r1, #2092]	; 0x82c
 8000a3e:	eb02 0285 	add.w	r2, r2, r5, lsl #2
 8000a42:	4290      	cmp	r0, r2
 8000a44:	d20e      	bcs.n	8000a64 <do_crc+0x58>
	{ // Send NACK
printf("Send NACK start addr out of range: %08X %X %08X %08X\n\r",pstart, count,(unsigned int)(&__appoffset + count), flash_hi);USART1_txint_send();
 8000a46:	f8d1 282c 	ldr.w	r2, [r1, #2092]	; 0x82c
 8000a4a:	481e      	ldr	r0, [pc, #120]	; (8000ac4 <do_crc+0xb8>)
 8000a4c:	9200      	str	r2, [sp, #0]
 8000a4e:	4631      	mov	r1, r6
 8000a50:	462a      	mov	r2, r5
 8000a52:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 8000a56:	f001 f885 	bl	8001b64 <tfp_printf>
	p->cd.ui[1] = crc32;
	p->cd.uc[0] = LDR_CRC;
	can_msg_put(p);		// Place in CAN output buffer

	return;
}
 8000a5a:	b003      	add	sp, #12
 8000a5c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	
	/* Check that we are dealing with valid start address and count */
	extern u8* __appoffset;	// Origin of application define in .ld file
	if ((pstart < (u32)(&__appoffset)) || ((u32)(&__appoffset + count) > (u32)flash_hi)) 
	{ // Send NACK
printf("Send NACK start addr out of range: %08X %X %08X %08X\n\r",pstart, count,(unsigned int)(&__appoffset + count), flash_hi);USART1_txint_send();
 8000a60:	f001 b976 	b.w	8001d50 <USART1_txint_send>
		return;
	}

if ( (pstart < (u32)0x08004000) ||  ( (pstart + count) > (u32)0x08100000) )
 8000a64:	4b18      	ldr	r3, [pc, #96]	; (8000ac8 <do_crc+0xbc>)
 8000a66:	429e      	cmp	r6, r3
 8000a68:	d903      	bls.n	8000a72 <do_crc+0x66>
 8000a6a:	19aa      	adds	r2, r5, r6
 8000a6c:	f1b2 6f01 	cmp.w	r2, #135266304	; 0x8100000
 8000a70:	d905      	bls.n	8000a7e <do_crc+0x72>
   {printf("Hard Coded address check out-of-range:"); return;}
 8000a72:	4816      	ldr	r0, [pc, #88]	; (8000acc <do_crc+0xc0>)
	p->cd.ui[1] = crc32;
	p->cd.uc[0] = LDR_CRC;
	can_msg_put(p);		// Place in CAN output buffer

	return;
}
 8000a74:	b003      	add	sp, #12
 8000a76:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
printf("Send NACK start addr out of range: %08X %X %08X %08X\n\r",pstart, count,(unsigned int)(&__appoffset + count), flash_hi);USART1_txint_send();
		return;
	}

if ( (pstart < (u32)0x08004000) ||  ( (pstart + count) > (u32)0x08100000) )
   {printf("Hard Coded address check out-of-range:"); return;}
 8000a7a:	f001 b873 	b.w	8001b64 <tfp_printf>

printf("rc_crc32: %08X %08X %08X\n\r",pstart, (pstart+count), count);USART1_txint_send();
 8000a7e:	462b      	mov	r3, r5
 8000a80:	4631      	mov	r1, r6
 8000a82:	4813      	ldr	r0, [pc, #76]	; (8000ad0 <do_crc+0xc4>)
 8000a84:	f001 f86e 	bl	8001b64 <tfp_printf>
 8000a88:	f001 f962 	bl	8001d50 <USART1_txint_send>
	/* Compute the crc and place in msg to be returned. */
	crc32 = rc_crc32((unsigned char*)pstart, count );
 8000a8c:	4629      	mov	r1, r5
 8000a8e:	4630      	mov	r0, r6
 8000a90:	f001 fb82 	bl	8002198 <rc_crc32>
 8000a94:	4605      	mov	r5, r0
printf("Send crc-32: %08X\n\r",crc32);USART1_txint_send();USART1_txint_send();
 8000a96:	4629      	mov	r1, r5
 8000a98:	480e      	ldr	r0, [pc, #56]	; (8000ad4 <do_crc+0xc8>)
 8000a9a:	f001 f863 	bl	8001b64 <tfp_printf>
 8000a9e:	f001 f957 	bl	8001d50 <USART1_txint_send>
 8000aa2:	f001 f955 	bl	8001d50 <USART1_txint_send>

	// Return msg with crc
	p->dlc = 8;
	p->cd.ui[1] = crc32;
	p->cd.uc[0] = LDR_CRC;
 8000aa6:	2303      	movs	r3, #3
	can_msg_put(p);		// Place in CAN output buffer
 8000aa8:	4620      	mov	r0, r4
	/* Compute the crc and place in msg to be returned. */
	crc32 = rc_crc32((unsigned char*)pstart, count );
printf("Send crc-32: %08X\n\r",crc32);USART1_txint_send();USART1_txint_send();

	// Return msg with crc
	p->dlc = 8;
 8000aaa:	6067      	str	r7, [r4, #4]
	p->cd.ui[1] = crc32;
 8000aac:	60e5      	str	r5, [r4, #12]
	p->cd.uc[0] = LDR_CRC;
 8000aae:	7223      	strb	r3, [r4, #8]
	can_msg_put(p);		// Place in CAN output buffer

	return;
}
 8000ab0:	b003      	add	sp, #12
 8000ab2:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}

	// Return msg with crc
	p->dlc = 8;
	p->cd.ui[1] = crc32;
	p->cd.uc[0] = LDR_CRC;
	can_msg_put(p);		// Place in CAN output buffer
 8000ab6:	e595      	b.n	80005e4 <can_msg_put>
 8000ab8:	080038a8 	.word	0x080038a8
 8000abc:	08005000 	.word	0x08005000
 8000ac0:	20000528 	.word	0x20000528
 8000ac4:	080038c3 	.word	0x080038c3
 8000ac8:	08003fff 	.word	0x08003fff
 8000acc:	080038fa 	.word	0x080038fa
 8000ad0:	08003921 	.word	0x08003921
 8000ad4:	0800393c 	.word	0x0800393c

08000ad8 <do_set_addr>:
 * ************************************************************************************** */
void do_set_addr(struct CANRCVBUF* p)
{
	u8* ptmp;

	if ((p->dlc & 0x0f) == 5) // Payload size: cmd byte + 4 byte address
 8000ad8:	6843      	ldr	r3, [r0, #4]
 * void do_set_addr(struct CANRCVBUF* p);
 * @brief	: Check payload and send response as two bytes (command + ACK/NACK)
 * @param	: Point to message buffer holding the precious command
 * ************************************************************************************** */
void do_set_addr(struct CANRCVBUF* p)
{
 8000ada:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	u8* ptmp;

	if ((p->dlc & 0x0f) == 5) // Payload size: cmd byte + 4 byte address
 8000ade:	f003 030f 	and.w	r3, r3, #15
 8000ae2:	2b05      	cmp	r3, #5
 * void do_set_addr(struct CANRCVBUF* p);
 * @brief	: Check payload and send response as two bytes (command + ACK/NACK)
 * @param	: Point to message buffer holding the precious command
 * ************************************************************************************** */
void do_set_addr(struct CANRCVBUF* p)
{
 8000ae4:	4604      	mov	r4, r0
 8000ae6:	4d18      	ldr	r5, [pc, #96]	; (8000b48 <do_set_addr+0x70>)
	u8* ptmp;

	if ((p->dlc & 0x0f) == 5) // Payload size: cmd byte + 4 byte address
 8000ae8:	d122      	bne.n	8000b30 <do_set_addr+0x58>
	{ // 
ldr_phase |= 0x1; // Stop ldr.c from jumping to the app.
 8000aea:	f8d5 3858 	ldr.w	r3, [r5, #2136]	; 0x858
		ptmp = (u8*)mv4(&p->cd.uc[1]);	// Extract address from payload
 8000aee:	3009      	adds	r0, #9
{
	u8* ptmp;

	if ((p->dlc & 0x0f) == 5) // Payload size: cmd byte + 4 byte address
	{ // 
ldr_phase |= 0x1; // Stop ldr.c from jumping to the app.
 8000af0:	f043 0301 	orr.w	r3, r3, #1
 8000af4:	f8c5 3858 	str.w	r3, [r5, #2136]	; 0x858
		ptmp = (u8*)mv4(&p->cd.uc[1]);	// Extract address from payload
 8000af8:	f7ff fe49 	bl	800078e <mv4>
 8000afc:	4606      	mov	r6, r0
		if (addressOK(ptmp) == 0)	// Valid STM32 address?
 8000afe:	f7ff fe6b 	bl	80007d8 <addressOK>
 8000b02:	4607      	mov	r7, r0
 8000b04:	b988      	cbnz	r0, 8000b2a <do_set_addr+0x52>
		{ // Here, yes.  It shouldn't cause a memory fault
			p->cd.uc[1] = LDR_ACK;	// Show it passed all checks
 8000b06:	f04f 0804 	mov.w	r8, #4
			padd = ptmp;		// Save working pointer
			padd_start = padd;	// Save start
			sw_padd = 1;		// Show it was "recently set"			
 8000b0a:	2301      	movs	r3, #1
	{ // 
ldr_phase |= 0x1; // Stop ldr.c from jumping to the app.
		ptmp = (u8*)mv4(&p->cd.uc[1]);	// Extract address from payload
		if (addressOK(ptmp) == 0)	// Valid STM32 address?
		{ // Here, yes.  It shouldn't cause a memory fault
			p->cd.uc[1] = LDR_ACK;	// Show it passed all checks
 8000b0c:	f884 8009 	strb.w	r8, [r4, #9]
			padd = ptmp;		// Save working pointer
 8000b10:	f8c5 6810 	str.w	r6, [r5, #2064]	; 0x810
			padd_start = padd;	// Save start
 8000b14:	f8c5 685c 	str.w	r6, [r5, #2140]	; 0x85c
			sw_padd = 1;		// Show it was "recently set"			
 8000b18:	f8c5 3850 	str.w	r3, [r5, #2128]	; 0x850
			flashblockinit();	//Load block that padd points to into RAM.
 8000b1c:	f7ff fd3e 	bl	800059c <flashblockinit>
			p->cd.uc[1] = LDR_ACK;
 8000b20:	f884 8009 	strb.w	r8, [r4, #9]
debugPctr = 0;
 8000b24:	f8c5 7828 	str.w	r7, [r5, #2088]	; 0x828
 8000b28:	e007      	b.n	8000b3a <do_set_addr+0x62>
		}
		else
			p->cd.uc[1] = LDR_ADDR_OOB; // Failed the address check					
 8000b2a:	230c      	movs	r3, #12
 8000b2c:	7263      	strb	r3, [r4, #9]
 8000b2e:	e004      	b.n	8000b3a <do_set_addr+0x62>
	}
	else
	{ // Here, dlc size wrong
		sw_padd = 0;	// Don't be storing stuff in bogus addresses
 8000b30:	2300      	movs	r3, #0
 8000b32:	f8c5 3850 	str.w	r3, [r5, #2128]	; 0x850
		p->cd.uc[1] = LDR_DLC_ERR;			
 8000b36:	330d      	adds	r3, #13
 8000b38:	7243      	strb	r3, [r0, #9]
	}
	/* Send response */
	p->dlc = 2;
 8000b3a:	2302      	movs	r3, #2
	can_msg_put(p);	// Place in CAN output buffer
 8000b3c:	4620      	mov	r0, r4
	{ // Here, dlc size wrong
		sw_padd = 0;	// Don't be storing stuff in bogus addresses
		p->cd.uc[1] = LDR_DLC_ERR;			
	}
	/* Send response */
	p->dlc = 2;
 8000b3e:	6063      	str	r3, [r4, #4]
	can_msg_put(p);	// Place in CAN output buffer
	return;
}
 8000b40:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		sw_padd = 0;	// Don't be storing stuff in bogus addresses
		p->cd.uc[1] = LDR_DLC_ERR;			
	}
	/* Send response */
	p->dlc = 2;
	can_msg_put(p);	// Place in CAN output buffer
 8000b44:	e54e      	b.n	80005e4 <can_msg_put>
 8000b46:	bf00      	nop
 8000b48:	20000528 	.word	0x20000528

08000b4c <do_flashsize>:
 * @brief	: Send flashsize
 * @param	: Point to message buffer holding the imperial command
 * ************************************************************************************** */
void do_flashsize(struct CANRCVBUF* p)
{
	p->dlc = 3;	// Command plus short
 8000b4c:	2303      	movs	r3, #3
 * void do_flashsize(struct CANRCVBUF* p);
 * @brief	: Send flashsize
 * @param	: Point to message buffer holding the imperial command
 * ************************************************************************************** */
void do_flashsize(struct CANRCVBUF* p)
{
 8000b4e:	b513      	push	{r0, r1, r4, lr}
	p->dlc = 3;	// Command plus short
 8000b50:	6043      	str	r3, [r0, #4]
	p->cd.uc[1] = flashblocksize;	
 8000b52:	4b0a      	ldr	r3, [pc, #40]	; (8000b7c <do_flashsize+0x30>)
 * void do_flashsize(struct CANRCVBUF* p);
 * @brief	: Send flashsize
 * @param	: Point to message buffer holding the imperial command
 * ************************************************************************************** */
void do_flashsize(struct CANRCVBUF* p)
{
 8000b54:	4604      	mov	r4, r0
	p->dlc = 3;	// Command plus short
	p->cd.uc[1] = flashblocksize;	
 8000b56:	6819      	ldr	r1, [r3, #0]
 8000b58:	b2cb      	uxtb	r3, r1
 8000b5a:	7243      	strb	r3, [r0, #9]
	p->cd.uc[2] = flashblocksize >> 8;
 8000b5c:	0a08      	lsrs	r0, r1, #8
 8000b5e:	b2c0      	uxtb	r0, r0
 8000b60:	72a0      	strb	r0, [r4, #10]
printf("X: flashblocksize: %X %X %X %X\n\r",flashblocksize, p->cd.uc[0],p->cd.uc[1],p->cd.uc[2]);USART1_txint_send();
 8000b62:	7a22      	ldrb	r2, [r4, #8]
 8000b64:	9000      	str	r0, [sp, #0]
 8000b66:	4806      	ldr	r0, [pc, #24]	; (8000b80 <do_flashsize+0x34>)
 8000b68:	f000 fffc 	bl	8001b64 <tfp_printf>
 8000b6c:	f001 f8f0 	bl	8001d50 <USART1_txint_send>
	can_msg_put(p);	// Place in CAN output buffer
 8000b70:	4620      	mov	r0, r4
	return;
}
 8000b72:	b002      	add	sp, #8
 8000b74:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
{
	p->dlc = 3;	// Command plus short
	p->cd.uc[1] = flashblocksize;	
	p->cd.uc[2] = flashblocksize >> 8;
printf("X: flashblocksize: %X %X %X %X\n\r",flashblocksize, p->cd.uc[0],p->cd.uc[1],p->cd.uc[2]);USART1_txint_send();
	can_msg_put(p);	// Place in CAN output buffer
 8000b78:	e534      	b.n	80005e4 <can_msg_put>
 8000b7a:	bf00      	nop
 8000b7c:	20000004 	.word	0x20000004
 8000b80:	08003950 	.word	0x08003950

08000b84 <do_rd4>:
 * void do_rd4(struct CANRCVBUF* p);
 * @brief	: Send 4 bytes from starting address contained in payload
 * @param	: Point to message buffer holding the imperial command
 * ************************************************************************************** */
void do_rd4(struct CANRCVBUF* p)
{
 8000b84:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 8000b86:	4604      	mov	r4, r0
	u8* rdaddr = (u8*)mv4(&p->cd.uc[1]); // Get bytes 1-4 into a word
 8000b88:	3009      	adds	r0, #9
 8000b8a:	f7ff fe00 	bl	800078e <mv4>
	p->dlc = 5;	// Command plus char*
 8000b8e:	2305      	movs	r3, #5
 8000b90:	6063      	str	r3, [r4, #4]
	p->cd.uc[1] = *rdaddr++;
 8000b92:	4602      	mov	r2, r0
 8000b94:	f812 3b01 	ldrb.w	r3, [r2], #1
 8000b98:	7263      	strb	r3, [r4, #9]
	p->cd.uc[2] = *rdaddr++;
 8000b9a:	7846      	ldrb	r6, [r0, #1]
 8000b9c:	1c51      	adds	r1, r2, #1
 8000b9e:	72a6      	strb	r6, [r4, #10]
	p->cd.uc[3] = *rdaddr++;
 8000ba0:	7855      	ldrb	r5, [r2, #1]
	p->cd.uc[4] = *rdaddr;
printf("R4: read addr: %X %X %X %X %X %X\n\r",(u32)rdaddr, p->cd.uc[0],p->cd.uc[1],p->cd.uc[2],p->cd.uc[3],p->cd.uc[4]);USART1_txint_send();
 8000ba2:	3101      	adds	r1, #1
{
	u8* rdaddr = (u8*)mv4(&p->cd.uc[1]); // Get bytes 1-4 into a word
	p->dlc = 5;	// Command plus char*
	p->cd.uc[1] = *rdaddr++;
	p->cd.uc[2] = *rdaddr++;
	p->cd.uc[3] = *rdaddr++;
 8000ba4:	72e5      	strb	r5, [r4, #11]
	p->cd.uc[4] = *rdaddr;
 8000ba6:	7890      	ldrb	r0, [r2, #2]
printf("R4: read addr: %X %X %X %X %X %X\n\r",(u32)rdaddr, p->cd.uc[0],p->cd.uc[1],p->cd.uc[2],p->cd.uc[3],p->cd.uc[4]);USART1_txint_send();
 8000ba8:	7a22      	ldrb	r2, [r4, #8]
	u8* rdaddr = (u8*)mv4(&p->cd.uc[1]); // Get bytes 1-4 into a word
	p->dlc = 5;	// Command plus char*
	p->cd.uc[1] = *rdaddr++;
	p->cd.uc[2] = *rdaddr++;
	p->cd.uc[3] = *rdaddr++;
	p->cd.uc[4] = *rdaddr;
 8000baa:	7320      	strb	r0, [r4, #12]
printf("R4: read addr: %X %X %X %X %X %X\n\r",(u32)rdaddr, p->cd.uc[0],p->cd.uc[1],p->cd.uc[2],p->cd.uc[3],p->cd.uc[4]);USART1_txint_send();
 8000bac:	9002      	str	r0, [sp, #8]
 8000bae:	4806      	ldr	r0, [pc, #24]	; (8000bc8 <do_rd4+0x44>)
 8000bb0:	9600      	str	r6, [sp, #0]
 8000bb2:	9501      	str	r5, [sp, #4]
 8000bb4:	f000 ffd6 	bl	8001b64 <tfp_printf>
 8000bb8:	f001 f8ca 	bl	8001d50 <USART1_txint_send>
	can_msg_put(p);	// Place in CAN output buffer
 8000bbc:	4620      	mov	r0, r4
	return;
}
 8000bbe:	b004      	add	sp, #16
 8000bc0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	p->cd.uc[1] = *rdaddr++;
	p->cd.uc[2] = *rdaddr++;
	p->cd.uc[3] = *rdaddr++;
	p->cd.uc[4] = *rdaddr;
printf("R4: read addr: %X %X %X %X %X %X\n\r",(u32)rdaddr, p->cd.uc[0],p->cd.uc[1],p->cd.uc[2],p->cd.uc[3],p->cd.uc[4]);USART1_txint_send();
	can_msg_put(p);	// Place in CAN output buffer
 8000bc4:	e50e      	b.n	80005e4 <can_msg_put>
 8000bc6:	bf00      	nop
 8000bc8:	08003971 	.word	0x08003971

08000bcc <do_getfromdaddress>:
 * @brief	: Return msg with 4 bytes in payload uc[1-4] from address d
 * @param	: p = pointer to message buffer holding the imperial command
 * @param	: rdaddr = address to use 
 * ************************************************************************************** */
void do_getfromdaddress(struct CANRCVBUF* p, u8* rdaddr)
{
 8000bcc:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8000bce:	4604      	mov	r4, r0
	if (addressOK(rdaddr) != 0)
 8000bd0:	4608      	mov	r0, r1
 * @brief	: Return msg with 4 bytes in payload uc[1-4] from address d
 * @param	: p = pointer to message buffer holding the imperial command
 * @param	: rdaddr = address to use 
 * ************************************************************************************** */
void do_getfromdaddress(struct CANRCVBUF* p, u8* rdaddr)
{
 8000bd2:	460d      	mov	r5, r1
	if (addressOK(rdaddr) != 0)
 8000bd4:	f7ff fe00 	bl	80007d8 <addressOK>
 8000bd8:	b140      	cbz	r0, 8000bec <do_getfromdaddress+0x20>
	{printf("do_getfromdaddress: addr not OK: %08X\n\r",rdaddr);USART1_txint_send(); return;}
 8000bda:	4811      	ldr	r0, [pc, #68]	; (8000c20 <do_getfromdaddress+0x54>)
 8000bdc:	4629      	mov	r1, r5
 8000bde:	f000 ffc1 	bl	8001b64 <tfp_printf>
	p->cd.uc[3] = *rdaddr++;
	p->cd.uc[4] = *rdaddr;
printf("GETADDR: read addr: %X %X %X %X %X\n\r", p->cd.uc[0],p->cd.uc[1],p->cd.uc[2],p->cd.uc[3],p->cd.uc[4]);USART1_txint_send();
	can_msg_put(p);	// Place in CAN output buffer
	return;
}
 8000be2:	b003      	add	sp, #12
 8000be4:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 * @param	: rdaddr = address to use 
 * ************************************************************************************** */
void do_getfromdaddress(struct CANRCVBUF* p, u8* rdaddr)
{
	if (addressOK(rdaddr) != 0)
	{printf("do_getfromdaddress: addr not OK: %08X\n\r",rdaddr);USART1_txint_send(); return;}
 8000be8:	f001 b8b2 	b.w	8001d50 <USART1_txint_send>

	p->dlc = 5;	// Command plus addr
 8000bec:	2305      	movs	r3, #5
 8000bee:	6063      	str	r3, [r4, #4]
	p->cd.uc[1] = *rdaddr++;
 8000bf0:	4629      	mov	r1, r5
 8000bf2:	f811 2b01 	ldrb.w	r2, [r1], #1
 8000bf6:	7262      	strb	r2, [r4, #9]
	p->cd.uc[2] = *rdaddr++;
 8000bf8:	786b      	ldrb	r3, [r5, #1]
 8000bfa:	72a3      	strb	r3, [r4, #10]
	p->cd.uc[3] = *rdaddr++;
 8000bfc:	784d      	ldrb	r5, [r1, #1]
 8000bfe:	72e5      	strb	r5, [r4, #11]
	p->cd.uc[4] = *rdaddr;
 8000c00:	7888      	ldrb	r0, [r1, #2]
printf("GETADDR: read addr: %X %X %X %X %X\n\r", p->cd.uc[0],p->cd.uc[1],p->cd.uc[2],p->cd.uc[3],p->cd.uc[4]);USART1_txint_send();
 8000c02:	7a21      	ldrb	r1, [r4, #8]

	p->dlc = 5;	// Command plus addr
	p->cd.uc[1] = *rdaddr++;
	p->cd.uc[2] = *rdaddr++;
	p->cd.uc[3] = *rdaddr++;
	p->cd.uc[4] = *rdaddr;
 8000c04:	7320      	strb	r0, [r4, #12]
printf("GETADDR: read addr: %X %X %X %X %X\n\r", p->cd.uc[0],p->cd.uc[1],p->cd.uc[2],p->cd.uc[3],p->cd.uc[4]);USART1_txint_send();
 8000c06:	9001      	str	r0, [sp, #4]
 8000c08:	4806      	ldr	r0, [pc, #24]	; (8000c24 <do_getfromdaddress+0x58>)
 8000c0a:	9500      	str	r5, [sp, #0]
 8000c0c:	f000 ffaa 	bl	8001b64 <tfp_printf>
 8000c10:	f001 f89e 	bl	8001d50 <USART1_txint_send>
	can_msg_put(p);	// Place in CAN output buffer
 8000c14:	4620      	mov	r0, r4
	return;
}
 8000c16:	b003      	add	sp, #12
 8000c18:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	p->cd.uc[1] = *rdaddr++;
	p->cd.uc[2] = *rdaddr++;
	p->cd.uc[3] = *rdaddr++;
	p->cd.uc[4] = *rdaddr;
printf("GETADDR: read addr: %X %X %X %X %X\n\r", p->cd.uc[0],p->cd.uc[1],p->cd.uc[2],p->cd.uc[3],p->cd.uc[4]);USART1_txint_send();
	can_msg_put(p);	// Place in CAN output buffer
 8000c1c:	e4e2      	b.n	80005e4 <can_msg_put>
 8000c1e:	bf00      	nop
 8000c20:	08003994 	.word	0x08003994
 8000c24:	080039bc 	.word	0x080039bc

08000c28 <do_send4>:
 * @brief	: Send 4 bytes
 * @param	: Point to message buffer holding the imperial command
 * @param	: n = 4 byte number
 * ************************************************************************************** */
void do_send4(struct CANRCVBUF* p, u32 n)
{
 8000c28:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	p->dlc = 5;	// Command plus char*
	p->cd.uc[1] = n;
	p->cd.uc[2] = n >> 8;
 8000c2a:	0a0e      	lsrs	r6, r1, #8
	p->cd.uc[3] = n >> 16;
 8000c2c:	0c0d      	lsrs	r5, r1, #16
 * @param	: Point to message buffer holding the imperial command
 * @param	: n = 4 byte number
 * ************************************************************************************** */
void do_send4(struct CANRCVBUF* p, u32 n)
{
	p->dlc = 5;	// Command plus char*
 8000c2e:	2305      	movs	r3, #5
 8000c30:	6043      	str	r3, [r0, #4]
	p->cd.uc[1] = n;
	p->cd.uc[2] = n >> 8;
 8000c32:	b2f6      	uxtb	r6, r6
 * @param	: n = 4 byte number
 * ************************************************************************************** */
void do_send4(struct CANRCVBUF* p, u32 n)
{
	p->dlc = 5;	// Command plus char*
	p->cd.uc[1] = n;
 8000c34:	b2cb      	uxtb	r3, r1
	p->cd.uc[2] = n >> 8;
	p->cd.uc[3] = n >> 16;
 8000c36:	b2ed      	uxtb	r5, r5
 * @param	: n = 4 byte number
 * ************************************************************************************** */
void do_send4(struct CANRCVBUF* p, u32 n)
{
	p->dlc = 5;	// Command plus char*
	p->cd.uc[1] = n;
 8000c38:	7243      	strb	r3, [r0, #9]
	p->cd.uc[2] = n >> 8;
 8000c3a:	7286      	strb	r6, [r0, #10]
	p->cd.uc[3] = n >> 16;
 8000c3c:	72c5      	strb	r5, [r0, #11]
 * @brief	: Send 4 bytes
 * @param	: Point to message buffer holding the imperial command
 * @param	: n = 4 byte number
 * ************************************************************************************** */
void do_send4(struct CANRCVBUF* p, u32 n)
{
 8000c3e:	4604      	mov	r4, r0
	p->dlc = 5;	// Command plus char*
	p->cd.uc[1] = n;
	p->cd.uc[2] = n >> 8;
	p->cd.uc[3] = n >> 16;
	p->cd.uc[4] = n >> 24;
 8000c40:	0e08      	lsrs	r0, r1, #24
 8000c42:	7320      	strb	r0, [r4, #12]
printf("send4: %X %X %X %X %X %X\n\r", n, p->cd.uc[0],p->cd.uc[1],p->cd.uc[2],p->cd.uc[3],p->cd.uc[4]);USART1_txint_send();
 8000c44:	7a22      	ldrb	r2, [r4, #8]
 8000c46:	9002      	str	r0, [sp, #8]
 8000c48:	4805      	ldr	r0, [pc, #20]	; (8000c60 <do_send4+0x38>)
 8000c4a:	9600      	str	r6, [sp, #0]
 8000c4c:	9501      	str	r5, [sp, #4]
 8000c4e:	f000 ff89 	bl	8001b64 <tfp_printf>
 8000c52:	f001 f87d 	bl	8001d50 <USART1_txint_send>
	can_msg_put(p);	// Place in CAN output buffer
 8000c56:	4620      	mov	r0, r4
	return;
}
 8000c58:	b004      	add	sp, #16
 8000c5a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	p->cd.uc[1] = n;
	p->cd.uc[2] = n >> 8;
	p->cd.uc[3] = n >> 16;
	p->cd.uc[4] = n >> 24;
printf("send4: %X %X %X %X %X %X\n\r", n, p->cd.uc[0],p->cd.uc[1],p->cd.uc[2],p->cd.uc[3],p->cd.uc[4]);USART1_txint_send();
	can_msg_put(p);	// Place in CAN output buffer
 8000c5e:	e4c1      	b.n	80005e4 <can_msg_put>
 8000c60:	080039e1 	.word	0x080039e1

08000c64 <do_getflashpaddr>:
extern u8* __highflashp;
extern u8* __highflashlayout;

void do_getflashpaddr(struct CANRCVBUF* p)
{
	p->dlc = 8;	// Command plus addr
 8000c64:	2308      	movs	r3, #8
extern u8* __appoffset;
extern u8* __highflashp;
extern u8* __highflashlayout;

void do_getflashpaddr(struct CANRCVBUF* p)
{
 8000c66:	b570      	push	{r4, r5, r6, lr}
	p->dlc = 8;	// Command plus addr
 8000c68:	6043      	str	r3, [r0, #4]

	extern void* __appjump;	// Defined in ldr.ld file
	u32* ppflashp = (u32*)((u32)((u8*)*&__appjump + 7 + 0));	// Points to "size"
 8000c6a:	4b12      	ldr	r3, [pc, #72]	; (8000cb4 <do_getflashpaddr+0x50>)
extern u8* __appoffset;
extern u8* __highflashp;
extern u8* __highflashlayout;

void do_getflashpaddr(struct CANRCVBUF* p)
{
 8000c6c:	4604      	mov	r4, r0
	p->dlc = 8;	// Command plus addr

	extern void* __appjump;	// Defined in ldr.ld file
	u32* ppflashp = (u32*)((u32)((u8*)*&__appjump + 7 + 0));	// Points to "size"
 8000c6e:	681b      	ldr	r3, [r3, #0]

	if (size > 0x000fffff) size = 0x000fffff; // Only 3 bytes allowed for size (and < 1 MB)

	/* Payload [0] = cmd code; [1] - [3] = size; [4] - [7] = FLASHP address */
	u8 tmp = p->cd.uc[0];
	p->cd.ui[0] = (size << 8);	
 8000c70:	4911      	ldr	r1, [pc, #68]	; (8000cb8 <do_getflashpaddr+0x54>)
	p->dlc = 8;	// Command plus addr

	extern void* __appjump;	// Defined in ldr.ld file
	u32* ppflashp = (u32*)((u32)((u8*)*&__appjump + 7 + 0));	// Points to "size"
	
	u32 size = *ppflashp;		// Get size
 8000c72:	f8d3 0007 	ldr.w	r0, [r3, #7]
	u32 pflashp = *(ppflashp + 1);	// Get pointer to FLASHP and beginning of app struct

	if (size > 0x000fffff) size = 0x000fffff; // Only 3 bytes allowed for size (and < 1 MB)

	/* Payload [0] = cmd code; [1] - [3] = size; [4] - [7] = FLASHP address */
	u8 tmp = p->cd.uc[0];
 8000c76:	7a22      	ldrb	r2, [r4, #8]

	extern void* __appjump;	// Defined in ldr.ld file
	u32* ppflashp = (u32*)((u32)((u8*)*&__appjump + 7 + 0));	// Points to "size"
	
	u32 size = *ppflashp;		// Get size
	u32 pflashp = *(ppflashp + 1);	// Get pointer to FLASHP and beginning of app struct
 8000c78:	f8d3 300b 	ldr.w	r3, [r3, #11]

	if (size > 0x000fffff) size = 0x000fffff; // Only 3 bytes allowed for size (and < 1 MB)

	/* Payload [0] = cmd code; [1] - [3] = size; [4] - [7] = FLASHP address */
	u8 tmp = p->cd.uc[0];
	p->cd.ui[0] = (size << 8);	
 8000c7c:	4288      	cmp	r0, r1
 8000c7e:	bf38      	it	cc
 8000c80:	4601      	movcc	r1, r0
 8000c82:	0209      	lsls	r1, r1, #8
 8000c84:	60a1      	str	r1, [r4, #8]
	p->cd.uc[0] = tmp;
	p->cd.ui[1] = pflashp;
 8000c86:	60e3      	str	r3, [r4, #12]
	if (size > 0x000fffff) size = 0x000fffff; // Only 3 bytes allowed for size (and < 1 MB)

	/* Payload [0] = cmd code; [1] - [3] = size; [4] - [7] = FLASHP address */
	u8 tmp = p->cd.uc[0];
	p->cd.ui[0] = (size << 8);	
	p->cd.uc[0] = tmp;
 8000c88:	7222      	strb	r2, [r4, #8]
	p->cd.ui[1] = pflashp;

int i;printf("GET FLASHP addr ");
 8000c8a:	480c      	ldr	r0, [pc, #48]	; (8000cbc <do_getflashpaddr+0x58>)
 8000c8c:	f000 ff6a 	bl	8001b64 <tfp_printf>
for (i = 0; i < 8; i++) printf(" %X",p->cd.uc[i]); 
 8000c90:	2500      	movs	r5, #0
 * ************************************************************************************** */
extern u8* __appoffset;
extern u8* __highflashp;
extern u8* __highflashlayout;

void do_getflashpaddr(struct CANRCVBUF* p)
 8000c92:	1963      	adds	r3, r4, r5
	p->cd.ui[0] = (size << 8);	
	p->cd.uc[0] = tmp;
	p->cd.ui[1] = pflashp;

int i;printf("GET FLASHP addr ");
for (i = 0; i < 8; i++) printf(" %X",p->cd.uc[i]); 
 8000c94:	480a      	ldr	r0, [pc, #40]	; (8000cc0 <do_getflashpaddr+0x5c>)
 8000c96:	7a19      	ldrb	r1, [r3, #8]
 8000c98:	3501      	adds	r5, #1
 8000c9a:	f000 ff63 	bl	8001b64 <tfp_printf>
 8000c9e:	2d08      	cmp	r5, #8
 8000ca0:	d1f7      	bne.n	8000c92 <do_getflashpaddr+0x2e>
printf("\n\r"); USART1_txint_send();
 8000ca2:	4808      	ldr	r0, [pc, #32]	; (8000cc4 <do_getflashpaddr+0x60>)
 8000ca4:	f000 ff5e 	bl	8001b64 <tfp_printf>
 8000ca8:	f001 f852 	bl	8001d50 <USART1_txint_send>

	can_msg_put(p);	// Place in CAN output buffer
 8000cac:	4620      	mov	r0, r4
	return;
}
 8000cae:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

int i;printf("GET FLASHP addr ");
for (i = 0; i < 8; i++) printf(" %X",p->cd.uc[i]); 
printf("\n\r"); USART1_txint_send();

	can_msg_put(p);	// Place in CAN output buffer
 8000cb2:	e497      	b.n	80005e4 <can_msg_put>
 8000cb4:	08005004 	.word	0x08005004
 8000cb8:	000fffff 	.word	0x000fffff
 8000cbc:	080039fc 	.word	0x080039fc
 8000cc0:	08003a0d 	.word	0x08003a0d
 8000cc4:	08003552 	.word	0x08003552

08000cc8 <do_cmd_cmd>:
 * void do_cmd_cmd(struct CANRCVBUF* p);
 * @brief	: Do something!
 * @param	: p = pointer to message buffer
 * ************************************************************************************** */
void do_cmd_cmd(struct CANRCVBUF* p)
{
 8000cc8:	b507      	push	{r0, r1, r2, lr}
	#define LDR_WRVAL_AI	22	// 8 Write: 2=memory area; 3-4=index; 5-8=one 4 byte value

*/
//printf("Q: %02X\n\r",p->cd.uc[0]); USART1_txint_send(); // Debug: Display command codes coming in
	/* Here, we have a command in the ID field. */
	switch (p->cd.uc[0])	// Command code
 8000cca:	7a01      	ldrb	r1, [r0, #8]
 * void do_cmd_cmd(struct CANRCVBUF* p);
 * @brief	: Do something!
 * @param	: p = pointer to message buffer
 * ************************************************************************************** */
void do_cmd_cmd(struct CANRCVBUF* p)
{
 8000ccc:	4603      	mov	r3, r0
	#define LDR_WRVAL_AI	22	// 8 Write: 2=memory area; 3-4=index; 5-8=one 4 byte value

*/
//printf("Q: %02X\n\r",p->cd.uc[0]); USART1_txint_send(); // Debug: Display command codes coming in
	/* Here, we have a command in the ID field. */
	switch (p->cd.uc[0])	// Command code
 8000cce:	1e4a      	subs	r2, r1, #1
 8000cd0:	2a14      	cmp	r2, #20
 8000cd2:	d862      	bhi.n	8000d9a <do_cmd_cmd+0xd2>
 8000cd4:	e8df f012 	tbh	[pc, r2, lsl #1]
 8000cd8:	00610015 	.word	0x00610015
 8000cdc:	00750030 	.word	0x00750030
 8000ce0:	001a0075 	.word	0x001a0075
 8000ce4:	00290024 	.word	0x00290024
 8000ce8:	00750075 	.word	0x00750075
 8000cec:	00610035 	.word	0x00610035
 8000cf0:	003a0061 	.word	0x003a0061
 8000cf4:	00450040 	.word	0x00450040
 8000cf8:	004e0048 	.word	0x004e0048
 8000cfc:	00610061 	.word	0x00610061
 8000d00:	0053      	.short	0x0053
	{
	case LDR_SET_ADDR: // Set address pointer (bytes 2-5):  Respond with last written address.
		do_set_addr(p);
 8000d02:	4618      	mov	r0, r3
		err_bogus_cmds_cmds += 1;
printf("BOGUS CMD CODE: %X %08X %X  %08X %08X\n\r",p->cd.uc[0], p->id, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
		break;
	}
	return;
}
 8000d04:	b003      	add	sp, #12
 8000d06:	f85d eb04 	ldr.w	lr, [sp], #4
//printf("Q: %02X\n\r",p->cd.uc[0]); USART1_txint_send(); // Debug: Display command codes coming in
	/* Here, we have a command in the ID field. */
	switch (p->cd.uc[0])	// Command code
	{
	case LDR_SET_ADDR: // Set address pointer (bytes 2-5):  Respond with last written address.
		do_set_addr(p);
 8000d0a:	e6e5      	b.n	8000ad8 <do_set_addr>
static int do_jump(struct CANRCVBUF* p)
{
	u32 appjump;

	/* Check for correct number of bytes in payload. */
	if (p->dlc != 4) return -1;
 8000d0c:	685a      	ldr	r2, [r3, #4]
 8000d0e:	2a04      	cmp	r2, #4
 8000d10:	d157      	bne.n	8000dc2 <do_cmd_cmd+0xfa>

	/* Convert byte array to 4 byte unsigned int */
	 appjump = mv4(&p->cd.u8[0]); 
 8000d12:	f103 0008 	add.w	r0, r3, #8
 8000d16:	f7ff fd3a 	bl	800078e <mv4>

	(*(  (void (**)(void))appjump)  )();	// Indirect jump via vector address
 8000d1a:	6803      	ldr	r3, [r0, #0]
 8000d1c:	4798      	blx	r3
 8000d1e:	e050      	b.n	8000dc2 <do_cmd_cmd+0xfa>
	case LDR_JMP:		// Jump: to address supplied
		do_jump(p);
		break;

	case LDR_WRBLK:		// Done with block: write block with whatever you have..
		do_wrblk(p);
 8000d20:	4618      	mov	r0, r3
		err_bogus_cmds_cmds += 1;
printf("BOGUS CMD CODE: %X %08X %X  %08X %08X\n\r",p->cd.uc[0], p->id, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
		break;
	}
	return;
}
 8000d22:	b003      	add	sp, #12
 8000d24:	f85d eb04 	ldr.w	lr, [sp], #4
	case LDR_JMP:		// Jump: to address supplied
		do_jump(p);
		break;

	case LDR_WRBLK:		// Done with block: write block with whatever you have..
		do_wrblk(p);
 8000d28:	e65e      	b.n	80009e8 <do_wrblk>
		break;

	case LDR_RESET:		// RESET: Execute a software forced RESET for this unit only.
		SCB_AIRCR  |= (0x5FA << 16) | SCB_AIRCR_SYSRESETREQ;	// Cause a RESET
 8000d2a:	4a27      	ldr	r2, [pc, #156]	; (8000dc8 <do_cmd_cmd+0x100>)
 8000d2c:	4b27      	ldr	r3, [pc, #156]	; (8000dcc <do_cmd_cmd+0x104>)
 8000d2e:	6811      	ldr	r1, [r2, #0]
 8000d30:	ea41 0303 	orr.w	r3, r1, r3
 8000d34:	6013      	str	r3, [r2, #0]
 8000d36:	e044      	b.n	8000dc2 <do_cmd_cmd+0xfa>
		break;

	case LDR_CRC:		// Get CRC: given count | start address, compute CRC and respond with it.
		do_crc(p);
 8000d38:	4618      	mov	r0, r3
		err_bogus_cmds_cmds += 1;
printf("BOGUS CMD CODE: %X %08X %X  %08X %08X\n\r",p->cd.uc[0], p->id, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
		break;
	}
	return;
}
 8000d3a:	b003      	add	sp, #12
 8000d3c:	f85d eb04 	ldr.w	lr, [sp], #4
	case LDR_RESET:		// RESET: Execute a software forced RESET for this unit only.
		SCB_AIRCR  |= (0x5FA << 16) | SCB_AIRCR_SYSRESETREQ;	// Cause a RESET
		break;

	case LDR_CRC:		// Get CRC: given count | start address, compute CRC and respond with it.
		do_crc(p);
 8000d40:	e664      	b.n	8000a0c <do_crc>

	case LDR_XOFF:		// Stop sending: response to our sending LDR_XOFF msg.
		break;

	case LDR_FLASHSIZE:	// Send flash size
		do_flashsize(p);
 8000d42:	4618      	mov	r0, r3
		err_bogus_cmds_cmds += 1;
printf("BOGUS CMD CODE: %X %08X %X  %08X %08X\n\r",p->cd.uc[0], p->id, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
		break;
	}
	return;
}
 8000d44:	b003      	add	sp, #12
 8000d46:	f85d eb04 	ldr.w	lr, [sp], #4

	case LDR_XOFF:		// Stop sending: response to our sending LDR_XOFF msg.
		break;

	case LDR_FLASHSIZE:	// Send flash size
		do_flashsize(p);
 8000d4a:	e6ff      	b.n	8000b4c <do_flashsize>
		break;

	case LDR_FIXEDADDR:	// Send address ahead of fixed address block
		do_getfromdaddress(p, (u8*)0x08000004);
 8000d4c:	4920      	ldr	r1, [pc, #128]	; (8000dd0 <do_cmd_cmd+0x108>)
 8000d4e:	4618      	mov	r0, r3
		err_bogus_cmds_cmds += 1;
printf("BOGUS CMD CODE: %X %08X %X  %08X %08X\n\r",p->cd.uc[0], p->id, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
		break;
	}
	return;
}
 8000d50:	b003      	add	sp, #12
 8000d52:	f85d eb04 	ldr.w	lr, [sp], #4
	case LDR_FLASHSIZE:	// Send flash size
		do_flashsize(p);
		break;

	case LDR_FIXEDADDR:	// Send address ahead of fixed address block
		do_getfromdaddress(p, (u8*)0x08000004);
 8000d56:	e739      	b.n	8000bcc <do_getfromdaddress>
		break;

	case LDR_RD4:		// Send address of fixed param flash area
		do_rd4(p);
 8000d58:	4618      	mov	r0, r3
		err_bogus_cmds_cmds += 1;
printf("BOGUS CMD CODE: %X %08X %X  %08X %08X\n\r",p->cd.uc[0], p->id, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
		break;
	}
	return;
}
 8000d5a:	b003      	add	sp, #12
 8000d5c:	f85d eb04 	ldr.w	lr, [sp], #4
	case LDR_FIXEDADDR:	// Send address ahead of fixed address block
		do_getfromdaddress(p, (u8*)0x08000004);
		break;

	case LDR_RD4:		// Send address of fixed param flash area
		do_rd4(p);
 8000d60:	e710      	b.n	8000b84 <do_rd4>
		break;

	case LDR_APPOFFSET:	// Send address of where app loads
		do_send4(p, (u32)&__appoffset);
 8000d62:	4618      	mov	r0, r3
 8000d64:	491b      	ldr	r1, [pc, #108]	; (8000dd4 <do_cmd_cmd+0x10c>)
 8000d66:	e001      	b.n	8000d6c <do_cmd_cmd+0xa4>
		break;

	case LDR_HIGHFLASHH:	// Send address of high flash area
		do_send4(p, (u32)&__highflashlayout);
 8000d68:	491b      	ldr	r1, [pc, #108]	; (8000dd8 <do_cmd_cmd+0x110>)
 8000d6a:	4618      	mov	r0, r3
		err_bogus_cmds_cmds += 1;
printf("BOGUS CMD CODE: %X %08X %X  %08X %08X\n\r",p->cd.uc[0], p->id, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
		break;
	}
	return;
}
 8000d6c:	b003      	add	sp, #12
 8000d6e:	f85d eb04 	ldr.w	lr, [sp], #4
	case LDR_APPOFFSET:	// Send address of where app loads
		do_send4(p, (u32)&__appoffset);
		break;

	case LDR_HIGHFLASHH:	// Send address of high flash area
		do_send4(p, (u32)&__highflashlayout);
 8000d72:	e759      	b.n	8000c28 <do_send4>
		break;

	case LDR_HIGHFLASHP:	// Get address of beginning of crc check info for app
		do_getflashpaddr(p);
 8000d74:	4618      	mov	r0, r3
		err_bogus_cmds_cmds += 1;
printf("BOGUS CMD CODE: %X %08X %X  %08X %08X\n\r",p->cd.uc[0], p->id, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
		break;
	}
	return;
}
 8000d76:	b003      	add	sp, #12
 8000d78:	f85d eb04 	ldr.w	lr, [sp], #4
	case LDR_HIGHFLASHH:	// Send address of high flash area
		do_send4(p, (u32)&__highflashlayout);
		break;

	case LDR_HIGHFLASHP:	// Get address of beginning of crc check info for app
		do_getflashpaddr(p);
 8000d7c:	e772      	b.n	8000c64 <do_getflashpaddr>
		break;

	case LDR_WRVAL_PTR:	// Write: 2-8=bytes to be written via address ptr previous set
		// Write data starting at payload[1], dlc holds byte ct: 1-7
		do_datawrite(&p->cd.uc[1], (0x7f & p->dlc) - 1, p);
 8000d7e:	6859      	ldr	r1, [r3, #4]
 8000d80:	f103 0009 	add.w	r0, r3, #9
 8000d84:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8000d88:	3901      	subs	r1, #1
 8000d8a:	461a      	mov	r2, r3
 8000d8c:	f7ff fd40 	bl	8000810 <do_datawrite>
		sendcanCMD(LDR_ACK);
 8000d90:	2004      	movs	r0, #4
		err_bogus_cmds_cmds += 1;
printf("BOGUS CMD CODE: %X %08X %X  %08X %08X\n\r",p->cd.uc[0], p->id, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
		break;
	}
	return;
}
 8000d92:	b003      	add	sp, #12
 8000d94:	f85d eb04 	ldr.w	lr, [sp], #4
		break;

	case LDR_WRVAL_PTR:	// Write: 2-8=bytes to be written via address ptr previous set
		// Write data starting at payload[1], dlc holds byte ct: 1-7
		do_datawrite(&p->cd.uc[1], (0x7f & p->dlc) - 1, p);
		sendcanCMD(LDR_ACK);
 8000d98:	e42e      	b.n	80005f8 <sendcanCMD>
		break;

	default:		// Not a defined command
		err_bogus_cmds_cmds += 1;
 8000d9a:	4a10      	ldr	r2, [pc, #64]	; (8000ddc <do_cmd_cmd+0x114>)
 8000d9c:	f8d2 0860 	ldr.w	r0, [r2, #2144]	; 0x860
 8000da0:	3001      	adds	r0, #1
 8000da2:	f8c2 0860 	str.w	r0, [r2, #2144]	; 0x860
printf("BOGUS CMD CODE: %X %08X %X  %08X %08X\n\r",p->cd.uc[0], p->id, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
 8000da6:	689a      	ldr	r2, [r3, #8]
 8000da8:	480d      	ldr	r0, [pc, #52]	; (8000de0 <do_cmd_cmd+0x118>)
 8000daa:	9200      	str	r2, [sp, #0]
 8000dac:	68da      	ldr	r2, [r3, #12]
 8000dae:	9201      	str	r2, [sp, #4]
 8000db0:	681a      	ldr	r2, [r3, #0]
 8000db2:	685b      	ldr	r3, [r3, #4]
 8000db4:	f000 fed6 	bl	8001b64 <tfp_printf>
		break;
	}
	return;
}
 8000db8:	b003      	add	sp, #12
 8000dba:	f85d eb04 	ldr.w	lr, [sp], #4
		sendcanCMD(LDR_ACK);
		break;

	default:		// Not a defined command
		err_bogus_cmds_cmds += 1;
printf("BOGUS CMD CODE: %X %08X %X  %08X %08X\n\r",p->cd.uc[0], p->id, p->dlc, p->cd.ui[0], p->cd.ui[1]);USART1_txint_send();
 8000dbe:	f000 bfc7 	b.w	8001d50 <USART1_txint_send>
		break;
	}
	return;
}
 8000dc2:	b003      	add	sp, #12
 8000dc4:	bd00      	pop	{pc}
 8000dc6:	bf00      	nop
 8000dc8:	e000ed0c 	.word	0xe000ed0c
 8000dcc:	05fa0004 	.word	0x05fa0004
 8000dd0:	08000004 	.word	0x08000004
 8000dd4:	08005000 	.word	0x08005000
 8000dd8:	0807f800 	.word	0x0807f800
 8000ddc:	20000528 	.word	0x20000528
 8000de0:	08003a11 	.word	0x08003a11

08000de4 <canwinch_ldrproto_poll>:
 * void canwinch_ldrproto_poll(void);
 * @param	: pctl = pointer control block for CAN module being used
 * @brief	: If msg is for this unit, then do something with it.
 * ************************************************************************************** */
void canwinch_ldrproto_poll(void)
{
 8000de4:	b538      	push	{r3, r4, r5, lr}
	struct CANRCVBUF* pcan;

	/* Check incoming msgs. */
	while ((pcan = can_driver_peek0(pctl1)) != NULL) // RX0 have a msg?
 8000de6:	e002      	b.n	8000dee <canwinch_ldrproto_poll+0xa>
		if ( (pcan->id & 0x0ffffffe) == fixedaddress.canid_ldr)
		{ // Here CAN ID is for this unit/loader
//printf ("X: %08X %d %08X %08X\n\r",pcan->id,pcan->dlc,pcan->cd.ui[0],pcan->cd.ui[1]);
//$			do_cmd_cmd(pcan);		// Execute command 
		}
		can_driver_toss0(pctl1);	// Release buffer block
 8000de8:	6820      	ldr	r0, [r4, #0]
 8000dea:	f001 ff11 	bl	8002c10 <can_driver_toss0>
void canwinch_ldrproto_poll(void)
{
	struct CANRCVBUF* pcan;

	/* Check incoming msgs. */
	while ((pcan = can_driver_peek0(pctl1)) != NULL) // RX0 have a msg?
 8000dee:	4c09      	ldr	r4, [pc, #36]	; (8000e14 <canwinch_ldrproto_poll+0x30>)
 8000df0:	6820      	ldr	r0, [r4, #0]
 8000df2:	f001 ff11 	bl	8002c18 <can_driver_peek0>
 8000df6:	4625      	mov	r5, r4
 8000df8:	2800      	cmp	r0, #0
 8000dfa:	d1f5      	bne.n	8000de8 <canwinch_ldrproto_poll+0x4>
 8000dfc:	e003      	b.n	8000e06 <canwinch_ldrproto_poll+0x22>
		}
		can_driver_toss0(pctl1);	// Release buffer block
	}
	/* Dump FIFO1 msgs. */
	while ((can_driver_peek1(pctl1)) != NULL)	// RX1 have a msg?
		can_driver_toss1(pctl1); 	// Release buffer block
 8000dfe:	4b05      	ldr	r3, [pc, #20]	; (8000e14 <canwinch_ldrproto_poll+0x30>)
 8000e00:	6818      	ldr	r0, [r3, #0]
 8000e02:	f001 ff07 	bl	8002c14 <can_driver_toss1>
//$			do_cmd_cmd(pcan);		// Execute command 
		}
		can_driver_toss0(pctl1);	// Release buffer block
	}
	/* Dump FIFO1 msgs. */
	while ((can_driver_peek1(pctl1)) != NULL)	// RX1 have a msg?
 8000e06:	6828      	ldr	r0, [r5, #0]
 8000e08:	f001 ff0d 	bl	8002c26 <can_driver_peek1>
 8000e0c:	2800      	cmp	r0, #0
 8000e0e:	d1f6      	bne.n	8000dfe <canwinch_ldrproto_poll+0x1a>
		can_driver_toss1(pctl1); 	// Release buffer block
	return;
}
 8000e10:	bd38      	pop	{r3, r4, r5, pc}
 8000e12:	bf00      	nop
 8000e14:	20000518 	.word	0x20000518

08000e18 <cleanup_glue>:
 8000e18:	b570      	push	{r4, r5, r6, lr}
 8000e1a:	460c      	mov	r4, r1
 8000e1c:	6809      	ldr	r1, [r1, #0]
 8000e1e:	4605      	mov	r5, r0
 8000e20:	b109      	cbz	r1, 8000e26 <cleanup_glue+0xe>
 8000e22:	f7ff fff9 	bl	8000e18 <cleanup_glue>
 8000e26:	4628      	mov	r0, r5
 8000e28:	4621      	mov	r1, r4
 8000e2a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8000e2e:	f000 b8d3 	b.w	8000fd8 <_free_r>
 8000e32:	bf00      	nop

08000e34 <_reclaim_reent>:
 8000e34:	f240 0308 	movw	r3, #8
 8000e38:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000e3c:	b570      	push	{r4, r5, r6, lr}
 8000e3e:	4605      	mov	r5, r0
 8000e40:	681b      	ldr	r3, [r3, #0]
 8000e42:	4298      	cmp	r0, r3
 8000e44:	d04a      	beq.n	8000edc <_reclaim_reent+0xa8>
 8000e46:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8000e48:	b302      	cbz	r2, 8000e8c <_reclaim_reent+0x58>
 8000e4a:	68d3      	ldr	r3, [r2, #12]
 8000e4c:	b1cb      	cbz	r3, 8000e82 <_reclaim_reent+0x4e>
 8000e4e:	2100      	movs	r1, #0
 8000e50:	460e      	mov	r6, r1
 8000e52:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 8000e56:	b909      	cbnz	r1, 8000e5c <_reclaim_reent+0x28>
 8000e58:	e008      	b.n	8000e6c <_reclaim_reent+0x38>
 8000e5a:	4621      	mov	r1, r4
 8000e5c:	680c      	ldr	r4, [r1, #0]
 8000e5e:	4628      	mov	r0, r5
 8000e60:	f000 f8ba 	bl	8000fd8 <_free_r>
 8000e64:	2c00      	cmp	r4, #0
 8000e66:	d1f8      	bne.n	8000e5a <_reclaim_reent+0x26>
 8000e68:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8000e6a:	68d3      	ldr	r3, [r2, #12]
 8000e6c:	3601      	adds	r6, #1
 8000e6e:	2e20      	cmp	r6, #32
 8000e70:	4631      	mov	r1, r6
 8000e72:	d001      	beq.n	8000e78 <_reclaim_reent+0x44>
 8000e74:	68d3      	ldr	r3, [r2, #12]
 8000e76:	e7ec      	b.n	8000e52 <_reclaim_reent+0x1e>
 8000e78:	4628      	mov	r0, r5
 8000e7a:	4619      	mov	r1, r3
 8000e7c:	f000 f8ac 	bl	8000fd8 <_free_r>
 8000e80:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8000e82:	6811      	ldr	r1, [r2, #0]
 8000e84:	b111      	cbz	r1, 8000e8c <_reclaim_reent+0x58>
 8000e86:	4628      	mov	r0, r5
 8000e88:	f000 f8a6 	bl	8000fd8 <_free_r>
 8000e8c:	6969      	ldr	r1, [r5, #20]
 8000e8e:	b111      	cbz	r1, 8000e96 <_reclaim_reent+0x62>
 8000e90:	4628      	mov	r0, r5
 8000e92:	f000 f8a1 	bl	8000fd8 <_free_r>
 8000e96:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8000e98:	b111      	cbz	r1, 8000ea0 <_reclaim_reent+0x6c>
 8000e9a:	4628      	mov	r0, r5
 8000e9c:	f000 f89c 	bl	8000fd8 <_free_r>
 8000ea0:	6ba9      	ldr	r1, [r5, #56]	; 0x38
 8000ea2:	b111      	cbz	r1, 8000eaa <_reclaim_reent+0x76>
 8000ea4:	4628      	mov	r0, r5
 8000ea6:	f000 f897 	bl	8000fd8 <_free_r>
 8000eaa:	6be9      	ldr	r1, [r5, #60]	; 0x3c
 8000eac:	b111      	cbz	r1, 8000eb4 <_reclaim_reent+0x80>
 8000eae:	4628      	mov	r0, r5
 8000eb0:	f000 f892 	bl	8000fd8 <_free_r>
 8000eb4:	6c29      	ldr	r1, [r5, #64]	; 0x40
 8000eb6:	b111      	cbz	r1, 8000ebe <_reclaim_reent+0x8a>
 8000eb8:	4628      	mov	r0, r5
 8000eba:	f000 f88d 	bl	8000fd8 <_free_r>
 8000ebe:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8000ec0:	b12b      	cbz	r3, 8000ece <_reclaim_reent+0x9a>
 8000ec2:	f8d3 1088 	ldr.w	r1, [r3, #136]	; 0x88
 8000ec6:	b111      	cbz	r1, 8000ece <_reclaim_reent+0x9a>
 8000ec8:	4628      	mov	r0, r5
 8000eca:	f000 f885 	bl	8000fd8 <_free_r>
 8000ece:	6b69      	ldr	r1, [r5, #52]	; 0x34
 8000ed0:	b111      	cbz	r1, 8000ed8 <_reclaim_reent+0xa4>
 8000ed2:	4628      	mov	r0, r5
 8000ed4:	f000 f880 	bl	8000fd8 <_free_r>
 8000ed8:	69ab      	ldr	r3, [r5, #24]
 8000eda:	b903      	cbnz	r3, 8000ede <_reclaim_reent+0xaa>
 8000edc:	bd70      	pop	{r4, r5, r6, pc}
 8000ede:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8000ee0:	4628      	mov	r0, r5
 8000ee2:	4798      	blx	r3
 8000ee4:	f8d5 10d8 	ldr.w	r1, [r5, #216]	; 0xd8
 8000ee8:	2900      	cmp	r1, #0
 8000eea:	d0f7      	beq.n	8000edc <_reclaim_reent+0xa8>
 8000eec:	4628      	mov	r0, r5
 8000eee:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8000ef2:	e791      	b.n	8000e18 <cleanup_glue>

08000ef4 <_wrapup_reent>:
 8000ef4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000ef6:	4607      	mov	r7, r0
 8000ef8:	b198      	cbz	r0, 8000f22 <_wrapup_reent+0x2e>
 8000efa:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8000efc:	b163      	cbz	r3, 8000f18 <_wrapup_reent+0x24>
 8000efe:	685e      	ldr	r6, [r3, #4]
 8000f00:	2e00      	cmp	r6, #0
 8000f02:	dd09      	ble.n	8000f18 <_wrapup_reent+0x24>
 8000f04:	1cb5      	adds	r5, r6, #2
 8000f06:	2400      	movs	r4, #0
 8000f08:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 8000f0c:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 8000f10:	3401      	adds	r4, #1
 8000f12:	4798      	blx	r3
 8000f14:	42b4      	cmp	r4, r6
 8000f16:	d1f9      	bne.n	8000f0c <_wrapup_reent+0x18>
 8000f18:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8000f1a:	b10b      	cbz	r3, 8000f20 <_wrapup_reent+0x2c>
 8000f1c:	4638      	mov	r0, r7
 8000f1e:	4798      	blx	r3
 8000f20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000f22:	f240 0308 	movw	r3, #8
 8000f26:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000f2a:	681f      	ldr	r7, [r3, #0]
 8000f2c:	e7e5      	b.n	8000efa <_wrapup_reent+0x6>
 8000f2e:	bf00      	nop

08000f30 <_malloc_trim_r>:
 8000f30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000f32:	f240 04fc 	movw	r4, #252	; 0xfc
 8000f36:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8000f3a:	460f      	mov	r7, r1
 8000f3c:	4605      	mov	r5, r0
 8000f3e:	f000 fbd5 	bl	80016ec <__malloc_lock>
 8000f42:	68a3      	ldr	r3, [r4, #8]
 8000f44:	685e      	ldr	r6, [r3, #4]
 8000f46:	f026 0603 	bic.w	r6, r6, #3
 8000f4a:	f506 637e 	add.w	r3, r6, #4064	; 0xfe0
 8000f4e:	330f      	adds	r3, #15
 8000f50:	1bdf      	subs	r7, r3, r7
 8000f52:	0b3f      	lsrs	r7, r7, #12
 8000f54:	3f01      	subs	r7, #1
 8000f56:	033f      	lsls	r7, r7, #12
 8000f58:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
 8000f5c:	db07      	blt.n	8000f6e <_malloc_trim_r+0x3e>
 8000f5e:	2100      	movs	r1, #0
 8000f60:	4628      	mov	r0, r5
 8000f62:	f000 fbc7 	bl	80016f4 <_sbrk_r>
 8000f66:	68a3      	ldr	r3, [r4, #8]
 8000f68:	199b      	adds	r3, r3, r6
 8000f6a:	4298      	cmp	r0, r3
 8000f6c:	d004      	beq.n	8000f78 <_malloc_trim_r+0x48>
 8000f6e:	4628      	mov	r0, r5
 8000f70:	f000 fbbe 	bl	80016f0 <__malloc_unlock>
 8000f74:	2000      	movs	r0, #0
 8000f76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000f78:	4279      	negs	r1, r7
 8000f7a:	4628      	mov	r0, r5
 8000f7c:	f000 fbba 	bl	80016f4 <_sbrk_r>
 8000f80:	f1b0 3fff 	cmp.w	r0, #4294967295
 8000f84:	d010      	beq.n	8000fa8 <_malloc_trim_r+0x78>
 8000f86:	f640 539c 	movw	r3, #3484	; 0xd9c
 8000f8a:	68a1      	ldr	r1, [r4, #8]
 8000f8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000f90:	1bf6      	subs	r6, r6, r7
 8000f92:	4628      	mov	r0, r5
 8000f94:	f046 0601 	orr.w	r6, r6, #1
 8000f98:	681a      	ldr	r2, [r3, #0]
 8000f9a:	604e      	str	r6, [r1, #4]
 8000f9c:	1bd7      	subs	r7, r2, r7
 8000f9e:	601f      	str	r7, [r3, #0]
 8000fa0:	f000 fba6 	bl	80016f0 <__malloc_unlock>
 8000fa4:	2001      	movs	r0, #1
 8000fa6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000fa8:	2100      	movs	r1, #0
 8000faa:	4628      	mov	r0, r5
 8000fac:	f000 fba2 	bl	80016f4 <_sbrk_r>
 8000fb0:	68a3      	ldr	r3, [r4, #8]
 8000fb2:	1ac2      	subs	r2, r0, r3
 8000fb4:	2a0f      	cmp	r2, #15
 8000fb6:	ddda      	ble.n	8000f6e <_malloc_trim_r+0x3e>
 8000fb8:	f240 5404 	movw	r4, #1284	; 0x504
 8000fbc:	f640 519c 	movw	r1, #3484	; 0xd9c
 8000fc0:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8000fc4:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8000fc8:	f042 0201 	orr.w	r2, r2, #1
 8000fcc:	605a      	str	r2, [r3, #4]
 8000fce:	6823      	ldr	r3, [r4, #0]
 8000fd0:	1ac0      	subs	r0, r0, r3
 8000fd2:	6008      	str	r0, [r1, #0]
 8000fd4:	e7cb      	b.n	8000f6e <_malloc_trim_r+0x3e>
 8000fd6:	bf00      	nop

08000fd8 <_free_r>:
 8000fd8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000fdc:	460d      	mov	r5, r1
 8000fde:	4604      	mov	r4, r0
 8000fe0:	2900      	cmp	r1, #0
 8000fe2:	d058      	beq.n	8001096 <_free_r+0xbe>
 8000fe4:	f000 fb82 	bl	80016ec <__malloc_lock>
 8000fe8:	f1a5 0208 	sub.w	r2, r5, #8
 8000fec:	f240 00fc 	movw	r0, #252	; 0xfc
 8000ff0:	6856      	ldr	r6, [r2, #4]
 8000ff2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000ff6:	f026 0301 	bic.w	r3, r6, #1
 8000ffa:	f8d0 c008 	ldr.w	ip, [r0, #8]
 8000ffe:	18d1      	adds	r1, r2, r3
 8001000:	458c      	cmp	ip, r1
 8001002:	684f      	ldr	r7, [r1, #4]
 8001004:	f027 0703 	bic.w	r7, r7, #3
 8001008:	d065      	beq.n	80010d6 <_free_r+0xfe>
 800100a:	f016 0601 	ands.w	r6, r6, #1
 800100e:	604f      	str	r7, [r1, #4]
 8001010:	d031      	beq.n	8001076 <_free_r+0x9e>
 8001012:	2600      	movs	r6, #0
 8001014:	19cd      	adds	r5, r1, r7
 8001016:	686d      	ldr	r5, [r5, #4]
 8001018:	f015 0f01 	tst.w	r5, #1
 800101c:	d106      	bne.n	800102c <_free_r+0x54>
 800101e:	19db      	adds	r3, r3, r7
 8001020:	2e00      	cmp	r6, #0
 8001022:	d04b      	beq.n	80010bc <_free_r+0xe4>
 8001024:	688d      	ldr	r5, [r1, #8]
 8001026:	68c9      	ldr	r1, [r1, #12]
 8001028:	60e9      	str	r1, [r5, #12]
 800102a:	608d      	str	r5, [r1, #8]
 800102c:	f043 0101 	orr.w	r1, r3, #1
 8001030:	50d3      	str	r3, [r2, r3]
 8001032:	6051      	str	r1, [r2, #4]
 8001034:	b9d6      	cbnz	r6, 800106c <_free_r+0x94>
 8001036:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800103a:	d32e      	bcc.n	800109a <_free_r+0xc2>
 800103c:	0a59      	lsrs	r1, r3, #9
 800103e:	2904      	cmp	r1, #4
 8001040:	d86b      	bhi.n	800111a <_free_r+0x142>
 8001042:	099e      	lsrs	r6, r3, #6
 8001044:	3638      	adds	r6, #56	; 0x38
 8001046:	00f5      	lsls	r5, r6, #3
 8001048:	1945      	adds	r5, r0, r5
 800104a:	68a9      	ldr	r1, [r5, #8]
 800104c:	42a9      	cmp	r1, r5
 800104e:	d103      	bne.n	8001058 <_free_r+0x80>
 8001050:	e069      	b.n	8001126 <_free_r+0x14e>
 8001052:	6889      	ldr	r1, [r1, #8]
 8001054:	428d      	cmp	r5, r1
 8001056:	d004      	beq.n	8001062 <_free_r+0x8a>
 8001058:	6848      	ldr	r0, [r1, #4]
 800105a:	f020 0003 	bic.w	r0, r0, #3
 800105e:	4283      	cmp	r3, r0
 8001060:	d3f7      	bcc.n	8001052 <_free_r+0x7a>
 8001062:	68cb      	ldr	r3, [r1, #12]
 8001064:	60d3      	str	r3, [r2, #12]
 8001066:	6091      	str	r1, [r2, #8]
 8001068:	60ca      	str	r2, [r1, #12]
 800106a:	609a      	str	r2, [r3, #8]
 800106c:	4620      	mov	r0, r4
 800106e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8001072:	f000 bb3d 	b.w	80016f0 <__malloc_unlock>
 8001076:	f855 5c08 	ldr.w	r5, [r5, #-8]
 800107a:	f100 0c08 	add.w	ip, r0, #8
 800107e:	1b52      	subs	r2, r2, r5
 8001080:	195b      	adds	r3, r3, r5
 8001082:	6895      	ldr	r5, [r2, #8]
 8001084:	4565      	cmp	r5, ip
 8001086:	d046      	beq.n	8001116 <_free_r+0x13e>
 8001088:	f8d2 c00c 	ldr.w	ip, [r2, #12]
 800108c:	f8c5 c00c 	str.w	ip, [r5, #12]
 8001090:	f8cc 5008 	str.w	r5, [ip, #8]
 8001094:	e7be      	b.n	8001014 <_free_r+0x3c>
 8001096:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800109a:	08db      	lsrs	r3, r3, #3
 800109c:	2501      	movs	r5, #1
 800109e:	6846      	ldr	r6, [r0, #4]
 80010a0:	eb00 01c3 	add.w	r1, r0, r3, lsl #3
 80010a4:	109b      	asrs	r3, r3, #2
 80010a6:	fa15 f303 	lsls.w	r3, r5, r3
 80010aa:	60d1      	str	r1, [r2, #12]
 80010ac:	688d      	ldr	r5, [r1, #8]
 80010ae:	ea46 0303 	orr.w	r3, r6, r3
 80010b2:	6043      	str	r3, [r0, #4]
 80010b4:	6095      	str	r5, [r2, #8]
 80010b6:	60ea      	str	r2, [r5, #12]
 80010b8:	608a      	str	r2, [r1, #8]
 80010ba:	e7d7      	b.n	800106c <_free_r+0x94>
 80010bc:	688d      	ldr	r5, [r1, #8]
 80010be:	4f2b      	ldr	r7, [pc, #172]	; (800116c <_free_r+0x194>)
 80010c0:	42bd      	cmp	r5, r7
 80010c2:	d1b0      	bne.n	8001026 <_free_r+0x4e>
 80010c4:	60ea      	str	r2, [r5, #12]
 80010c6:	f043 0101 	orr.w	r1, r3, #1
 80010ca:	60aa      	str	r2, [r5, #8]
 80010cc:	60d5      	str	r5, [r2, #12]
 80010ce:	6095      	str	r5, [r2, #8]
 80010d0:	6051      	str	r1, [r2, #4]
 80010d2:	50d3      	str	r3, [r2, r3]
 80010d4:	e7ca      	b.n	800106c <_free_r+0x94>
 80010d6:	f016 0f01 	tst.w	r6, #1
 80010da:	443b      	add	r3, r7
 80010dc:	d107      	bne.n	80010ee <_free_r+0x116>
 80010de:	f855 1c08 	ldr.w	r1, [r5, #-8]
 80010e2:	1a52      	subs	r2, r2, r1
 80010e4:	185b      	adds	r3, r3, r1
 80010e6:	6895      	ldr	r5, [r2, #8]
 80010e8:	68d1      	ldr	r1, [r2, #12]
 80010ea:	60e9      	str	r1, [r5, #12]
 80010ec:	608d      	str	r5, [r1, #8]
 80010ee:	f240 5108 	movw	r1, #1288	; 0x508
 80010f2:	f043 0501 	orr.w	r5, r3, #1
 80010f6:	f2c2 0100 	movt	r1, #8192	; 0x2000
 80010fa:	6055      	str	r5, [r2, #4]
 80010fc:	6082      	str	r2, [r0, #8]
 80010fe:	680a      	ldr	r2, [r1, #0]
 8001100:	4293      	cmp	r3, r2
 8001102:	d3b3      	bcc.n	800106c <_free_r+0x94>
 8001104:	f640 5398 	movw	r3, #3480	; 0xd98
 8001108:	4620      	mov	r0, r4
 800110a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800110e:	6819      	ldr	r1, [r3, #0]
 8001110:	f7ff ff0e 	bl	8000f30 <_malloc_trim_r>
 8001114:	e7aa      	b.n	800106c <_free_r+0x94>
 8001116:	2601      	movs	r6, #1
 8001118:	e77c      	b.n	8001014 <_free_r+0x3c>
 800111a:	2914      	cmp	r1, #20
 800111c:	d80c      	bhi.n	8001138 <_free_r+0x160>
 800111e:	f101 065b 	add.w	r6, r1, #91	; 0x5b
 8001122:	00f5      	lsls	r5, r6, #3
 8001124:	e790      	b.n	8001048 <_free_r+0x70>
 8001126:	2501      	movs	r5, #1
 8001128:	6847      	ldr	r7, [r0, #4]
 800112a:	10b6      	asrs	r6, r6, #2
 800112c:	460b      	mov	r3, r1
 800112e:	40b5      	lsls	r5, r6
 8001130:	ea47 0505 	orr.w	r5, r7, r5
 8001134:	6045      	str	r5, [r0, #4]
 8001136:	e795      	b.n	8001064 <_free_r+0x8c>
 8001138:	2954      	cmp	r1, #84	; 0x54
 800113a:	d803      	bhi.n	8001144 <_free_r+0x16c>
 800113c:	0b1e      	lsrs	r6, r3, #12
 800113e:	366e      	adds	r6, #110	; 0x6e
 8001140:	00f5      	lsls	r5, r6, #3
 8001142:	e781      	b.n	8001048 <_free_r+0x70>
 8001144:	f5b1 7faa 	cmp.w	r1, #340	; 0x154
 8001148:	d803      	bhi.n	8001152 <_free_r+0x17a>
 800114a:	0bde      	lsrs	r6, r3, #15
 800114c:	3677      	adds	r6, #119	; 0x77
 800114e:	00f5      	lsls	r5, r6, #3
 8001150:	e77a      	b.n	8001048 <_free_r+0x70>
 8001152:	f240 5554 	movw	r5, #1364	; 0x554
 8001156:	42a9      	cmp	r1, r5
 8001158:	d803      	bhi.n	8001162 <_free_r+0x18a>
 800115a:	0c9e      	lsrs	r6, r3, #18
 800115c:	367c      	adds	r6, #124	; 0x7c
 800115e:	00f5      	lsls	r5, r6, #3
 8001160:	e772      	b.n	8001048 <_free_r+0x70>
 8001162:	f44f 757c 	mov.w	r5, #1008	; 0x3f0
 8001166:	267e      	movs	r6, #126	; 0x7e
 8001168:	e76e      	b.n	8001048 <_free_r+0x70>
 800116a:	bf00      	nop
 800116c:	20000104 	.word	0x20000104

08001170 <_malloc_r>:
 8001170:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001174:	f101 040b 	add.w	r4, r1, #11
 8001178:	2c16      	cmp	r4, #22
 800117a:	b083      	sub	sp, #12
 800117c:	4606      	mov	r6, r0
 800117e:	d931      	bls.n	80011e4 <_malloc_r+0x74>
 8001180:	f024 0407 	bic.w	r4, r4, #7
 8001184:	0fe3      	lsrs	r3, r4, #31
 8001186:	428c      	cmp	r4, r1
 8001188:	bf2c      	ite	cs
 800118a:	4619      	movcs	r1, r3
 800118c:	f043 0101 	orrcc.w	r1, r3, #1
 8001190:	2900      	cmp	r1, #0
 8001192:	d130      	bne.n	80011f6 <_malloc_r+0x86>
 8001194:	4630      	mov	r0, r6
 8001196:	f000 faa9 	bl	80016ec <__malloc_lock>
 800119a:	f5b4 7ffc 	cmp.w	r4, #504	; 0x1f8
 800119e:	d22f      	bcs.n	8001200 <_malloc_r+0x90>
 80011a0:	ea4f 0cd4 	mov.w	ip, r4, lsr #3
 80011a4:	f240 05fc 	movw	r5, #252	; 0xfc
 80011a8:	f2c2 0500 	movt	r5, #8192	; 0x2000
 80011ac:	eb05 02cc 	add.w	r2, r5, ip, lsl #3
 80011b0:	462f      	mov	r7, r5
 80011b2:	68d3      	ldr	r3, [r2, #12]
 80011b4:	4293      	cmp	r3, r2
 80011b6:	f000 822d 	beq.w	8001614 <_malloc_r+0x4a4>
 80011ba:	685c      	ldr	r4, [r3, #4]
 80011bc:	f103 0808 	add.w	r8, r3, #8
 80011c0:	68da      	ldr	r2, [r3, #12]
 80011c2:	4630      	mov	r0, r6
 80011c4:	f024 0403 	bic.w	r4, r4, #3
 80011c8:	6899      	ldr	r1, [r3, #8]
 80011ca:	191b      	adds	r3, r3, r4
 80011cc:	685c      	ldr	r4, [r3, #4]
 80011ce:	60ca      	str	r2, [r1, #12]
 80011d0:	f044 0401 	orr.w	r4, r4, #1
 80011d4:	6091      	str	r1, [r2, #8]
 80011d6:	605c      	str	r4, [r3, #4]
 80011d8:	f000 fa8a 	bl	80016f0 <__malloc_unlock>
 80011dc:	4640      	mov	r0, r8
 80011de:	b003      	add	sp, #12
 80011e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80011e4:	2300      	movs	r3, #0
 80011e6:	2410      	movs	r4, #16
 80011e8:	428c      	cmp	r4, r1
 80011ea:	bf2c      	ite	cs
 80011ec:	4619      	movcs	r1, r3
 80011ee:	f043 0101 	orrcc.w	r1, r3, #1
 80011f2:	2900      	cmp	r1, #0
 80011f4:	d0ce      	beq.n	8001194 <_malloc_r+0x24>
 80011f6:	230c      	movs	r3, #12
 80011f8:	f04f 0800 	mov.w	r8, #0
 80011fc:	6033      	str	r3, [r6, #0]
 80011fe:	e7ed      	b.n	80011dc <_malloc_r+0x6c>
 8001200:	ea5f 2c54 	movs.w	ip, r4, lsr #9
 8001204:	bf04      	itt	eq
 8001206:	ea4f 0cd4 	moveq.w	ip, r4, lsr #3
 800120a:	ea4f 00cc 	moveq.w	r0, ip, lsl #3
 800120e:	f040 8086 	bne.w	800131e <_malloc_r+0x1ae>
 8001212:	f240 05fc 	movw	r5, #252	; 0xfc
 8001216:	f2c2 0500 	movt	r5, #8192	; 0x2000
 800121a:	1828      	adds	r0, r5, r0
 800121c:	462f      	mov	r7, r5
 800121e:	68c3      	ldr	r3, [r0, #12]
 8001220:	4298      	cmp	r0, r3
 8001222:	d106      	bne.n	8001232 <_malloc_r+0xc2>
 8001224:	e00d      	b.n	8001242 <_malloc_r+0xd2>
 8001226:	2900      	cmp	r1, #0
 8001228:	f280 8179 	bge.w	800151e <_malloc_r+0x3ae>
 800122c:	68db      	ldr	r3, [r3, #12]
 800122e:	4298      	cmp	r0, r3
 8001230:	d007      	beq.n	8001242 <_malloc_r+0xd2>
 8001232:	685a      	ldr	r2, [r3, #4]
 8001234:	f022 0203 	bic.w	r2, r2, #3
 8001238:	1b11      	subs	r1, r2, r4
 800123a:	290f      	cmp	r1, #15
 800123c:	ddf3      	ble.n	8001226 <_malloc_r+0xb6>
 800123e:	f10c 3cff 	add.w	ip, ip, #4294967295
 8001242:	f10c 0c01 	add.w	ip, ip, #1
 8001246:	4abd      	ldr	r2, [pc, #756]	; (800153c <_malloc_r+0x3cc>)
 8001248:	6893      	ldr	r3, [r2, #8]
 800124a:	429a      	cmp	r2, r3
 800124c:	bf08      	it	eq
 800124e:	6878      	ldreq	r0, [r7, #4]
 8001250:	d024      	beq.n	800129c <_malloc_r+0x12c>
 8001252:	6858      	ldr	r0, [r3, #4]
 8001254:	f020 0003 	bic.w	r0, r0, #3
 8001258:	1b01      	subs	r1, r0, r4
 800125a:	290f      	cmp	r1, #15
 800125c:	f300 81c0 	bgt.w	80015e0 <_malloc_r+0x470>
 8001260:	2900      	cmp	r1, #0
 8001262:	60d2      	str	r2, [r2, #12]
 8001264:	6092      	str	r2, [r2, #8]
 8001266:	f280 8094 	bge.w	8001392 <_malloc_r+0x222>
 800126a:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 800126e:	f080 8177 	bcs.w	8001560 <_malloc_r+0x3f0>
 8001272:	08c0      	lsrs	r0, r0, #3
 8001274:	f04f 0e01 	mov.w	lr, #1
 8001278:	f8d7 8004 	ldr.w	r8, [r7, #4]
 800127c:	eb07 01c0 	add.w	r1, r7, r0, lsl #3
 8001280:	1080      	asrs	r0, r0, #2
 8001282:	fa0e f000 	lsl.w	r0, lr, r0
 8001286:	60d9      	str	r1, [r3, #12]
 8001288:	f8d1 e008 	ldr.w	lr, [r1, #8]
 800128c:	ea40 0008 	orr.w	r0, r0, r8
 8001290:	6078      	str	r0, [r7, #4]
 8001292:	f8c3 e008 	str.w	lr, [r3, #8]
 8001296:	f8ce 300c 	str.w	r3, [lr, #12]
 800129a:	608b      	str	r3, [r1, #8]
 800129c:	f04f 0e01 	mov.w	lr, #1
 80012a0:	ea4f 03ac 	mov.w	r3, ip, asr #2
 80012a4:	fa0e fe03 	lsl.w	lr, lr, r3
 80012a8:	4586      	cmp	lr, r0
 80012aa:	d87d      	bhi.n	80013a8 <_malloc_r+0x238>
 80012ac:	ea10 0f0e 	tst.w	r0, lr
 80012b0:	d108      	bne.n	80012c4 <_malloc_r+0x154>
 80012b2:	f02c 0c03 	bic.w	ip, ip, #3
 80012b6:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 80012ba:	f10c 0c04 	add.w	ip, ip, #4
 80012be:	ea10 0f0e 	tst.w	r0, lr
 80012c2:	d0f8      	beq.n	80012b6 <_malloc_r+0x146>
 80012c4:	eb07 0acc 	add.w	sl, r7, ip, lsl #3
 80012c8:	46e1      	mov	r9, ip
 80012ca:	46d0      	mov	r8, sl
 80012cc:	f8d8 000c 	ldr.w	r0, [r8, #12]
 80012d0:	4580      	cmp	r8, r0
 80012d2:	d107      	bne.n	80012e4 <_malloc_r+0x174>
 80012d4:	e196      	b.n	8001604 <_malloc_r+0x494>
 80012d6:	2b00      	cmp	r3, #0
 80012d8:	f280 81a6 	bge.w	8001628 <_malloc_r+0x4b8>
 80012dc:	68c0      	ldr	r0, [r0, #12]
 80012de:	4580      	cmp	r8, r0
 80012e0:	f000 8190 	beq.w	8001604 <_malloc_r+0x494>
 80012e4:	6841      	ldr	r1, [r0, #4]
 80012e6:	f021 0103 	bic.w	r1, r1, #3
 80012ea:	1b0b      	subs	r3, r1, r4
 80012ec:	2b0f      	cmp	r3, #15
 80012ee:	ddf2      	ble.n	80012d6 <_malloc_r+0x166>
 80012f0:	4680      	mov	r8, r0
 80012f2:	68c5      	ldr	r5, [r0, #12]
 80012f4:	1901      	adds	r1, r0, r4
 80012f6:	f044 0e01 	orr.w	lr, r4, #1
 80012fa:	f858 7f08 	ldr.w	r7, [r8, #8]!
 80012fe:	f043 0401 	orr.w	r4, r3, #1
 8001302:	f8c0 e004 	str.w	lr, [r0, #4]
 8001306:	4630      	mov	r0, r6
 8001308:	604c      	str	r4, [r1, #4]
 800130a:	60fd      	str	r5, [r7, #12]
 800130c:	60af      	str	r7, [r5, #8]
 800130e:	60d1      	str	r1, [r2, #12]
 8001310:	6091      	str	r1, [r2, #8]
 8001312:	60ca      	str	r2, [r1, #12]
 8001314:	608a      	str	r2, [r1, #8]
 8001316:	50cb      	str	r3, [r1, r3]
 8001318:	f000 f9ea 	bl	80016f0 <__malloc_unlock>
 800131c:	e75e      	b.n	80011dc <_malloc_r+0x6c>
 800131e:	f1bc 0f04 	cmp.w	ip, #4
 8001322:	bf9e      	ittt	ls
 8001324:	ea4f 1c94 	movls.w	ip, r4, lsr #6
 8001328:	f10c 0c38 	addls.w	ip, ip, #56	; 0x38
 800132c:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 8001330:	f67f af6f 	bls.w	8001212 <_malloc_r+0xa2>
 8001334:	f1bc 0f14 	cmp.w	ip, #20
 8001338:	bf9c      	itt	ls
 800133a:	f10c 0c5b 	addls.w	ip, ip, #91	; 0x5b
 800133e:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 8001342:	f67f af66 	bls.w	8001212 <_malloc_r+0xa2>
 8001346:	f1bc 0f54 	cmp.w	ip, #84	; 0x54
 800134a:	bf9e      	ittt	ls
 800134c:	ea4f 3c14 	movls.w	ip, r4, lsr #12
 8001350:	f10c 0c6e 	addls.w	ip, ip, #110	; 0x6e
 8001354:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 8001358:	f67f af5b 	bls.w	8001212 <_malloc_r+0xa2>
 800135c:	f5bc 7faa 	cmp.w	ip, #340	; 0x154
 8001360:	bf9e      	ittt	ls
 8001362:	ea4f 3cd4 	movls.w	ip, r4, lsr #15
 8001366:	f10c 0c77 	addls.w	ip, ip, #119	; 0x77
 800136a:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 800136e:	f67f af50 	bls.w	8001212 <_malloc_r+0xa2>
 8001372:	f240 5354 	movw	r3, #1364	; 0x554
 8001376:	459c      	cmp	ip, r3
 8001378:	bf95      	itete	ls
 800137a:	ea4f 4c94 	movls.w	ip, r4, lsr #18
 800137e:	f44f 707c 	movhi.w	r0, #1008	; 0x3f0
 8001382:	f10c 0c7c 	addls.w	ip, ip, #124	; 0x7c
 8001386:	f04f 0c7e 	movhi.w	ip, #126	; 0x7e
 800138a:	bf98      	it	ls
 800138c:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 8001390:	e73f      	b.n	8001212 <_malloc_r+0xa2>
 8001392:	181a      	adds	r2, r3, r0
 8001394:	f103 0808 	add.w	r8, r3, #8
 8001398:	4630      	mov	r0, r6
 800139a:	6853      	ldr	r3, [r2, #4]
 800139c:	f043 0301 	orr.w	r3, r3, #1
 80013a0:	6053      	str	r3, [r2, #4]
 80013a2:	f000 f9a5 	bl	80016f0 <__malloc_unlock>
 80013a6:	e719      	b.n	80011dc <_malloc_r+0x6c>
 80013a8:	f8d7 8008 	ldr.w	r8, [r7, #8]
 80013ac:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80013b0:	f023 0903 	bic.w	r9, r3, #3
 80013b4:	454c      	cmp	r4, r9
 80013b6:	ebc4 0209 	rsb	r2, r4, r9
 80013ba:	bf94      	ite	ls
 80013bc:	2300      	movls	r3, #0
 80013be:	2301      	movhi	r3, #1
 80013c0:	2a0f      	cmp	r2, #15
 80013c2:	bfd8      	it	le
 80013c4:	f043 0301 	orrle.w	r3, r3, #1
 80013c8:	2b00      	cmp	r3, #0
 80013ca:	f000 80b9 	beq.w	8001540 <_malloc_r+0x3d0>
 80013ce:	f640 5a98 	movw	sl, #3480	; 0xd98
 80013d2:	f8d5 3408 	ldr.w	r3, [r5, #1032]	; 0x408
 80013d6:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 80013da:	4630      	mov	r0, r6
 80013dc:	f1b3 3fff 	cmp.w	r3, #4294967295
 80013e0:	f8da 2000 	ldr.w	r2, [sl]
 80013e4:	f102 0b10 	add.w	fp, r2, #16
 80013e8:	44a3      	add	fp, r4
 80013ea:	bf1f      	itttt	ne
 80013ec:	f50b 6b7e 	addne.w	fp, fp, #4064	; 0xfe0
 80013f0:	f10b 0b1f 	addne.w	fp, fp, #31
 80013f4:	f42b 6b7e 	bicne.w	fp, fp, #4064	; 0xfe0
 80013f8:	f02b 0b1f 	bicne.w	fp, fp, #31
 80013fc:	4659      	mov	r1, fp
 80013fe:	f000 f979 	bl	80016f4 <_sbrk_r>
 8001402:	f1b0 3fff 	cmp.w	r0, #4294967295
 8001406:	4603      	mov	r3, r0
 8001408:	f000 8118 	beq.w	800163c <_malloc_r+0x4cc>
 800140c:	eb08 0109 	add.w	r1, r8, r9
 8001410:	4281      	cmp	r1, r0
 8001412:	f200 8110 	bhi.w	8001636 <_malloc_r+0x4c6>
 8001416:	f8da 2004 	ldr.w	r2, [sl, #4]
 800141a:	4281      	cmp	r1, r0
 800141c:	445a      	add	r2, fp
 800141e:	f8ca 2004 	str.w	r2, [sl, #4]
 8001422:	f000 813e 	beq.w	80016a2 <_malloc_r+0x532>
 8001426:	f8d5 e408 	ldr.w	lr, [r5, #1032]	; 0x408
 800142a:	f240 05fc 	movw	r5, #252	; 0xfc
 800142e:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8001432:	f1be 3fff 	cmp.w	lr, #4294967295
 8001436:	bf17      	itett	ne
 8001438:	1882      	addne	r2, r0, r2
 800143a:	f8c5 0408 	streq.w	r0, [r5, #1032]	; 0x408
 800143e:	ebc1 0102 	rsbne	r1, r1, r2
 8001442:	f8ca 1004 	strne.w	r1, [sl, #4]
 8001446:	f010 0507 	ands.w	r5, r0, #7
 800144a:	bf17      	itett	ne
 800144c:	f1c5 0508 	rsbne	r5, r5, #8
 8001450:	f44f 5580 	moveq.w	r5, #4096	; 0x1000
 8001454:	1943      	addne	r3, r0, r5
 8001456:	f505 5580 	addne.w	r5, r5, #4096	; 0x1000
 800145a:	eb03 020b 	add.w	r2, r3, fp
 800145e:	4630      	mov	r0, r6
 8001460:	9301      	str	r3, [sp, #4]
 8001462:	0512      	lsls	r2, r2, #20
 8001464:	0d12      	lsrs	r2, r2, #20
 8001466:	1aad      	subs	r5, r5, r2
 8001468:	4629      	mov	r1, r5
 800146a:	f000 f943 	bl	80016f4 <_sbrk_r>
 800146e:	9b01      	ldr	r3, [sp, #4]
 8001470:	f1b0 3fff 	cmp.w	r0, #4294967295
 8001474:	f000 812c 	beq.w	80016d0 <_malloc_r+0x560>
 8001478:	1ac1      	subs	r1, r0, r3
 800147a:	1949      	adds	r1, r1, r5
 800147c:	f041 0101 	orr.w	r1, r1, #1
 8001480:	f8da 2004 	ldr.w	r2, [sl, #4]
 8001484:	45b8      	cmp	r8, r7
 8001486:	f640 5b98 	movw	fp, #3480	; 0xd98
 800148a:	60bb      	str	r3, [r7, #8]
 800148c:	442a      	add	r2, r5
 800148e:	f2c2 0b00 	movt	fp, #8192	; 0x2000
 8001492:	6059      	str	r1, [r3, #4]
 8001494:	f8ca 2004 	str.w	r2, [sl, #4]
 8001498:	d017      	beq.n	80014ca <_malloc_r+0x35a>
 800149a:	f1b9 0f0f 	cmp.w	r9, #15
 800149e:	f240 80e1 	bls.w	8001664 <_malloc_r+0x4f4>
 80014a2:	f1a9 030c 	sub.w	r3, r9, #12
 80014a6:	f8d8 5004 	ldr.w	r5, [r8, #4]
 80014aa:	f023 0307 	bic.w	r3, r3, #7
 80014ae:	2005      	movs	r0, #5
 80014b0:	eb08 0103 	add.w	r1, r8, r3
 80014b4:	2b0f      	cmp	r3, #15
 80014b6:	f005 0501 	and.w	r5, r5, #1
 80014ba:	ea43 0505 	orr.w	r5, r3, r5
 80014be:	f8c8 5004 	str.w	r5, [r8, #4]
 80014c2:	6048      	str	r0, [r1, #4]
 80014c4:	6088      	str	r0, [r1, #8]
 80014c6:	f200 80fb 	bhi.w	80016c0 <_malloc_r+0x550>
 80014ca:	f8da 102c 	ldr.w	r1, [sl, #44]	; 0x2c
 80014ce:	f640 5398 	movw	r3, #3480	; 0xd98
 80014d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80014d6:	428a      	cmp	r2, r1
 80014d8:	f8da 1030 	ldr.w	r1, [sl, #48]	; 0x30
 80014dc:	bf88      	it	hi
 80014de:	62da      	strhi	r2, [r3, #44]	; 0x2c
 80014e0:	f640 5398 	movw	r3, #3480	; 0xd98
 80014e4:	428a      	cmp	r2, r1
 80014e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80014ea:	f240 80a7 	bls.w	800163c <_malloc_r+0x4cc>
 80014ee:	f8d7 8008 	ldr.w	r8, [r7, #8]
 80014f2:	631a      	str	r2, [r3, #48]	; 0x30
 80014f4:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80014f8:	f023 0303 	bic.w	r3, r3, #3
 80014fc:	429c      	cmp	r4, r3
 80014fe:	ebc4 0203 	rsb	r2, r4, r3
 8001502:	bf94      	ite	ls
 8001504:	2300      	movls	r3, #0
 8001506:	2301      	movhi	r3, #1
 8001508:	2a0f      	cmp	r2, #15
 800150a:	bfd8      	it	le
 800150c:	f043 0301 	orrle.w	r3, r3, #1
 8001510:	b1b3      	cbz	r3, 8001540 <_malloc_r+0x3d0>
 8001512:	4630      	mov	r0, r6
 8001514:	f04f 0800 	mov.w	r8, #0
 8001518:	f000 f8ea 	bl	80016f0 <__malloc_unlock>
 800151c:	e65e      	b.n	80011dc <_malloc_r+0x6c>
 800151e:	189a      	adds	r2, r3, r2
 8001520:	68d9      	ldr	r1, [r3, #12]
 8001522:	689c      	ldr	r4, [r3, #8]
 8001524:	f103 0808 	add.w	r8, r3, #8
 8001528:	6855      	ldr	r5, [r2, #4]
 800152a:	4630      	mov	r0, r6
 800152c:	f045 0301 	orr.w	r3, r5, #1
 8001530:	60e1      	str	r1, [r4, #12]
 8001532:	608c      	str	r4, [r1, #8]
 8001534:	6053      	str	r3, [r2, #4]
 8001536:	f000 f8db 	bl	80016f0 <__malloc_unlock>
 800153a:	e64f      	b.n	80011dc <_malloc_r+0x6c>
 800153c:	20000104 	.word	0x20000104
 8001540:	eb08 0304 	add.w	r3, r8, r4
 8001544:	f042 0201 	orr.w	r2, r2, #1
 8001548:	f044 0401 	orr.w	r4, r4, #1
 800154c:	4630      	mov	r0, r6
 800154e:	f8c8 4004 	str.w	r4, [r8, #4]
 8001552:	f108 0808 	add.w	r8, r8, #8
 8001556:	605a      	str	r2, [r3, #4]
 8001558:	60bb      	str	r3, [r7, #8]
 800155a:	f000 f8c9 	bl	80016f0 <__malloc_unlock>
 800155e:	e63d      	b.n	80011dc <_malloc_r+0x6c>
 8001560:	0a41      	lsrs	r1, r0, #9
 8001562:	2904      	cmp	r1, #4
 8001564:	bf9c      	itt	ls
 8001566:	ea4f 1e90 	movls.w	lr, r0, lsr #6
 800156a:	f10e 0e38 	addls.w	lr, lr, #56	; 0x38
 800156e:	d91d      	bls.n	80015ac <_malloc_r+0x43c>
 8001570:	2914      	cmp	r1, #20
 8001572:	bf98      	it	ls
 8001574:	f101 0e5b 	addls.w	lr, r1, #91	; 0x5b
 8001578:	d918      	bls.n	80015ac <_malloc_r+0x43c>
 800157a:	2954      	cmp	r1, #84	; 0x54
 800157c:	bf9c      	itt	ls
 800157e:	ea4f 3e10 	movls.w	lr, r0, lsr #12
 8001582:	f10e 0e6e 	addls.w	lr, lr, #110	; 0x6e
 8001586:	d911      	bls.n	80015ac <_malloc_r+0x43c>
 8001588:	f5b1 7faa 	cmp.w	r1, #340	; 0x154
 800158c:	bf9c      	itt	ls
 800158e:	ea4f 3ed0 	movls.w	lr, r0, lsr #15
 8001592:	f10e 0e77 	addls.w	lr, lr, #119	; 0x77
 8001596:	d909      	bls.n	80015ac <_malloc_r+0x43c>
 8001598:	f240 5e54 	movw	lr, #1364	; 0x554
 800159c:	4571      	cmp	r1, lr
 800159e:	bf96      	itet	ls
 80015a0:	ea4f 4e90 	movls.w	lr, r0, lsr #18
 80015a4:	f04f 0e7e 	movhi.w	lr, #126	; 0x7e
 80015a8:	f10e 0e7c 	addls.w	lr, lr, #124	; 0x7c
 80015ac:	eb07 08ce 	add.w	r8, r7, lr, lsl #3
 80015b0:	f8d8 1008 	ldr.w	r1, [r8, #8]
 80015b4:	4541      	cmp	r1, r8
 80015b6:	d103      	bne.n	80015c0 <_malloc_r+0x450>
 80015b8:	e047      	b.n	800164a <_malloc_r+0x4da>
 80015ba:	6889      	ldr	r1, [r1, #8]
 80015bc:	4588      	cmp	r8, r1
 80015be:	d005      	beq.n	80015cc <_malloc_r+0x45c>
 80015c0:	f8d1 e004 	ldr.w	lr, [r1, #4]
 80015c4:	f02e 0e03 	bic.w	lr, lr, #3
 80015c8:	4570      	cmp	r0, lr
 80015ca:	d3f6      	bcc.n	80015ba <_malloc_r+0x44a>
 80015cc:	f8d1 e00c 	ldr.w	lr, [r1, #12]
 80015d0:	f8c3 e00c 	str.w	lr, [r3, #12]
 80015d4:	6099      	str	r1, [r3, #8]
 80015d6:	6878      	ldr	r0, [r7, #4]
 80015d8:	60cb      	str	r3, [r1, #12]
 80015da:	f8ce 3008 	str.w	r3, [lr, #8]
 80015de:	e65d      	b.n	800129c <_malloc_r+0x12c>
 80015e0:	191d      	adds	r5, r3, r4
 80015e2:	f041 0701 	orr.w	r7, r1, #1
 80015e6:	60d5      	str	r5, [r2, #12]
 80015e8:	f044 0401 	orr.w	r4, r4, #1
 80015ec:	6095      	str	r5, [r2, #8]
 80015ee:	4630      	mov	r0, r6
 80015f0:	605c      	str	r4, [r3, #4]
 80015f2:	f103 0808 	add.w	r8, r3, #8
 80015f6:	60ea      	str	r2, [r5, #12]
 80015f8:	60aa      	str	r2, [r5, #8]
 80015fa:	606f      	str	r7, [r5, #4]
 80015fc:	5069      	str	r1, [r5, r1]
 80015fe:	f000 f877 	bl	80016f0 <__malloc_unlock>
 8001602:	e5eb      	b.n	80011dc <_malloc_r+0x6c>
 8001604:	f109 0901 	add.w	r9, r9, #1
 8001608:	f019 0f03 	tst.w	r9, #3
 800160c:	d02f      	beq.n	800166e <_malloc_r+0x4fe>
 800160e:	f108 0808 	add.w	r8, r8, #8
 8001612:	e65b      	b.n	80012cc <_malloc_r+0x15c>
 8001614:	f103 0208 	add.w	r2, r3, #8
 8001618:	695b      	ldr	r3, [r3, #20]
 800161a:	429a      	cmp	r2, r3
 800161c:	bf08      	it	eq
 800161e:	f10c 0c02 	addeq.w	ip, ip, #2
 8001622:	f43f ae10 	beq.w	8001246 <_malloc_r+0xd6>
 8001626:	e5c8      	b.n	80011ba <_malloc_r+0x4a>
 8001628:	4680      	mov	r8, r0
 800162a:	1843      	adds	r3, r0, r1
 800162c:	68c2      	ldr	r2, [r0, #12]
 800162e:	4630      	mov	r0, r6
 8001630:	f858 1f08 	ldr.w	r1, [r8, #8]!
 8001634:	e5ca      	b.n	80011cc <_malloc_r+0x5c>
 8001636:	45b8      	cmp	r8, r7
 8001638:	f43f aeed 	beq.w	8001416 <_malloc_r+0x2a6>
 800163c:	f8d7 8008 	ldr.w	r8, [r7, #8]
 8001640:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8001644:	f023 0303 	bic.w	r3, r3, #3
 8001648:	e758      	b.n	80014fc <_malloc_r+0x38c>
 800164a:	f04f 0901 	mov.w	r9, #1
 800164e:	f8d7 8004 	ldr.w	r8, [r7, #4]
 8001652:	ea4f 00ae 	mov.w	r0, lr, asr #2
 8001656:	468e      	mov	lr, r1
 8001658:	fa09 f000 	lsl.w	r0, r9, r0
 800165c:	ea48 0000 	orr.w	r0, r8, r0
 8001660:	6078      	str	r0, [r7, #4]
 8001662:	e7b5      	b.n	80015d0 <_malloc_r+0x460>
 8001664:	4698      	mov	r8, r3
 8001666:	2201      	movs	r2, #1
 8001668:	605a      	str	r2, [r3, #4]
 800166a:	2300      	movs	r3, #0
 800166c:	e746      	b.n	80014fc <_malloc_r+0x38c>
 800166e:	4651      	mov	r1, sl
 8001670:	f01c 0f03 	tst.w	ip, #3
 8001674:	460b      	mov	r3, r1
 8001676:	f10c 3cff 	add.w	ip, ip, #4294967295
 800167a:	d02c      	beq.n	80016d6 <_malloc_r+0x566>
 800167c:	f853 1908 	ldr.w	r1, [r3], #-8
 8001680:	4299      	cmp	r1, r3
 8001682:	d0f5      	beq.n	8001670 <_malloc_r+0x500>
 8001684:	687b      	ldr	r3, [r7, #4]
 8001686:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 800168a:	459e      	cmp	lr, r3
 800168c:	f63f ae8c 	bhi.w	80013a8 <_malloc_r+0x238>
 8001690:	f1be 0f00 	cmp.w	lr, #0
 8001694:	f43f ae88 	beq.w	80013a8 <_malloc_r+0x238>
 8001698:	ea1e 0f03 	tst.w	lr, r3
 800169c:	d020      	beq.n	80016e0 <_malloc_r+0x570>
 800169e:	46cc      	mov	ip, r9
 80016a0:	e610      	b.n	80012c4 <_malloc_r+0x154>
 80016a2:	ea4f 5e01 	mov.w	lr, r1, lsl #20
 80016a6:	ea4f 5e1e 	mov.w	lr, lr, lsr #20
 80016aa:	f1be 0f00 	cmp.w	lr, #0
 80016ae:	f47f aeba 	bne.w	8001426 <_malloc_r+0x2b6>
 80016b2:	68bb      	ldr	r3, [r7, #8]
 80016b4:	eb0b 0109 	add.w	r1, fp, r9
 80016b8:	f041 0101 	orr.w	r1, r1, #1
 80016bc:	6059      	str	r1, [r3, #4]
 80016be:	e704      	b.n	80014ca <_malloc_r+0x35a>
 80016c0:	4630      	mov	r0, r6
 80016c2:	f108 0108 	add.w	r1, r8, #8
 80016c6:	f7ff fc87 	bl	8000fd8 <_free_r>
 80016ca:	f8db 2004 	ldr.w	r2, [fp, #4]
 80016ce:	e6fc      	b.n	80014ca <_malloc_r+0x35a>
 80016d0:	2101      	movs	r1, #1
 80016d2:	2500      	movs	r5, #0
 80016d4:	e6d4      	b.n	8001480 <_malloc_r+0x310>
 80016d6:	687b      	ldr	r3, [r7, #4]
 80016d8:	ea23 030e 	bic.w	r3, r3, lr
 80016dc:	607b      	str	r3, [r7, #4]
 80016de:	e7d1      	b.n	8001684 <_malloc_r+0x514>
 80016e0:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 80016e4:	f109 0904 	add.w	r9, r9, #4
 80016e8:	e7d6      	b.n	8001698 <_malloc_r+0x528>
 80016ea:	bf00      	nop

080016ec <__malloc_lock>:
 80016ec:	4770      	bx	lr
 80016ee:	bf00      	nop

080016f0 <__malloc_unlock>:
 80016f0:	4770      	bx	lr
 80016f2:	bf00      	nop

080016f4 <_sbrk_r>:
 80016f4:	b538      	push	{r3, r4, r5, lr}
 80016f6:	f241 6454 	movw	r4, #5716	; 0x1654
 80016fa:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80016fe:	4605      	mov	r5, r0
 8001700:	4608      	mov	r0, r1
 8001702:	2300      	movs	r3, #0
 8001704:	6023      	str	r3, [r4, #0]
 8001706:	f7fe fedd 	bl	80004c4 <_sbrk>
 800170a:	f1b0 3fff 	cmp.w	r0, #4294967295
 800170e:	d000      	beq.n	8001712 <_sbrk_r+0x1e>
 8001710:	bd38      	pop	{r3, r4, r5, pc}
 8001712:	6823      	ldr	r3, [r4, #0]
 8001714:	2b00      	cmp	r3, #0
 8001716:	d0fb      	beq.n	8001710 <_sbrk_r+0x1c>
 8001718:	602b      	str	r3, [r5, #0]
 800171a:	bd38      	pop	{r3, r4, r5, pc}

0800171c <convert>:
 800171c:	4603      	mov	r3, r0
 800171e:	2001      	movs	r0, #1
 8001720:	b10b      	cbz	r3, 8001726 <convert+0xa>
 8001722:	3b03      	subs	r3, #3
 8001724:	4098      	lsls	r0, r3
 8001726:	4770      	bx	lr

08001728 <clockspecifysetup>:
 8001728:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800172c:	4c50      	ldr	r4, [pc, #320]	; (8001870 <clockspecifysetup+0x148>)
 800172e:	7807      	ldrb	r7, [r0, #0]
 8001730:	2300      	movs	r3, #0
 8001732:	6023      	str	r3, [r4, #0]
 8001734:	2f04      	cmp	r7, #4
 8001736:	d835      	bhi.n	80017a4 <clockspecifysetup+0x7c>
 8001738:	e8df f007 	tbb	[pc, r7]
 800173c:	170c0335 	.word	0x170c0335
 8001740:	24          	.byte	0x24
 8001741:	00          	.byte	0x00
 8001742:	4b4c      	ldr	r3, [pc, #304]	; (8001874 <clockspecifysetup+0x14c>)
 8001744:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8001748:	601a      	str	r2, [r3, #0]
 800174a:	681a      	ldr	r2, [r3, #0]
 800174c:	0392      	lsls	r2, r2, #14
 800174e:	d5fc      	bpl.n	800174a <clockspecifysetup+0x22>
 8001750:	2601      	movs	r6, #1
 8001752:	e029      	b.n	80017a8 <clockspecifysetup+0x80>
 8001754:	4b47      	ldr	r3, [pc, #284]	; (8001874 <clockspecifysetup+0x14c>)
 8001756:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 800175a:	601a      	str	r2, [r3, #0]
 800175c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8001760:	601a      	str	r2, [r3, #0]
 8001762:	681a      	ldr	r2, [r3, #0]
 8001764:	0396      	lsls	r6, r2, #14
 8001766:	d5fc      	bpl.n	8001762 <clockspecifysetup+0x3a>
 8001768:	e7f2      	b.n	8001750 <clockspecifysetup+0x28>
 800176a:	4a43      	ldr	r2, [pc, #268]	; (8001878 <clockspecifysetup+0x150>)
 800176c:	6813      	ldr	r3, [r2, #0]
 800176e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001772:	6013      	str	r3, [r2, #0]
 8001774:	4b3f      	ldr	r3, [pc, #252]	; (8001874 <clockspecifysetup+0x14c>)
 8001776:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 800177a:	601a      	str	r2, [r3, #0]
 800177c:	681a      	ldr	r2, [r3, #0]
 800177e:	0395      	lsls	r5, r2, #14
 8001780:	d5fc      	bpl.n	800177c <clockspecifysetup+0x54>
 8001782:	e7e5      	b.n	8001750 <clockspecifysetup+0x28>
 8001784:	4a3c      	ldr	r2, [pc, #240]	; (8001878 <clockspecifysetup+0x150>)
 8001786:	6813      	ldr	r3, [r2, #0]
 8001788:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800178c:	6013      	str	r3, [r2, #0]
 800178e:	4b39      	ldr	r3, [pc, #228]	; (8001874 <clockspecifysetup+0x14c>)
 8001790:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 8001794:	601a      	str	r2, [r3, #0]
 8001796:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 800179a:	601a      	str	r2, [r3, #0]
 800179c:	681a      	ldr	r2, [r3, #0]
 800179e:	0391      	lsls	r1, r2, #14
 80017a0:	d5fc      	bpl.n	800179c <clockspecifysetup+0x74>
 80017a2:	e7d5      	b.n	8001750 <clockspecifysetup+0x28>
 80017a4:	e7fe      	b.n	80017a4 <clockspecifysetup+0x7c>
 80017a6:	2600      	movs	r6, #0
 80017a8:	7843      	ldrb	r3, [r0, #1]
 80017aa:	4d34      	ldr	r5, [pc, #208]	; (800187c <clockspecifysetup+0x154>)
 80017ac:	6882      	ldr	r2, [r0, #8]
 80017ae:	5ce9      	ldrb	r1, [r5, r3]
 80017b0:	434a      	muls	r2, r1
 80017b2:	78c1      	ldrb	r1, [r0, #3]
 80017b4:	3101      	adds	r1, #1
 80017b6:	0049      	lsls	r1, r1, #1
 80017b8:	fbb2 f2f1 	udiv	r2, r2, r1
 80017bc:	4930      	ldr	r1, [pc, #192]	; (8001880 <clockspecifysetup+0x158>)
 80017be:	b90f      	cbnz	r7, 80017c4 <clockspecifysetup+0x9c>
 80017c0:	b103      	cbz	r3, 80017c4 <clockspecifysetup+0x9c>
 80017c2:	0852      	lsrs	r2, r2, #1
 80017c4:	600a      	str	r2, [r1, #0]
 80017c6:	6809      	ldr	r1, [r1, #0]
 80017c8:	4a2e      	ldr	r2, [pc, #184]	; (8001884 <clockspecifysetup+0x15c>)
 80017ca:	4291      	cmp	r1, r2
 80017cc:	d906      	bls.n	80017dc <clockspecifysetup+0xb4>
 80017ce:	4a2e      	ldr	r2, [pc, #184]	; (8001888 <clockspecifysetup+0x160>)
 80017d0:	4291      	cmp	r1, r2
 80017d2:	4a2e      	ldr	r2, [pc, #184]	; (800188c <clockspecifysetup+0x164>)
 80017d4:	bf94      	ite	ls
 80017d6:	2731      	movls	r7, #49	; 0x31
 80017d8:	2732      	movhi	r7, #50	; 0x32
 80017da:	6017      	str	r7, [r2, #0]
 80017dc:	7947      	ldrb	r7, [r0, #5]
 80017de:	f890 e004 	ldrb.w	lr, [r0, #4]
 80017e2:	f890 c006 	ldrb.w	ip, [r0, #6]
 80017e6:	02fa      	lsls	r2, r7, #11
 80017e8:	ea42 220e 	orr.w	r2, r2, lr, lsl #8
 80017ec:	ea42 120c 	orr.w	r2, r2, ip, lsl #4
 80017f0:	f8df 807c 	ldr.w	r8, [pc, #124]	; 8001870 <clockspecifysetup+0x148>
 80017f4:	6022      	str	r2, [r4, #0]
 80017f6:	b1a3      	cbz	r3, 8001822 <clockspecifysetup+0xfa>
 80017f8:	78c2      	ldrb	r2, [r0, #3]
 80017fa:	049b      	lsls	r3, r3, #18
 80017fc:	ea43 4242 	orr.w	r2, r3, r2, lsl #17
 8001800:	7883      	ldrb	r3, [r0, #2]
 8001802:	f8d8 6000 	ldr.w	r6, [r8]
 8001806:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
 800180a:	4333      	orrs	r3, r6
 800180c:	f8c8 3000 	str.w	r3, [r8]
 8001810:	4b18      	ldr	r3, [pc, #96]	; (8001874 <clockspecifysetup+0x14c>)
 8001812:	681a      	ldr	r2, [r3, #0]
 8001814:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8001818:	601a      	str	r2, [r3, #0]
 800181a:	681a      	ldr	r2, [r3, #0]
 800181c:	0192      	lsls	r2, r2, #6
 800181e:	d5fc      	bpl.n	800181a <clockspecifysetup+0xf2>
 8001820:	2602      	movs	r6, #2
 8001822:	6823      	ldr	r3, [r4, #0]
 8001824:	f023 0303 	bic.w	r3, r3, #3
 8001828:	4333      	orrs	r3, r6
 800182a:	6023      	str	r3, [r4, #0]
 800182c:	00b6      	lsls	r6, r6, #2
 800182e:	6823      	ldr	r3, [r4, #0]
 8001830:	f003 030c 	and.w	r3, r3, #12
 8001834:	42b3      	cmp	r3, r6
 8001836:	d1fa      	bne.n	800182e <clockspecifysetup+0x106>
 8001838:	eb05 054c 	add.w	r5, r5, ip, lsl #1
 800183c:	8a2c      	ldrh	r4, [r5, #16]
 800183e:	4a14      	ldr	r2, [pc, #80]	; (8001890 <clockspecifysetup+0x168>)
 8001840:	fbb1 f4f4 	udiv	r4, r1, r4
 8001844:	6813      	ldr	r3, [r2, #0]
 8001846:	4670      	mov	r0, lr
 8001848:	f043 037c 	orr.w	r3, r3, #124	; 0x7c
 800184c:	6013      	str	r3, [r2, #0]
 800184e:	4b11      	ldr	r3, [pc, #68]	; (8001894 <clockspecifysetup+0x16c>)
 8001850:	601c      	str	r4, [r3, #0]
 8001852:	f7ff ff63 	bl	800171c <convert>
 8001856:	fbb4 f0f0 	udiv	r0, r4, r0
 800185a:	4b0f      	ldr	r3, [pc, #60]	; (8001898 <clockspecifysetup+0x170>)
 800185c:	6018      	str	r0, [r3, #0]
 800185e:	4638      	mov	r0, r7
 8001860:	f7ff ff5c 	bl	800171c <convert>
 8001864:	fbb4 f0f0 	udiv	r0, r4, r0
 8001868:	4b0c      	ldr	r3, [pc, #48]	; (800189c <clockspecifysetup+0x174>)
 800186a:	6018      	str	r0, [r3, #0]
 800186c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001870:	40021004 	.word	0x40021004
 8001874:	40021000 	.word	0x40021000
 8001878:	40010004 	.word	0x40010004
 800187c:	08003a74 	.word	0x08003a74
 8001880:	20000dcc 	.word	0x20000dcc
 8001884:	016e3600 	.word	0x016e3600
 8001888:	02dc6c00 	.word	0x02dc6c00
 800188c:	40022000 	.word	0x40022000
 8001890:	40021018 	.word	0x40021018
 8001894:	20000dd8 	.word	0x20000dd8
 8001898:	20000dd4 	.word	0x20000dd4
 800189c:	20000dd0 	.word	0x20000dd0

080018a0 <DTW_counter_init>:
 80018a0:	4a05      	ldr	r2, [pc, #20]	; (80018b8 <DTW_counter_init+0x18>)
 80018a2:	6813      	ldr	r3, [r2, #0]
 80018a4:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80018a8:	6013      	str	r3, [r2, #0]
 80018aa:	4a04      	ldr	r2, [pc, #16]	; (80018bc <DTW_counter_init+0x1c>)
 80018ac:	6813      	ldr	r3, [r2, #0]
 80018ae:	f043 0301 	orr.w	r3, r3, #1
 80018b2:	6013      	str	r3, [r2, #0]
 80018b4:	4770      	bx	lr
 80018b6:	bf00      	nop
 80018b8:	e000edfc 	.word	0xe000edfc
 80018bc:	e0001000 	.word	0xe0001000

080018c0 <uli2a>:
 80018c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80018c2:	2401      	movs	r4, #1
 80018c4:	fbb0 f5f4 	udiv	r5, r0, r4
 80018c8:	428d      	cmp	r5, r1
 80018ca:	d301      	bcc.n	80018d0 <uli2a+0x10>
 80018cc:	434c      	muls	r4, r1
 80018ce:	e7f9      	b.n	80018c4 <uli2a+0x4>
 80018d0:	2600      	movs	r6, #0
 80018d2:	b1d4      	cbz	r4, 800190a <uli2a+0x4a>
 80018d4:	fbb0 f5f4 	udiv	r5, r0, r4
 80018d8:	fb04 0015 	mls	r0, r4, r5, r0
 80018dc:	fbb4 f4f1 	udiv	r4, r4, r1
 80018e0:	b91e      	cbnz	r6, 80018ea <uli2a+0x2a>
 80018e2:	2d00      	cmp	r5, #0
 80018e4:	dc01      	bgt.n	80018ea <uli2a+0x2a>
 80018e6:	2c00      	cmp	r4, #0
 80018e8:	d1f3      	bne.n	80018d2 <uli2a+0x12>
 80018ea:	2d09      	cmp	r5, #9
 80018ec:	f103 0e01 	add.w	lr, r3, #1
 80018f0:	b2ef      	uxtb	r7, r5
 80018f2:	dd04      	ble.n	80018fe <uli2a+0x3e>
 80018f4:	2a00      	cmp	r2, #0
 80018f6:	bf14      	ite	ne
 80018f8:	2537      	movne	r5, #55	; 0x37
 80018fa:	2557      	moveq	r5, #87	; 0x57
 80018fc:	e000      	b.n	8001900 <uli2a+0x40>
 80018fe:	2530      	movs	r5, #48	; 0x30
 8001900:	443d      	add	r5, r7
 8001902:	701d      	strb	r5, [r3, #0]
 8001904:	3601      	adds	r6, #1
 8001906:	4673      	mov	r3, lr
 8001908:	e7e3      	b.n	80018d2 <uli2a+0x12>
 800190a:	701c      	strb	r4, [r3, #0]
 800190c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800190e <ui2a>:
 800190e:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001910:	2401      	movs	r4, #1
 8001912:	fbb0 f5f4 	udiv	r5, r0, r4
 8001916:	428d      	cmp	r5, r1
 8001918:	d301      	bcc.n	800191e <ui2a+0x10>
 800191a:	434c      	muls	r4, r1
 800191c:	e7f9      	b.n	8001912 <ui2a+0x4>
 800191e:	2600      	movs	r6, #0
 8001920:	b1d4      	cbz	r4, 8001958 <ui2a+0x4a>
 8001922:	fbb0 f5f4 	udiv	r5, r0, r4
 8001926:	fb04 0015 	mls	r0, r4, r5, r0
 800192a:	fbb4 f4f1 	udiv	r4, r4, r1
 800192e:	b91e      	cbnz	r6, 8001938 <ui2a+0x2a>
 8001930:	2d00      	cmp	r5, #0
 8001932:	dc01      	bgt.n	8001938 <ui2a+0x2a>
 8001934:	2c00      	cmp	r4, #0
 8001936:	d1f3      	bne.n	8001920 <ui2a+0x12>
 8001938:	2d09      	cmp	r5, #9
 800193a:	f103 0e01 	add.w	lr, r3, #1
 800193e:	b2ef      	uxtb	r7, r5
 8001940:	dd04      	ble.n	800194c <ui2a+0x3e>
 8001942:	2a00      	cmp	r2, #0
 8001944:	bf14      	ite	ne
 8001946:	2537      	movne	r5, #55	; 0x37
 8001948:	2557      	moveq	r5, #87	; 0x57
 800194a:	e000      	b.n	800194e <ui2a+0x40>
 800194c:	2530      	movs	r5, #48	; 0x30
 800194e:	443d      	add	r5, r7
 8001950:	701d      	strb	r5, [r3, #0]
 8001952:	3601      	adds	r6, #1
 8001954:	4673      	mov	r3, lr
 8001956:	e7e3      	b.n	8001920 <ui2a+0x12>
 8001958:	701c      	strb	r4, [r3, #0]
 800195a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800195c <putchw>:
 800195c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001960:	9d06      	ldr	r5, [sp, #24]
 8001962:	2b00      	cmp	r3, #0
 8001964:	4606      	mov	r6, r0
 8001966:	460f      	mov	r7, r1
 8001968:	462b      	mov	r3, r5
 800196a:	bf14      	ite	ne
 800196c:	f04f 0830 	movne.w	r8, #48	; 0x30
 8001970:	f04f 0820 	moveq.w	r8, #32
 8001974:	f813 1b01 	ldrb.w	r1, [r3], #1
 8001978:	b909      	cbnz	r1, 800197e <putchw+0x22>
 800197a:	4614      	mov	r4, r2
 800197c:	e003      	b.n	8001986 <putchw+0x2a>
 800197e:	2a00      	cmp	r2, #0
 8001980:	ddfb      	ble.n	800197a <putchw+0x1e>
 8001982:	3a01      	subs	r2, #1
 8001984:	e7f6      	b.n	8001974 <putchw+0x18>
 8001986:	2c00      	cmp	r4, #0
 8001988:	dd04      	ble.n	8001994 <putchw+0x38>
 800198a:	4630      	mov	r0, r6
 800198c:	4641      	mov	r1, r8
 800198e:	47b8      	blx	r7
 8001990:	3c01      	subs	r4, #1
 8001992:	e7f8      	b.n	8001986 <putchw+0x2a>
 8001994:	f815 1b01 	ldrb.w	r1, [r5], #1
 8001998:	b111      	cbz	r1, 80019a0 <putchw+0x44>
 800199a:	4630      	mov	r0, r6
 800199c:	47b8      	blx	r7
 800199e:	e7f9      	b.n	8001994 <putchw+0x38>
 80019a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080019a4 <putcp>:
 80019a4:	6803      	ldr	r3, [r0, #0]
 80019a6:	1c5a      	adds	r2, r3, #1
 80019a8:	6002      	str	r2, [r0, #0]
 80019aa:	7019      	strb	r1, [r3, #0]
 80019ac:	4770      	bx	lr

080019ae <tfp_format>:
 80019ae:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80019b2:	4680      	mov	r8, r0
 80019b4:	4689      	mov	r9, r1
 80019b6:	4615      	mov	r5, r2
 80019b8:	461c      	mov	r4, r3
 80019ba:	b087      	sub	sp, #28
 80019bc:	7829      	ldrb	r1, [r5, #0]
 80019be:	2900      	cmp	r1, #0
 80019c0:	f000 80c7 	beq.w	8001b52 <tfp_format+0x1a4>
 80019c4:	2925      	cmp	r1, #37	; 0x25
 80019c6:	d002      	beq.n	80019ce <tfp_format+0x20>
 80019c8:	3501      	adds	r5, #1
 80019ca:	4640      	mov	r0, r8
 80019cc:	e083      	b.n	8001ad6 <tfp_format+0x128>
 80019ce:	786a      	ldrb	r2, [r5, #1]
 80019d0:	2700      	movs	r7, #0
 80019d2:	2a30      	cmp	r2, #48	; 0x30
 80019d4:	bf0c      	ite	eq
 80019d6:	78aa      	ldrbeq	r2, [r5, #2]
 80019d8:	1cae      	addne	r6, r5, #2
 80019da:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 80019de:	bf12      	itee	ne
 80019e0:	f04f 0a00 	movne.w	sl, #0
 80019e4:	1cee      	addeq	r6, r5, #3
 80019e6:	f04f 0a01 	moveq.w	sl, #1
 80019ea:	2b09      	cmp	r3, #9
 80019ec:	d819      	bhi.n	8001a22 <tfp_format+0x74>
 80019ee:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 80019f2:	b2d9      	uxtb	r1, r3
 80019f4:	2909      	cmp	r1, #9
 80019f6:	d805      	bhi.n	8001a04 <tfp_format+0x56>
 80019f8:	220a      	movs	r2, #10
 80019fa:	fb02 3707 	mla	r7, r2, r7, r3
 80019fe:	f816 2b01 	ldrb.w	r2, [r6], #1
 8001a02:	e7f4      	b.n	80019ee <tfp_format+0x40>
 8001a04:	f1a2 0361 	sub.w	r3, r2, #97	; 0x61
 8001a08:	2b05      	cmp	r3, #5
 8001a0a:	d802      	bhi.n	8001a12 <tfp_format+0x64>
 8001a0c:	f1a2 0357 	sub.w	r3, r2, #87	; 0x57
 8001a10:	e005      	b.n	8001a1e <tfp_format+0x70>
 8001a12:	f1a2 0341 	sub.w	r3, r2, #65	; 0x41
 8001a16:	2b05      	cmp	r3, #5
 8001a18:	d803      	bhi.n	8001a22 <tfp_format+0x74>
 8001a1a:	f1a2 0337 	sub.w	r3, r2, #55	; 0x37
 8001a1e:	2b0a      	cmp	r3, #10
 8001a20:	ddea      	ble.n	80019f8 <tfp_format+0x4a>
 8001a22:	2a6c      	cmp	r2, #108	; 0x6c
 8001a24:	d13b      	bne.n	8001a9e <tfp_format+0xf0>
 8001a26:	7832      	ldrb	r2, [r6, #0]
 8001a28:	1c75      	adds	r5, r6, #1
 8001a2a:	2a63      	cmp	r2, #99	; 0x63
 8001a2c:	d03a      	beq.n	8001aa4 <tfp_format+0xf6>
 8001a2e:	d807      	bhi.n	8001a40 <tfp_format+0x92>
 8001a30:	2a25      	cmp	r2, #37	; 0x25
 8001a32:	d04e      	beq.n	8001ad2 <tfp_format+0x124>
 8001a34:	2a58      	cmp	r2, #88	; 0x58
 8001a36:	d00d      	beq.n	8001a54 <tfp_format+0xa6>
 8001a38:	2a00      	cmp	r2, #0
 8001a3a:	f000 808a 	beq.w	8001b52 <tfp_format+0x1a4>
 8001a3e:	e7bd      	b.n	80019bc <tfp_format+0xe>
 8001a40:	2a73      	cmp	r2, #115	; 0x73
 8001a42:	d038      	beq.n	8001ab6 <tfp_format+0x108>
 8001a44:	d802      	bhi.n	8001a4c <tfp_format+0x9e>
 8001a46:	2a64      	cmp	r2, #100	; 0x64
 8001a48:	d064      	beq.n	8001b14 <tfp_format+0x166>
 8001a4a:	e7b7      	b.n	80019bc <tfp_format+0xe>
 8001a4c:	2a75      	cmp	r2, #117	; 0x75
 8001a4e:	d051      	beq.n	8001af4 <tfp_format+0x146>
 8001a50:	2a78      	cmp	r2, #120	; 0x78
 8001a52:	d1b3      	bne.n	80019bc <tfp_format+0xe>
 8001a54:	1d26      	adds	r6, r4, #4
 8001a56:	6820      	ldr	r0, [r4, #0]
 8001a58:	f1a2 0458 	sub.w	r4, r2, #88	; 0x58
 8001a5c:	4262      	negs	r2, r4
 8001a5e:	f04f 0110 	mov.w	r1, #16
 8001a62:	4162      	adcs	r2, r4
 8001a64:	ab03      	add	r3, sp, #12
 8001a66:	f7ff ff2b 	bl	80018c0 <uli2a>
 8001a6a:	4634      	mov	r4, r6
 8001a6c:	e00e      	b.n	8001a8c <tfp_format+0xde>
 8001a6e:	2a58      	cmp	r2, #88	; 0x58
 8001a70:	d133      	bne.n	8001ada <tfp_format+0x12c>
 8001a72:	f1a2 0358 	sub.w	r3, r2, #88	; 0x58
 8001a76:	425a      	negs	r2, r3
 8001a78:	f104 0504 	add.w	r5, r4, #4
 8001a7c:	6820      	ldr	r0, [r4, #0]
 8001a7e:	415a      	adcs	r2, r3
 8001a80:	2110      	movs	r1, #16
 8001a82:	ab03      	add	r3, sp, #12
 8001a84:	462c      	mov	r4, r5
 8001a86:	f7ff ff42 	bl	800190e <ui2a>
 8001a8a:	4635      	mov	r5, r6
 8001a8c:	ab03      	add	r3, sp, #12
 8001a8e:	9300      	str	r3, [sp, #0]
 8001a90:	4640      	mov	r0, r8
 8001a92:	4649      	mov	r1, r9
 8001a94:	463a      	mov	r2, r7
 8001a96:	4653      	mov	r3, sl
 8001a98:	f7ff ff60 	bl	800195c <putchw>
 8001a9c:	e78e      	b.n	80019bc <tfp_format+0xe>
 8001a9e:	2a63      	cmp	r2, #99	; 0x63
 8001aa0:	d105      	bne.n	8001aae <tfp_format+0x100>
 8001aa2:	4635      	mov	r5, r6
 8001aa4:	4640      	mov	r0, r8
 8001aa6:	7821      	ldrb	r1, [r4, #0]
 8001aa8:	1d26      	adds	r6, r4, #4
 8001aaa:	47c8      	blx	r9
 8001aac:	e00c      	b.n	8001ac8 <tfp_format+0x11a>
 8001aae:	d90d      	bls.n	8001acc <tfp_format+0x11e>
 8001ab0:	2a73      	cmp	r2, #115	; 0x73
 8001ab2:	d116      	bne.n	8001ae2 <tfp_format+0x134>
 8001ab4:	4635      	mov	r5, r6
 8001ab6:	6823      	ldr	r3, [r4, #0]
 8001ab8:	4640      	mov	r0, r8
 8001aba:	9300      	str	r3, [sp, #0]
 8001abc:	4649      	mov	r1, r9
 8001abe:	463a      	mov	r2, r7
 8001ac0:	2300      	movs	r3, #0
 8001ac2:	1d26      	adds	r6, r4, #4
 8001ac4:	f7ff ff4a 	bl	800195c <putchw>
 8001ac8:	4634      	mov	r4, r6
 8001aca:	e777      	b.n	80019bc <tfp_format+0xe>
 8001acc:	2a25      	cmp	r2, #37	; 0x25
 8001ace:	d1ce      	bne.n	8001a6e <tfp_format+0xc0>
 8001ad0:	4635      	mov	r5, r6
 8001ad2:	4640      	mov	r0, r8
 8001ad4:	2125      	movs	r1, #37	; 0x25
 8001ad6:	47c8      	blx	r9
 8001ad8:	e770      	b.n	80019bc <tfp_format+0xe>
 8001ada:	2a00      	cmp	r2, #0
 8001adc:	d039      	beq.n	8001b52 <tfp_format+0x1a4>
 8001ade:	4635      	mov	r5, r6
 8001ae0:	e76c      	b.n	80019bc <tfp_format+0xe>
 8001ae2:	d802      	bhi.n	8001aea <tfp_format+0x13c>
 8001ae4:	2a64      	cmp	r2, #100	; 0x64
 8001ae6:	d024      	beq.n	8001b32 <tfp_format+0x184>
 8001ae8:	e7f9      	b.n	8001ade <tfp_format+0x130>
 8001aea:	2a75      	cmp	r2, #117	; 0x75
 8001aec:	d007      	beq.n	8001afe <tfp_format+0x150>
 8001aee:	2a78      	cmp	r2, #120	; 0x78
 8001af0:	d0bf      	beq.n	8001a72 <tfp_format+0xc4>
 8001af2:	e7f4      	b.n	8001ade <tfp_format+0x130>
 8001af4:	1d26      	adds	r6, r4, #4
 8001af6:	6820      	ldr	r0, [r4, #0]
 8001af8:	210a      	movs	r1, #10
 8001afa:	2200      	movs	r2, #0
 8001afc:	e7b2      	b.n	8001a64 <tfp_format+0xb6>
 8001afe:	6820      	ldr	r0, [r4, #0]
 8001b00:	f104 0b04 	add.w	fp, r4, #4
 8001b04:	210a      	movs	r1, #10
 8001b06:	2200      	movs	r2, #0
 8001b08:	ab03      	add	r3, sp, #12
 8001b0a:	f7ff ff00 	bl	800190e <ui2a>
 8001b0e:	4635      	mov	r5, r6
 8001b10:	465c      	mov	r4, fp
 8001b12:	e7bb      	b.n	8001a8c <tfp_format+0xde>
 8001b14:	6820      	ldr	r0, [r4, #0]
 8001b16:	1d26      	adds	r6, r4, #4
 8001b18:	2800      	cmp	r0, #0
 8001b1a:	da08      	bge.n	8001b2e <tfp_format+0x180>
 8001b1c:	232d      	movs	r3, #45	; 0x2d
 8001b1e:	f88d 300c 	strb.w	r3, [sp, #12]
 8001b22:	4240      	negs	r0, r0
 8001b24:	f10d 030d 	add.w	r3, sp, #13
 8001b28:	210a      	movs	r1, #10
 8001b2a:	2200      	movs	r2, #0
 8001b2c:	e79b      	b.n	8001a66 <tfp_format+0xb8>
 8001b2e:	ab03      	add	r3, sp, #12
 8001b30:	e7fa      	b.n	8001b28 <tfp_format+0x17a>
 8001b32:	6820      	ldr	r0, [r4, #0]
 8001b34:	f104 0b04 	add.w	fp, r4, #4
 8001b38:	2800      	cmp	r0, #0
 8001b3a:	da08      	bge.n	8001b4e <tfp_format+0x1a0>
 8001b3c:	232d      	movs	r3, #45	; 0x2d
 8001b3e:	f88d 300c 	strb.w	r3, [sp, #12]
 8001b42:	4240      	negs	r0, r0
 8001b44:	f10d 030d 	add.w	r3, sp, #13
 8001b48:	210a      	movs	r1, #10
 8001b4a:	2200      	movs	r2, #0
 8001b4c:	e7dd      	b.n	8001b0a <tfp_format+0x15c>
 8001b4e:	ab03      	add	r3, sp, #12
 8001b50:	e7fa      	b.n	8001b48 <tfp_format+0x19a>
 8001b52:	b007      	add	sp, #28
 8001b54:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08001b58 <init_printf>:
 8001b58:	4b01      	ldr	r3, [pc, #4]	; (8001b60 <init_printf+0x8>)
 8001b5a:	6019      	str	r1, [r3, #0]
 8001b5c:	6058      	str	r0, [r3, #4]
 8001b5e:	4770      	bx	lr
 8001b60:	20000de4 	.word	0x20000de4

08001b64 <tfp_printf>:
 8001b64:	b40f      	push	{r0, r1, r2, r3}
 8001b66:	b507      	push	{r0, r1, r2, lr}
 8001b68:	4906      	ldr	r1, [pc, #24]	; (8001b84 <tfp_printf+0x20>)
 8001b6a:	ab04      	add	r3, sp, #16
 8001b6c:	f853 2b04 	ldr.w	r2, [r3], #4
 8001b70:	6848      	ldr	r0, [r1, #4]
 8001b72:	6809      	ldr	r1, [r1, #0]
 8001b74:	9301      	str	r3, [sp, #4]
 8001b76:	f7ff ff1a 	bl	80019ae <tfp_format>
 8001b7a:	b003      	add	sp, #12
 8001b7c:	f85d eb04 	ldr.w	lr, [sp], #4
 8001b80:	b004      	add	sp, #16
 8001b82:	4770      	bx	lr
 8001b84:	20000de4 	.word	0x20000de4

08001b88 <tfp_sprintf>:
 8001b88:	b40e      	push	{r1, r2, r3}
 8001b8a:	b50f      	push	{r0, r1, r2, r3, lr}
 8001b8c:	ab05      	add	r3, sp, #20
 8001b8e:	f853 2b04 	ldr.w	r2, [r3], #4
 8001b92:	9001      	str	r0, [sp, #4]
 8001b94:	4906      	ldr	r1, [pc, #24]	; (8001bb0 <tfp_sprintf+0x28>)
 8001b96:	a801      	add	r0, sp, #4
 8001b98:	9303      	str	r3, [sp, #12]
 8001b9a:	f7ff ff08 	bl	80019ae <tfp_format>
 8001b9e:	9b01      	ldr	r3, [sp, #4]
 8001ba0:	2200      	movs	r2, #0
 8001ba2:	701a      	strb	r2, [r3, #0]
 8001ba4:	b004      	add	sp, #16
 8001ba6:	f85d eb04 	ldr.w	lr, [sp], #4
 8001baa:	b003      	add	sp, #12
 8001bac:	4770      	bx	lr
 8001bae:	bf00      	nop
 8001bb0:	080019a5 	.word	0x080019a5

08001bb4 <Reset_Handler>:
 8001bb4:	b508      	push	{r3, lr}
 8001bb6:	4a0a      	ldr	r2, [pc, #40]	; (8001be0 <Reset_Handler+0x2c>)
 8001bb8:	4b0a      	ldr	r3, [pc, #40]	; (8001be4 <Reset_Handler+0x30>)
 8001bba:	490b      	ldr	r1, [pc, #44]	; (8001be8 <Reset_Handler+0x34>)
 8001bbc:	428b      	cmp	r3, r1
 8001bbe:	d204      	bcs.n	8001bca <Reset_Handler+0x16>
 8001bc0:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 8001bc4:	f803 1b01 	strb.w	r1, [r3], #1
 8001bc8:	e7f7      	b.n	8001bba <Reset_Handler+0x6>
 8001bca:	4b08      	ldr	r3, [pc, #32]	; (8001bec <Reset_Handler+0x38>)
 8001bcc:	4a08      	ldr	r2, [pc, #32]	; (8001bf0 <Reset_Handler+0x3c>)
 8001bce:	4293      	cmp	r3, r2
 8001bd0:	d203      	bcs.n	8001bda <Reset_Handler+0x26>
 8001bd2:	2200      	movs	r2, #0
 8001bd4:	f803 2b01 	strb.w	r2, [r3], #1
 8001bd8:	e7f8      	b.n	8001bcc <Reset_Handler+0x18>
 8001bda:	f7fe faf7 	bl	80001cc <main>
 8001bde:	e7fe      	b.n	8001bde <Reset_Handler+0x2a>
 8001be0:	08003f73 	.word	0x08003f73
 8001be4:	20000000 	.word	0x20000000
 8001be8:	20000518 	.word	0x20000518
 8001bec:	20000518 	.word	0x20000518
 8001bf0:	20001658 	.word	0x20001658

08001bf4 <USART1_rxinttxint_init>:
 * @param	: u16 XmtLineSize	- size of each line buffer 		(e.g. 80)
 * @param	: u16 NumberXmtLines	- number of xmt line buffers		(e.g. 2)
 * @return	: 0 = success; 1 = fail malloc; 2 = RcvLineSize zero; 3 = NumberRcvLines = 0; 
 *******************************************************************************/
u16 USART1_rxinttxint_init (u32 BaudRate,u16 RcvLineSize, u16 NumberRcvLines, u16 XmtLineSize, u16 NumberXmtLines)
{
 8001bf4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001bf6:	461e      	mov	r6, r3
	u16 temp;

	/* Setup GPIO pin for GPIO_USART1 tx (PA9) (See Ref manual, page 158) */
	GPIO_CRH(GPIOA) &= ~((0x000f ) << (4*1));	// Clear CNF reset bit 01 = Floating input (reset state)
 8001bf8:	4b1a      	ldr	r3, [pc, #104]	; (8001c64 <USART1_rxinttxint_init+0x70>)
 * @param	: u16 XmtLineSize	- size of each line buffer 		(e.g. 80)
 * @param	: u16 NumberXmtLines	- number of xmt line buffers		(e.g. 2)
 * @return	: 0 = success; 1 = fail malloc; 2 = RcvLineSize zero; 3 = NumberRcvLines = 0; 
 *******************************************************************************/
u16 USART1_rxinttxint_init (u32 BaudRate,u16 RcvLineSize, u16 NumberRcvLines, u16 XmtLineSize, u16 NumberXmtLines)
{
 8001bfa:	4604      	mov	r4, r0
	u16 temp;

	/* Setup GPIO pin for GPIO_USART1 tx (PA9) (See Ref manual, page 158) */
	GPIO_CRH(GPIOA) &= ~((0x000f ) << (4*1));	// Clear CNF reset bit 01 = Floating input (reset state)
 8001bfc:	6818      	ldr	r0, [r3, #0]
 * @param	: u16 XmtLineSize	- size of each line buffer 		(e.g. 80)
 * @param	: u16 NumberXmtLines	- number of xmt line buffers		(e.g. 2)
 * @return	: 0 = success; 1 = fail malloc; 2 = RcvLineSize zero; 3 = NumberRcvLines = 0; 
 *******************************************************************************/
u16 USART1_rxinttxint_init (u32 BaudRate,u16 RcvLineSize, u16 NumberRcvLines, u16 XmtLineSize, u16 NumberXmtLines)
{
 8001bfe:	f8bd 5018 	ldrh.w	r5, [sp, #24]
	u16 temp;

	/* Setup GPIO pin for GPIO_USART1 tx (PA9) (See Ref manual, page 158) */
	GPIO_CRH(GPIOA) &= ~((0x000f ) << (4*1));	// Clear CNF reset bit 01 = Floating input (reset state)
 8001c02:	f020 00f0 	bic.w	r0, r0, #240	; 0xf0
 8001c06:	6018      	str	r0, [r3, #0]
	GPIO_CRH(GPIOA) |=  (( (GPIO_CNF_OUTPUT_ALTFN_PUSHPULL<<2) | (GPIO_MODE_OUTPUT_50_MHZ) ) << (4*1));
 8001c08:	6818      	ldr	r0, [r3, #0]
 8001c0a:	f040 00b0 	orr.w	r0, r0, #176	; 0xb0
 8001c0e:	6018      	str	r0, [r3, #0]
	
	// Enable clock for USART1.
	RCC_APB2ENR |= RCC_APB2ENR_USART1EN;
 8001c10:	4b15      	ldr	r3, [pc, #84]	; (8001c68 <USART1_rxinttxint_init+0x74>)
 8001c12:	6818      	ldr	r0, [r3, #0]
 8001c14:	f440 4080 	orr.w	r0, r0, #16384	; 0x4000
 8001c18:	6018      	str	r0, [r3, #0]

	/* Allocate memory for buffers and setup pointers in control blocks for rcv and xmt */
	/* 'rxint' is the same as for 'rxinttxint'  Just the interrupt routine is different */
	if ( (temp = usartx_rxint_allocatebuffers(RcvLineSize,NumberRcvLines,&pUSARTcbr1)) != 0) return temp;
 8001c1a:	4608      	mov	r0, r1
 8001c1c:	4611      	mov	r1, r2
 8001c1e:	4a13      	ldr	r2, [pc, #76]	; (8001c6c <USART1_rxinttxint_init+0x78>)
 8001c20:	f000 f97a 	bl	8001f18 <usartx_rxint_allocatebuffers>
 8001c24:	4607      	mov	r7, r0
 8001c26:	b9d8      	cbnz	r0, 8001c60 <USART1_rxinttxint_init+0x6c>
	/* 'txdma' uses the same tx buffer setup as 'txint' */
	if ( (temp = usartx_txdma_allocatebuffers(XmtLineSize,NumberXmtLines,&pUSARTcbt1)) != 0) return temp+2;
 8001c28:	4630      	mov	r0, r6
 8001c2a:	4629      	mov	r1, r5
 8001c2c:	4a10      	ldr	r2, [pc, #64]	; (8001c70 <USART1_rxinttxint_init+0x7c>)
 8001c2e:	f000 f8cf 	bl	8001dd0 <usartx_txdma_allocatebuffers>
 8001c32:	4607      	mov	r7, r0
 8001c34:	b110      	cbz	r0, 8001c3c <USART1_rxinttxint_init+0x48>
 8001c36:	1c87      	adds	r7, r0, #2
 8001c38:	b2bf      	uxth	r7, r7
 8001c3a:	e011      	b.n	8001c60 <USART1_rxinttxint_init+0x6c>

	/* Set up usart and baudrate */
	/* 'txcir' sets up the usart Tx the same as needed here */
	usartx_txint_usart_init (USART1,BaudRate);// Tx enable
 8001c3c:	480d      	ldr	r0, [pc, #52]	; (8001c74 <USART1_rxinttxint_init+0x80>)
 8001c3e:	4621      	mov	r1, r4
 8001c40:	f000 fa27 	bl	8002092 <usartx_txint_usart_init>
	/* 'rxint' of course is the same except for the interrup routine */
	usartx_rxint_usart_init (USART1,BaudRate);// Rx enable and enable interrupt
 8001c44:	480b      	ldr	r0, [pc, #44]	; (8001c74 <USART1_rxinttxint_init+0x80>)
 8001c46:	4621      	mov	r1, r4
 8001c48:	f000 f997 	bl	8001f7a <usartx_rxint_usart_init>

	/* Set and enable interrupt controller USART */
	NVICIPR(NVIC_USART1_IRQ, USART_PRIORITY );	// Set interrupt priority
 8001c4c:	4b0a      	ldr	r3, [pc, #40]	; (8001c78 <USART1_rxinttxint_init+0x84>)
 8001c4e:	681a      	ldr	r2, [r3, #0]
 8001c50:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001c54:	601a      	str	r2, [r3, #0]
	NVICISER(NVIC_USART1_IRQ);			// Enable interrupt	
 8001c56:	4b09      	ldr	r3, [pc, #36]	; (8001c7c <USART1_rxinttxint_init+0x88>)
 8001c58:	681a      	ldr	r2, [r3, #0]
 8001c5a:	f042 0220 	orr.w	r2, r2, #32
 8001c5e:	601a      	str	r2, [r3, #0]
	return 0 ;	// Success	
}
 8001c60:	4638      	mov	r0, r7
 8001c62:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001c64:	40010804 	.word	0x40010804
 8001c68:	40021018 	.word	0x40021018
 8001c6c:	20000df0 	.word	0x20000df0
 8001c70:	20000dec 	.word	0x20000dec
 8001c74:	40013800 	.word	0x40013800
 8001c78:	e000e424 	.word	0xe000e424
 8001c7c:	e000e104 	.word	0xe000e104

08001c80 <USART1_IRQHandler>:
/*#######################################################################################
 * ISR routine
 *####################################################################################### */
void USART1_IRQHandler(void)
{
 8001c80:	b538      	push	{r3, r4, r5, lr}
	/* Receive */
	if ( MEM_ADDR(BITBAND(USART1SR,RXFLAG)) != 0)	// Receive register loaded?
 8001c82:	4b14      	ldr	r3, [pc, #80]	; (8001cd4 <USART1_IRQHandler+0x54>)
 8001c84:	681b      	ldr	r3, [r3, #0]
 8001c86:	b143      	cbz	r3, 8001c9a <USART1_IRQHandler+0x1a>
	{  // Here, receive interrupt flag is on. 
		*pUSARTcbr1->prx_now_i = USART_DR(USART1);	// Read and store char
 8001c88:	4b13      	ldr	r3, [pc, #76]	; (8001cd8 <USART1_IRQHandler+0x58>)
 8001c8a:	6819      	ldr	r1, [r3, #0]
 8001c8c:	4b13      	ldr	r3, [pc, #76]	; (8001cdc <USART1_IRQHandler+0x5c>)
 8001c8e:	681a      	ldr	r2, [r3, #0]
 8001c90:	6812      	ldr	r2, [r2, #0]
 8001c92:	7011      	strb	r1, [r2, #0]

		/* Advance pointers to line buffers and array of counts and reset when end reached */	
		usartx_rxint_rxisrptradv(pUSARTcbr1);	// Advance pointers common routine
 8001c94:	6818      	ldr	r0, [r3, #0]
 8001c96:	f000 f99e 	bl	8001fd6 <usartx_rxint_rxisrptradv>
	}

	/* Transmit */
	if (MEM_ADDR(BITBAND(USART1CR1,TXFLAG)) != 0)	// Are Tx interrupts enabled?
 8001c9a:	4c11      	ldr	r4, [pc, #68]	; (8001ce0 <USART1_IRQHandler+0x60>)
 8001c9c:	6823      	ldr	r3, [r4, #0]
 8001c9e:	b1bb      	cbz	r3, 8001cd0 <USART1_IRQHandler+0x50>
	{  // Here, yes.  Transmit interrupts are enabled so check if a tx interrupt
		if (MEM_ADDR(BITBAND(USART1SR,TXFLAG)) != 0)	// Transmit register empty?
 8001ca0:	4b10      	ldr	r3, [pc, #64]	; (8001ce4 <USART1_IRQHandler+0x64>)
 8001ca2:	681b      	ldr	r3, [r3, #0]
 8001ca4:	b1a3      	cbz	r3, 8001cd0 <USART1_IRQHandler+0x50>
		{ // Here, yes.
			USART_DR(USART1) = *pUSARTcbt1->ptx_now_d++;	// Send next char, step pointer
 8001ca6:	4d10      	ldr	r5, [pc, #64]	; (8001ce8 <USART1_IRQHandler+0x68>)
 8001ca8:	4a0b      	ldr	r2, [pc, #44]	; (8001cd8 <USART1_IRQHandler+0x58>)
 8001caa:	6828      	ldr	r0, [r5, #0]
 8001cac:	6883      	ldr	r3, [r0, #8]
 8001cae:	f813 1b01 	ldrb.w	r1, [r3], #1
 8001cb2:	6011      	str	r1, [r2, #0]
			*pUSARTcbt1->ptx_ctary_now_d -= 1;	// Count down number to send in the line buffer
 8001cb4:	69c2      	ldr	r2, [r0, #28]
	/* Transmit */
	if (MEM_ADDR(BITBAND(USART1CR1,TXFLAG)) != 0)	// Are Tx interrupts enabled?
	{  // Here, yes.  Transmit interrupts are enabled so check if a tx interrupt
		if (MEM_ADDR(BITBAND(USART1SR,TXFLAG)) != 0)	// Transmit register empty?
		{ // Here, yes.
			USART_DR(USART1) = *pUSARTcbt1->ptx_now_d++;	// Send next char, step pointer
 8001cb6:	6083      	str	r3, [r0, #8]
			*pUSARTcbt1->ptx_ctary_now_d -= 1;	// Count down number to send in the line buffer
 8001cb8:	8813      	ldrh	r3, [r2, #0]
 8001cba:	3b01      	subs	r3, #1
 8001cbc:	b29b      	uxth	r3, r3
 8001cbe:	8013      	strh	r3, [r2, #0]
			if (*pUSARTcbt1->ptx_ctary_now_d == 0) 
 8001cc0:	b933      	cbnz	r3, 8001cd0 <USART1_IRQHandler+0x50>
			{ // Here, last char to be sent from this line buffer has been loaded into the tx register
				/* Advance pointers to line buffers and array of counts and reset to beginning when end reached */	
				usartx_txisr_advlnptr(pUSARTcbt1);	// Advance pointer for interrupt pointer ('_d)
 8001cc2:	f000 f8e3 	bl	8001e8c <usartx_txisr_advlnptr>
				/* Are we caught up?  Check beginning of line buffer pointers, mainline versus interrupt  */	
//				if (pUSARTcbt1->ptx_begin_d == pUSARTcbt1->ptx_begin_m) // Interrupt versus Mainline pointers
				if (*pUSARTcbt1->ptx_ctary_now_d == 0)	// Is new line buffer ready?
 8001cc6:	682b      	ldr	r3, [r5, #0]
 8001cc8:	69db      	ldr	r3, [r3, #28]
 8001cca:	881b      	ldrh	r3, [r3, #0]
 8001ccc:	b903      	cbnz	r3, 8001cd0 <USART1_IRQHandler+0x50>
				{ // Here, we are caught up with the main (where chars are being added)
					MEM_ADDR(BITBAND(USART1CR1,TXFLAG)) = 0x00;	// Disable Tx interrupts
 8001cce:	6023      	str	r3, [r4, #0]
 8001cd0:	bd38      	pop	{r3, r4, r5, pc}
 8001cd2:	bf00      	nop
 8001cd4:	42270014 	.word	0x42270014
 8001cd8:	40013804 	.word	0x40013804
 8001cdc:	20000df0 	.word	0x20000df0
 8001ce0:	4227019c 	.word	0x4227019c
 8001ce4:	4227001c 	.word	0x4227001c
 8001ce8:	20000dec 	.word	0x20000dec

08001cec <USART1_txint_putc>:
* @brief	: Put char.  Add a char to output buffer
* @param	: Char to be sent
* @return	: 0 = buffer did not overflow; 1 = overflow, chars could be lost
*******************************************************************************/
char USART1_txint_putc(char c)
{
 8001cec:	b510      	push	{r4, lr}
 8001cee:	4604      	mov	r4, r0
	/* If we have filled all the line buffers, then we are screwed and must wait */
	while (USART1_txint_busy() == 1);	// Loop until buffer free
 8001cf0:	f000 f83c 	bl	8001d6c <USART1_txint_busy>
 8001cf4:	2801      	cmp	r0, #1
 8001cf6:	d0fb      	beq.n	8001cf0 <USART1_txint_putc+0x4>

 	*pUSARTcbt1->ptx_now_m++ = c;	// Store a char
 8001cf8:	4a09      	ldr	r2, [pc, #36]	; (8001d20 <USART1_txint_putc+0x34>)
 8001cfa:	6811      	ldr	r1, [r2, #0]
 8001cfc:	680b      	ldr	r3, [r1, #0]
 8001cfe:	f803 4b01 	strb.w	r4, [r3], #1
 8001d02:	600b      	str	r3, [r1, #0]

	/* Are we at the end of the buffer? */
	if (pUSARTcbt1->ptx_now_m >= (pUSARTcbt1->ptx_begin_m + pUSARTcbt1->tx_ln_sz) ) 
 8001d04:	6813      	ldr	r3, [r2, #0]
 8001d06:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
 8001d08:	6859      	ldr	r1, [r3, #4]
 8001d0a:	681b      	ldr	r3, [r3, #0]
 8001d0c:	188a      	adds	r2, r1, r2
 8001d0e:	4293      	cmp	r3, r2
 8001d10:	d303      	bcc.n	8001d1a <USART1_txint_putc+0x2e>
	{ // Here we hit the end of the line buffer, so 
		USART1_txint_send();	// Step to next line buffer
 8001d12:	f000 f81d 	bl	8001d50 <USART1_txint_send>
		return 1;		// Show caller we hit the end
 8001d16:	2001      	movs	r0, #1
 8001d18:	bd10      	pop	{r4, pc}
	}
 	return 0;	
 8001d1a:	2000      	movs	r0, #0
}
 8001d1c:	bd10      	pop	{r4, pc}
 8001d1e:	bf00      	nop
 8001d20:	20000dec 	.word	0x20000dec

08001d24 <USART1_txint_puts>:
* void USART1_txint_puts(char* p);
* @brief	: p: Pointer to zero terminated string
* @return	: 1 = all line buffers filled; 0 = free line buffer(s)
*******************************************************************************/
void USART1_txint_puts(char* p)
{
 8001d24:	b510      	push	{r4, lr}
 8001d26:	4604      	mov	r4, r0
// the DMA then we return the pointer to the mainline and the bozo writing that program can 
// wrestle with the problem of what to do.
	do 
	{
		/* Be sure we don't try to load into a buffer that is being sent, or to be sent */
		while (*(volatile char*)pUSARTcbt1->ptx_ctary_now_m != 0);	// Loop until a buffer is free
 8001d28:	4b08      	ldr	r3, [pc, #32]	; (8001d4c <USART1_txint_puts+0x28>)
 8001d2a:	6819      	ldr	r1, [r3, #0]
 8001d2c:	698b      	ldr	r3, [r1, #24]
 8001d2e:	781a      	ldrb	r2, [r3, #0]
 8001d30:	2a00      	cmp	r2, #0
 8001d32:	d1fc      	bne.n	8001d2e <USART1_txint_puts+0xa>

		/* Move the string into the buffer quickly with this assembly program */
		p = usartx_putsS(p,&pUSARTcbt1->ptx_now_m,(pUSARTcbt1->ptx_begin_m + pUSARTcbt1->tx_ln_sz) );
 8001d34:	8c8b      	ldrh	r3, [r1, #36]	; 0x24
 8001d36:	684a      	ldr	r2, [r1, #4]
 8001d38:	4620      	mov	r0, r4
 8001d3a:	18d2      	adds	r2, r2, r3
 8001d3c:	f000 f820 	bl	8001d80 <usartx_putsS>

		/* Step to the next buffer, and if buffer end was hit, start Tx if not already sending */
		if ( p != 0)
 8001d40:	4604      	mov	r4, r0
 8001d42:	b110      	cbz	r0, 8001d4a <USART1_txint_puts+0x26>
			USART1_txint_send();
 8001d44:	f000 f804 	bl	8001d50 <USART1_txint_send>
 8001d48:	e7ee      	b.n	8001d28 <USART1_txint_puts+0x4>
 8001d4a:	bd10      	pop	{r4, pc}
 8001d4c:	20000dec 	.word	0x20000dec

08001d50 <USART1_txint_send>:
* void USART1_txint_send(void);
* @brief	: Step to next line tx line buffer; if DMA not sending, start it now.
* @return	: none
*******************************************************************************/
void USART1_txint_send(void)
{
 8001d50:	b508      	push	{r3, lr}
	/* Common to all three USARTS */
	if (usartx_txint_send(pUSARTcbt1) != 0) return;
 8001d52:	4b04      	ldr	r3, [pc, #16]	; (8001d64 <USART1_txint_send+0x14>)
 8001d54:	6818      	ldr	r0, [r3, #0]
 8001d56:	f000 f95e 	bl	8002016 <usartx_txint_send>
 8001d5a:	b910      	cbnz	r0, 8001d62 <USART1_txint_send+0x12>
			
	MEM_ADDR(BITBAND(USART1CR1,TXFLAG)) = 0x01;	// Enable Tx interrupts
 8001d5c:	4b02      	ldr	r3, [pc, #8]	; (8001d68 <USART1_txint_send+0x18>)
 8001d5e:	2201      	movs	r2, #1
 8001d60:	601a      	str	r2, [r3, #0]
 8001d62:	bd08      	pop	{r3, pc}
 8001d64:	20000dec 	.word	0x20000dec
 8001d68:	4227019c 	.word	0x4227019c

08001d6c <USART1_txint_busy>:
	   interrupt pointer, then main has filled all the line buffers, so none are free.  If the pointers are
	   the same, but we are not transmitting, then the all the line buffers are free, e.g. the initial
           conditions. 
	*/
//	if (  (MEM_ADDR(BITBAND(USART1CR1,TXFLAG)) == 1) && (pUSARTcbt1->ptx_begin_d == pUSARTcbt1->ptx_begin_m) )
	if (*pUSARTcbt1->ptx_ctary_now_m != 0)
 8001d6c:	4b03      	ldr	r3, [pc, #12]	; (8001d7c <USART1_txint_busy+0x10>)
 8001d6e:	681b      	ldr	r3, [r3, #0]
 8001d70:	699b      	ldr	r3, [r3, #24]
		return 1;	// Show that no line buffers are free
 8001d72:	8818      	ldrh	r0, [r3, #0]
	return 0;		// Show we are good to go.
}
 8001d74:	3800      	subs	r0, #0
 8001d76:	bf18      	it	ne
 8001d78:	2001      	movne	r0, #1
 8001d7a:	4770      	bx	lr
 8001d7c:	20000dec 	.word	0x20000dec

08001d80 <usartx_putsS>:
 8001d80:	b418      	push	{r3, r4}
 8001d82:	680c      	ldr	r4, [r1, #0]

08001d84 <loop>:
 8001d84:	f810 3b01 	ldrb.w	r3, [r0], #1
 8001d88:	b12b      	cbz	r3, 8001d96 <endloop>
 8001d8a:	f804 3b01 	strb.w	r3, [r4], #1
 8001d8e:	4294      	cmp	r4, r2
 8001d90:	d3f8      	bcc.n	8001d84 <loop>
 8001d92:	f014 0f00 	tst.w	r4, #0

08001d96 <endloop>:
 8001d96:	bf18      	it	ne
 8001d98:	2000      	movne	r0, #0
 8001d9a:	600c      	str	r4, [r1, #0]
 8001d9c:	bc18      	pop	{r3, r4}
 8001d9e:	4770      	bx	lr

08001da0 <USART1_txmin_init>:
 *******************************************************************************/
void USART1_txmin_init (u32 BaudRate)
{

	/* Setup GPIO pin for GPIO_USART1 tx (PA9) (See Ref manual, page 158) */
	GPIO_CRH(GPIOA) &= ~((0x000f ) << (4*1));	// Clear CNF reset bit 01 = Floating input (reset state)
 8001da0:	4b08      	ldr	r3, [pc, #32]	; (8001dc4 <USART1_txmin_init+0x24>)
 * void USART1_txmin_init (u32 BaudRate);
 * @brief	: Initializes the USARTx to 8N1 and the baudrate for interrupting receive into line buffers
 * @param	: u32 Baudrate		- baudrate 				(e.g. 115200)
 *******************************************************************************/
void USART1_txmin_init (u32 BaudRate)
{
 8001da2:	4601      	mov	r1, r0

	/* Setup GPIO pin for GPIO_USART1 tx (PA9) (See Ref manual, page 158) */
	GPIO_CRH(GPIOA) &= ~((0x000f ) << (4*1));	// Clear CNF reset bit 01 = Floating input (reset state)
 8001da4:	681a      	ldr	r2, [r3, #0]
	
	// Enable clock for USART1.
	RCC_APB2ENR |= RCC_APB2ENR_USART1EN;

	/* Set up usart and baudrate */
	usartx_txmin_init (USART1,BaudRate);
 8001da6:	4808      	ldr	r0, [pc, #32]	; (8001dc8 <USART1_txmin_init+0x28>)
 *******************************************************************************/
void USART1_txmin_init (u32 BaudRate)
{

	/* Setup GPIO pin for GPIO_USART1 tx (PA9) (See Ref manual, page 158) */
	GPIO_CRH(GPIOA) &= ~((0x000f ) << (4*1));	// Clear CNF reset bit 01 = Floating input (reset state)
 8001da8:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8001dac:	601a      	str	r2, [r3, #0]
	GPIO_CRH(GPIOA) |=  (( (GPIO_CNF_OUTPUT_ALTFN_PUSHPULL<<2) | (GPIO_MODE_OUTPUT_50_MHZ) ) << (4*1));
 8001dae:	681a      	ldr	r2, [r3, #0]
 8001db0:	f042 02b0 	orr.w	r2, r2, #176	; 0xb0
 8001db4:	601a      	str	r2, [r3, #0]
	
	// Enable clock for USART1.
	RCC_APB2ENR |= RCC_APB2ENR_USART1EN;
 8001db6:	4b05      	ldr	r3, [pc, #20]	; (8001dcc <USART1_txmin_init+0x2c>)
 8001db8:	681a      	ldr	r2, [r3, #0]
 8001dba:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001dbe:	601a      	str	r2, [r3, #0]

	/* Set up usart and baudrate */
	usartx_txmin_init (USART1,BaudRate);
 8001dc0:	f000 b9a8 	b.w	8002114 <usartx_txmin_init>
 8001dc4:	40010804 	.word	0x40010804
 8001dc8:	40013800 	.word	0x40013800
 8001dcc:	40021018 	.word	0x40021018

08001dd0 <usartx_txdma_allocatebuffers>:
 * @param	: numberxmtlines is the number of receive line buffers (e.g. 4)
 * @param	: pUSARTcbtx points to pointer in static memory that points to control block
 * @return	: 0 = success;1 = fail mymallocl; 2 = zero xmtlinesize zero; 3 = numberxmtlinesize less than 2
******************************************************************************/
u16 usartx_txdma_allocatebuffers (u16 xmtlinesize,u16 numberxmtlines, struct USARTCBT** pUSARTcbtx)
{
 8001dd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001dd2:	460c      	mov	r4, r1
 8001dd4:	4617      	mov	r7, r2
	u16 i;
	u32* ptr;
	struct USARTCBT* pUSARTcbtl; // Local pointer to control block setup on heap

	/* Zero buffer size would cause trouble */
	if (xmtlinesize == 0 ) return 2;
 8001dd6:	4606      	mov	r6, r0
 8001dd8:	2800      	cmp	r0, #0
 8001dda:	d02f      	beq.n	8001e3c <usartx_txdma_allocatebuffers+0x6c>
	if (numberxmtlines < 2 ) return 3;
 8001ddc:	2901      	cmp	r1, #1
 8001dde:	d92f      	bls.n	8001e40 <usartx_txdma_allocatebuffers+0x70>

	/* Allocate space and set pointer for the struct USARTcbtx */
	ptr = (u32*)mymalloc(sizeof (struct USARTCBT));
 8001de0:	2028      	movs	r0, #40	; 0x28
 8001de2:	f000 f961 	bl	80020a8 <mymalloc>
	if  ( ptr  == 0)  return 1;
 8001de6:	4605      	mov	r5, r0
 8001de8:	2800      	cmp	r0, #0
 8001dea:	d02b      	beq.n	8001e44 <usartx_txdma_allocatebuffers+0x74>
	*pUSARTcbtx = (struct USARTCBT*)ptr;	// Initialize static variable used by others
 8001dec:	6038      	str	r0, [r7, #0]
	 pUSARTcbtl = (struct USARTCBT*)ptr;	

	/* ---------------------------- transmit (dma) buffers and pointers -------------------------- */

	/* Allocate space and set pointer in USARTcbx for transmit line buffers */
	if ( (pUSARTcbtl->ptx_begin = (char*)mymalloc(xmtlinesize * numberxmtlines)) == 0 ) return 1;
 8001dee:	fb06 f704 	mul.w	r7, r6, r4
 8001df2:	b2b8      	uxth	r0, r7
 8001df4:	f000 f958 	bl	80020a8 <mymalloc>
 8001df8:	6128      	str	r0, [r5, #16]
 8001dfa:	2800      	cmp	r0, #0
 8001dfc:	d022      	beq.n	8001e44 <usartx_txdma_allocatebuffers+0x74>

	/* These tx pointers start out on the same line buffer */	
	pUSARTcbtl->ptx_begin_m = pUSARTcbtl->ptx_begin;	// Beginning of line being filled (main)
 8001dfe:	6068      	str	r0, [r5, #4]
	pUSARTcbtl->ptx_begin_d = pUSARTcbtl->ptx_begin;	// Beginning of line being sent (dma)
 8001e00:	60e8      	str	r0, [r5, #12]
	pUSARTcbtl->ptx_now_m   = pUSARTcbtl->ptx_begin;	// Pointer in line being filled (main)
 8001e02:	6028      	str	r0, [r5, #0]
	pUSARTcbtl->ptx_now_d   = pUSARTcbtl->ptx_begin;	// Pointer in line being filled (dma) [not used?]
 8001e04:	60a8      	str	r0, [r5, #8]

	/* Use this for testing for end of line buffers wraparound */
	pUSARTcbtl->ptx_end     = pUSARTcbtl->ptx_begin + (xmtlinesize * numberxmtlines); 
 8001e06:	19c7      	adds	r7, r0, r7

	/* Save number of tx line buffers */
	pUSARTcbtl->tx_ln_ct = numberxmtlines;

	/* Setup an array with the dma transfer count for each tx line buffer */
	if ( (pUSARTcbtl->ptx_ctary_begin = (mymalloc(sizeof(u16) * numberxmtlines))) == 0 ) return 1;
 8001e08:	0063      	lsls	r3, r4, #1
 8001e0a:	f64f 70fe 	movw	r0, #65534	; 0xfffe
	pUSARTcbtl->ptx_begin_d = pUSARTcbtl->ptx_begin;	// Beginning of line being sent (dma)
	pUSARTcbtl->ptx_now_m   = pUSARTcbtl->ptx_begin;	// Pointer in line being filled (main)
	pUSARTcbtl->ptx_now_d   = pUSARTcbtl->ptx_begin;	// Pointer in line being filled (dma) [not used?]

	/* Use this for testing for end of line buffers wraparound */
	pUSARTcbtl->ptx_end     = pUSARTcbtl->ptx_begin + (xmtlinesize * numberxmtlines); 
 8001e0e:	616f      	str	r7, [r5, #20]

	/* Save tx line buffer size */
	pUSARTcbtl->tx_ln_sz = xmtlinesize;
 8001e10:	84ae      	strh	r6, [r5, #36]	; 0x24

	/* Save number of tx line buffers */
	pUSARTcbtl->tx_ln_ct = numberxmtlines;
 8001e12:	84ec      	strh	r4, [r5, #38]	; 0x26

	/* Setup an array with the dma transfer count for each tx line buffer */
	if ( (pUSARTcbtl->ptx_ctary_begin = (mymalloc(sizeof(u16) * numberxmtlines))) == 0 ) return 1;
 8001e14:	ea03 0000 	and.w	r0, r3, r0
 8001e18:	f000 f946 	bl	80020a8 <mymalloc>
 8001e1c:	6228      	str	r0, [r5, #32]
 8001e1e:	b198      	cbz	r0, 8001e48 <usartx_txdma_allocatebuffers+0x78>
	pUSARTcbtl->ptx_ctary_now_m = pUSARTcbtl->ptx_ctary_begin;	// Set working pointer, main
 8001e20:	61a8      	str	r0, [r5, #24]
	pUSARTcbtl->ptx_ctary_now_d = pUSARTcbtl->ptx_ctary_begin;	// Set working pointer, dma
 8001e22:	61e8      	str	r0, [r5, #28]
 8001e24:	4602      	mov	r2, r0

	/* Set set array counts to zero (used in 'int) */
	for (i = 0; i <numberxmtlines; i++)
 8001e26:	2300      	movs	r3, #0
 8001e28:	3301      	adds	r3, #1
 8001e2a:	b29b      	uxth	r3, r3
		*pUSARTcbtl->ptx_ctary_now_m++ = 0;
 8001e2c:	2100      	movs	r1, #0
	if ( (pUSARTcbtl->ptx_ctary_begin = (mymalloc(sizeof(u16) * numberxmtlines))) == 0 ) return 1;
	pUSARTcbtl->ptx_ctary_now_m = pUSARTcbtl->ptx_ctary_begin;	// Set working pointer, main
	pUSARTcbtl->ptx_ctary_now_d = pUSARTcbtl->ptx_ctary_begin;	// Set working pointer, dma

	/* Set set array counts to zero (used in 'int) */
	for (i = 0; i <numberxmtlines; i++)
 8001e2e:	42a3      	cmp	r3, r4
		*pUSARTcbtl->ptx_ctary_now_m++ = 0;
 8001e30:	f822 1b02 	strh.w	r1, [r2], #2
	if ( (pUSARTcbtl->ptx_ctary_begin = (mymalloc(sizeof(u16) * numberxmtlines))) == 0 ) return 1;
	pUSARTcbtl->ptx_ctary_now_m = pUSARTcbtl->ptx_ctary_begin;	// Set working pointer, main
	pUSARTcbtl->ptx_ctary_now_d = pUSARTcbtl->ptx_ctary_begin;	// Set working pointer, dma

	/* Set set array counts to zero (used in 'int) */
	for (i = 0; i <numberxmtlines; i++)
 8001e34:	d1f8      	bne.n	8001e28 <usartx_txdma_allocatebuffers+0x58>
		*pUSARTcbtl->ptx_ctary_now_m++ = 0;
	pUSARTcbtl->ptx_ctary_now_m = pUSARTcbtl->ptx_ctary_begin;	// Set working pointer, main
 8001e36:	61a8      	str	r0, [r5, #24]

	return 0;
 8001e38:	2000      	movs	r0, #0
 8001e3a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	u16 i;
	u32* ptr;
	struct USARTCBT* pUSARTcbtl; // Local pointer to control block setup on heap

	/* Zero buffer size would cause trouble */
	if (xmtlinesize == 0 ) return 2;
 8001e3c:	2002      	movs	r0, #2
 8001e3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (numberxmtlines < 2 ) return 3;
 8001e40:	2003      	movs	r0, #3
 8001e42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	 pUSARTcbtl = (struct USARTCBT*)ptr;	

	/* ---------------------------- transmit (dma) buffers and pointers -------------------------- */

	/* Allocate space and set pointer in USARTcbx for transmit line buffers */
	if ( (pUSARTcbtl->ptx_begin = (char*)mymalloc(xmtlinesize * numberxmtlines)) == 0 ) return 1;
 8001e44:	2001      	movs	r0, #1
 8001e46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	/* Save number of tx line buffers */
	pUSARTcbtl->tx_ln_ct = numberxmtlines;

	/* Setup an array with the dma transfer count for each tx line buffer */
	if ( (pUSARTcbtl->ptx_ctary_begin = (mymalloc(sizeof(u16) * numberxmtlines))) == 0 ) return 1;
 8001e48:	2001      	movs	r0, #1
	for (i = 0; i <numberxmtlines; i++)
		*pUSARTcbtl->ptx_ctary_now_m++ = 0;
	pUSARTcbtl->ptx_ctary_now_m = pUSARTcbtl->ptx_ctary_begin;	// Set working pointer, main

	return 0;
}
 8001e4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08001e4c <usartx_txdma_usart_init>:
 * void usartx_txdma_usart_init (u32 USARTx, u32 BaudRate);
 * @brief	: Setup USART baudrate, Tx for dma
 * @return	: none
******************************************************************************/
void usartx_txdma_usart_init (u32 USARTx, u32 BaudRate)
{
 8001e4c:	b510      	push	{r4, lr}
 8001e4e:	4604      	mov	r4, r0
	/* Set baud rate */
	usartx_setbaud(USARTx,BaudRate);	// Compute divider settings and load BRR
 8001e50:	f000 f93c 	bl	80020cc <usartx_setbaud>

 	/* Setup CR2 ------------------------------------------------------------------- */
	/* After reset CR2 is 0x0000 and this is just fine */

	/* Set up CR1 (page 771) ------------------------------------------------------- */
	USART_CR1(USARTx) |= USART_UE | USART_TX_ENABLE;// Set Usart enable, Transmit enable
 8001e54:	68e3      	ldr	r3, [r4, #12]
 8001e56:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8001e5a:	f043 0308 	orr.w	r3, r3, #8
 8001e5e:	60e3      	str	r3, [r4, #12]
	
	/* Hook up usart tx to dma channel */
	USART_CR3(USARTx) |= USART_DMAT;			// CR3 setup
 8001e60:	6963      	ldr	r3, [r4, #20]
 8001e62:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001e66:	6163      	str	r3, [r4, #20]

	return;	
}
 8001e68:	bd10      	pop	{r4, pc}

08001e6a <usartx_txmain_advlnptr>:
 * @brief	: Advance line buffer pointers for main
******************************************************************************/
void usartx_txmain_advlnptr (struct USARTCBT* pUSARTcbtx)
{
	/* Advance to next line buffer and companion array of char cts */
	pUSARTcbtx->ptx_begin_m     += pUSARTcbtx->tx_ln_sz;	// Line buffer
 8001e6a:	6842      	ldr	r2, [r0, #4]
 8001e6c:	8c83      	ldrh	r3, [r0, #36]	; 0x24
 8001e6e:	18d3      	adds	r3, r2, r3
	pUSARTcbtx->ptx_ctary_now_m += 1;	// Array of char cts
 8001e70:	6982      	ldr	r2, [r0, #24]
 * @brief	: Advance line buffer pointers for main
******************************************************************************/
void usartx_txmain_advlnptr (struct USARTCBT* pUSARTcbtx)
{
	/* Advance to next line buffer and companion array of char cts */
	pUSARTcbtx->ptx_begin_m     += pUSARTcbtx->tx_ln_sz;	// Line buffer
 8001e72:	6043      	str	r3, [r0, #4]
	pUSARTcbtx->ptx_ctary_now_m += 1;	// Array of char cts
 8001e74:	3202      	adds	r2, #2
 8001e76:	6182      	str	r2, [r0, #24]

	/* Check if at the end of all the line buffers */
	if (pUSARTcbtx->ptx_begin_m >= pUSARTcbtx->ptx_end)
 8001e78:	6942      	ldr	r2, [r0, #20]
 8001e7a:	4293      	cmp	r3, r2
 8001e7c:	d303      	bcc.n	8001e86 <usartx_txmain_advlnptr+0x1c>
	{ // Here, end of line buffers, reset pointers to beginning
		pUSARTcbtx->ptx_begin_m     = pUSARTcbtx->ptx_begin;	// Line buffer
 8001e7e:	6903      	ldr	r3, [r0, #16]
 8001e80:	6043      	str	r3, [r0, #4]
		pUSARTcbtx->ptx_ctary_now_m = pUSARTcbtx->ptx_ctary_begin;// Array of char cts
 8001e82:	6a03      	ldr	r3, [r0, #32]
 8001e84:	6183      	str	r3, [r0, #24]
	}
	pUSARTcbtx->ptx_now_m = pUSARTcbtx->ptx_begin_m;		// Set new working-within-line pointer
 8001e86:	6843      	ldr	r3, [r0, #4]
 8001e88:	6003      	str	r3, [r0, #0]

	return;
}
 8001e8a:	4770      	bx	lr

08001e8c <usartx_txisr_advlnptr>:
 * @brief	: Advance line buffer pointers for isr
******************************************************************************/
void usartx_txisr_advlnptr (struct USARTCBT* pUSARTcbtx)
{
	/* Advance to next line buffer and companion array of char cts */
	pUSARTcbtx->ptx_begin_d     += pUSARTcbtx->tx_ln_sz;	// Line buffer
 8001e8c:	68c2      	ldr	r2, [r0, #12]
 8001e8e:	8c83      	ldrh	r3, [r0, #36]	; 0x24
 8001e90:	18d3      	adds	r3, r2, r3
	pUSARTcbtx->ptx_ctary_now_d += 1;		// Array of char cts
 8001e92:	69c2      	ldr	r2, [r0, #28]
 * @brief	: Advance line buffer pointers for isr
******************************************************************************/
void usartx_txisr_advlnptr (struct USARTCBT* pUSARTcbtx)
{
	/* Advance to next line buffer and companion array of char cts */
	pUSARTcbtx->ptx_begin_d     += pUSARTcbtx->tx_ln_sz;	// Line buffer
 8001e94:	60c3      	str	r3, [r0, #12]
	pUSARTcbtx->ptx_ctary_now_d += 1;		// Array of char cts
 8001e96:	3202      	adds	r2, #2
 8001e98:	61c2      	str	r2, [r0, #28]

	/* Check if at the end of all the line buffers */
	if (pUSARTcbtx->ptx_begin_d >= pUSARTcbtx->ptx_end)
 8001e9a:	6942      	ldr	r2, [r0, #20]
 8001e9c:	4293      	cmp	r3, r2
 8001e9e:	d303      	bcc.n	8001ea8 <usartx_txisr_advlnptr+0x1c>
	{ // Here, end of line buffers, reset pointers to beginning
		pUSARTcbtx->ptx_begin_d     = pUSARTcbtx->ptx_begin;	// Line buffer
 8001ea0:	6903      	ldr	r3, [r0, #16]
 8001ea2:	60c3      	str	r3, [r0, #12]
		pUSARTcbtx->ptx_ctary_now_d = pUSARTcbtx->ptx_ctary_begin;// Array of char cts
 8001ea4:	6a03      	ldr	r3, [r0, #32]
 8001ea6:	61c3      	str	r3, [r0, #28]
	}
	pUSARTcbtx->ptx_now_d = pUSARTcbtx->ptx_begin_d;		// Set new working-within-line pointer
 8001ea8:	68c3      	ldr	r3, [r0, #12]
 8001eaa:	6083      	str	r3, [r0, #8]

	return;
}
 8001eac:	4770      	bx	lr
	...

08001eb0 <USART1_rxdma_init>:
control block and the buffers are allocated in the heap area via
mymalloc which is a one-time only allocation, i.e. no 'free' etc. */
struct USARTCBR* pUSARTcbr1;

u16 USART1_rxdma_init (u32 BaudRate,u16 RcvCircularSize, u16 GetLineSize)
{
 8001eb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u16 temp;
	if ( (temp = usartx_rxdma_allocatebuffers(RcvCircularSize, GetLineSize, &pUSARTcbr1)) != 0) return temp;
 8001eb2:	4c13      	ldr	r4, [pc, #76]	; (8001f00 <USART1_rxdma_init+0x50>)
control block and the buffers are allocated in the heap area via
mymalloc which is a one-time only allocation, i.e. no 'free' etc. */
struct USARTCBR* pUSARTcbr1;

u16 USART1_rxdma_init (u32 BaudRate,u16 RcvCircularSize, u16 GetLineSize)
{
 8001eb4:	4606      	mov	r6, r0
 8001eb6:	460d      	mov	r5, r1
	u16 temp;
	if ( (temp = usartx_rxdma_allocatebuffers(RcvCircularSize, GetLineSize, &pUSARTcbr1)) != 0) return temp;
 8001eb8:	4608      	mov	r0, r1
 8001eba:	4611      	mov	r1, r2
 8001ebc:	4622      	mov	r2, r4
 8001ebe:	f000 f934 	bl	800212a <usartx_rxdma_allocatebuffers>
 8001ec2:	4607      	mov	r7, r0
 8001ec4:	b9d0      	cbnz	r0, 8001efc <USART1_rxdma_init+0x4c>
		
	/* ---------------------- DMA and USART hardware setup --------------------- */	
	
	/* Enable clock for USART1. */
	RCC_APB2ENR |= RCC_APB2ENR_USART1EN;
 8001ec6:	4b0f      	ldr	r3, [pc, #60]	; (8001f04 <USART1_rxdma_init+0x54>)

	/* DMA1 is used with all three buffered USART routines */
	RCC_AHBENR |= RCC_AHBENR_DMA1EN;

	/* Setup USART baudrate, rx non-interrupting, and connected to DMA */
	usartx_rxdma_usart_init (USART1, BaudRate);
 8001ec8:	480f      	ldr	r0, [pc, #60]	; (8001f08 <USART1_rxdma_init+0x58>)
	if ( (temp = usartx_rxdma_allocatebuffers(RcvCircularSize, GetLineSize, &pUSARTcbr1)) != 0) return temp;
		
	/* ---------------------- DMA and USART hardware setup --------------------- */	
	
	/* Enable clock for USART1. */
	RCC_APB2ENR |= RCC_APB2ENR_USART1EN;
 8001eca:	681a      	ldr	r2, [r3, #0]

	/* DMA1 is used with all three buffered USART routines */
	RCC_AHBENR |= RCC_AHBENR_DMA1EN;

	/* Setup USART baudrate, rx non-interrupting, and connected to DMA */
	usartx_rxdma_usart_init (USART1, BaudRate);
 8001ecc:	4631      	mov	r1, r6
	if ( (temp = usartx_rxdma_allocatebuffers(RcvCircularSize, GetLineSize, &pUSARTcbr1)) != 0) return temp;
		
	/* ---------------------- DMA and USART hardware setup --------------------- */	
	
	/* Enable clock for USART1. */
	RCC_APB2ENR |= RCC_APB2ENR_USART1EN;
 8001ece:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001ed2:	601a      	str	r2, [r3, #0]

	/* DMA1 is used with all three buffered USART routines */
	RCC_AHBENR |= RCC_AHBENR_DMA1EN;
 8001ed4:	f853 2c04 	ldr.w	r2, [r3, #-4]
 8001ed8:	f042 0201 	orr.w	r2, r2, #1
 8001edc:	f843 2c04 	str.w	r2, [r3, #-4]

	/* Setup USART baudrate, rx non-interrupting, and connected to DMA */
	usartx_rxdma_usart_init (USART1, BaudRate);
 8001ee0:	f000 f94b 	bl	800217a <usartx_rxdma_usart_init>

	/* Setup DMA for usart receive, circular buffering, no interrupts */
	DMA1_CNDTR5 = RcvCircularSize;			// Number of incoming chars before wrap-around
 8001ee4:	4b09      	ldr	r3, [pc, #36]	; (8001f0c <USART1_rxdma_init+0x5c>)
 8001ee6:	601d      	str	r5, [r3, #0]
	DMA1_CMAR5 = (u32)pUSARTcbr1->prx_begin;	// DMA chan 5 memory rx circular buffer start address
 8001ee8:	6823      	ldr	r3, [r4, #0]
 8001eea:	68da      	ldr	r2, [r3, #12]
 8001eec:	4b08      	ldr	r3, [pc, #32]	; (8001f10 <USART1_rxdma_init+0x60>)
 8001eee:	601a      	str	r2, [r3, #0]
	DMA1_CPAR5 = (u32)&USART1_DR;			// DMA chan 5 periperal usart rx address
 8001ef0:	4a08      	ldr	r2, [pc, #32]	; (8001f14 <USART1_rxdma_init+0x64>)
 8001ef2:	f843 2c04 	str.w	r2, [r3, #-4]
	DMA_CCR5(DMA1) = DMA_CCR5_MINC | DMA_CCR5_CIRC | DMA_CCR5_EN;   // Chan 5 Rx Mem increment, Circular, Enable
 8001ef6:	22a1      	movs	r2, #161	; 0xa1
 8001ef8:	f843 2c0c 	str.w	r2, [r3, #-12]

	return 0;	// Return 0 = success!
}
 8001efc:	4638      	mov	r0, r7
 8001efe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001f00:	20000df0 	.word	0x20000df0
 8001f04:	40021018 	.word	0x40021018
 8001f08:	40013800 	.word	0x40013800
 8001f0c:	4002005c 	.word	0x4002005c
 8001f10:	40020064 	.word	0x40020064
 8001f14:	40013804 	.word	0x40013804

08001f18 <usartx_rxint_allocatebuffers>:
 * @param	: numberrcvlines is the number of receive line buffers (e.g. 4)
 * @param	: pUSARTcbrx points to pointer in static memory that points to control block
 * @return	: 0 = success; 1 = fail malloc; 2 = rcvlinesize zero; 3 = numberrcvlines = 0; 
******************************************************************************/
u16 usartx_rxint_allocatebuffers (u16 rcvlinesize, u16 numberrcvlines, struct USARTCBR** pUSARTcbrx)
{
 8001f18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001f1a:	460c      	mov	r4, r1
 8001f1c:	4617      	mov	r7, r2
	u32* ptr;
	struct USARTCBR* pUSARTcbrl; // Local pointer to control block setup on heap

	/* Bomb out just in case buffer size would be zero */
	if (rcvlinesize    == 0) return 2;
 8001f1e:	4606      	mov	r6, r0
 8001f20:	b318      	cbz	r0, 8001f6a <usartx_rxint_allocatebuffers+0x52>
	if (numberrcvlines == 0) return 3;
 8001f22:	b321      	cbz	r1, 8001f6e <usartx_rxint_allocatebuffers+0x56>

	/* Allocate space and set pointer for the struct USARTcbrx */
	ptr = (u32*)mymalloc(sizeof (struct USARTCBR));
 8001f24:	2024      	movs	r0, #36	; 0x24
 8001f26:	f000 f8bf 	bl	80020a8 <mymalloc>
	if  ( ptr  == 0)  return 1;
 8001f2a:	4605      	mov	r5, r0
 8001f2c:	b308      	cbz	r0, 8001f72 <usartx_rxint_allocatebuffers+0x5a>
	*pUSARTcbrx = (struct USARTCBR*)ptr;	// Initialize static variable used by others
 8001f2e:	6038      	str	r0, [r7, #0]
	 pUSARTcbrl = (struct USARTCBR*)ptr;	// Local pointer

	/* ---------------------------- receive buffers and pointers ------------------------------- */
	/* Allocate space and set pointer in USARTcbrx for receive line buffer(s) */
	if ( (pUSARTcbrl->prx_begin = (char*)mymalloc(rcvlinesize * numberrcvlines)) == 0 ) return 1;
 8001f30:	fb06 f704 	mul.w	r7, r6, r4
 8001f34:	b2b8      	uxth	r0, r7
 8001f36:	f000 f8b7 	bl	80020a8 <mymalloc>
 8001f3a:	60e8      	str	r0, [r5, #12]
 8001f3c:	b1c8      	cbz	r0, 8001f72 <usartx_rxint_allocatebuffers+0x5a>

	/* These rx pointers to start out on the same line buffer */	
	pUSARTcbrl->prx_begin_m = pUSARTcbrl->prx_begin;	// Beginning of line (main)
 8001f3e:	6068      	str	r0, [r5, #4]
	pUSARTcbrl->prx_begin_i = pUSARTcbrl->prx_begin;	// Beginning of line being filled (interrupt)
 8001f40:	60a8      	str	r0, [r5, #8]
	pUSARTcbrl->prx_now_i   = pUSARTcbrl->prx_begin;	// Pointer within line being filled (interrupt)
 8001f42:	6028      	str	r0, [r5, #0]

	/* Use this for testing for end of line buffers wraparound */
	pUSARTcbrl->prx_end     = pUSARTcbrl->prx_begin + (rcvlinesize * numberrcvlines); 
 8001f44:	19c7      	adds	r7, r0, r7

	/* Save rx line buffer size */
	pUSARTcbrl->rx_ln_sz = rcvlinesize;

	/* Save number of rx line buffers */
	pUSARTcbrl->rx_ln_ct = numberrcvlines;
 8001f46:	846c      	strh	r4, [r5, #34]	; 0x22

	/* Allocate space and set pointer in USARTcbrx for char count array */
	if ( (pUSARTcbrl->prx_ctary_begin = mymalloc(sizeof(u16) * numberrcvlines)) == 0 ) return 1;
 8001f48:	f64f 70fe 	movw	r0, #65534	; 0xfffe
 8001f4c:	0064      	lsls	r4, r4, #1
	pUSARTcbrl->prx_begin_m = pUSARTcbrl->prx_begin;	// Beginning of line (main)
	pUSARTcbrl->prx_begin_i = pUSARTcbrl->prx_begin;	// Beginning of line being filled (interrupt)
	pUSARTcbrl->prx_now_i   = pUSARTcbrl->prx_begin;	// Pointer within line being filled (interrupt)

	/* Use this for testing for end of line buffers wraparound */
	pUSARTcbrl->prx_end     = pUSARTcbrl->prx_begin + (rcvlinesize * numberrcvlines); 
 8001f4e:	612f      	str	r7, [r5, #16]

	/* Save rx line buffer size */
	pUSARTcbrl->rx_ln_sz = rcvlinesize;
 8001f50:	842e      	strh	r6, [r5, #32]

	/* Save number of rx line buffers */
	pUSARTcbrl->rx_ln_ct = numberrcvlines;

	/* Allocate space and set pointer in USARTcbrx for char count array */
	if ( (pUSARTcbrl->prx_ctary_begin = mymalloc(sizeof(u16) * numberrcvlines)) == 0 ) return 1;
 8001f52:	ea04 0000 	and.w	r0, r4, r0
 8001f56:	f000 f8a7 	bl	80020a8 <mymalloc>
 8001f5a:	61e8      	str	r0, [r5, #28]
 8001f5c:	b158      	cbz	r0, 8001f76 <usartx_rxint_allocatebuffers+0x5e>
	 pUSARTcbrl->prx_ctary_now_m = pUSARTcbrl->prx_ctary_begin; 	// main pointer
	 pUSARTcbrl->prx_ctary_now_i = pUSARTcbrl->prx_ctary_begin; 	// isr pointer
	*pUSARTcbrl->prx_ctary_now_m = 0; 				// Show no chars in initial line buffer
 8001f5e:	2300      	movs	r3, #0
	/* Save number of rx line buffers */
	pUSARTcbrl->rx_ln_ct = numberrcvlines;

	/* Allocate space and set pointer in USARTcbrx for char count array */
	if ( (pUSARTcbrl->prx_ctary_begin = mymalloc(sizeof(u16) * numberrcvlines)) == 0 ) return 1;
	 pUSARTcbrl->prx_ctary_now_m = pUSARTcbrl->prx_ctary_begin; 	// main pointer
 8001f60:	6168      	str	r0, [r5, #20]
	 pUSARTcbrl->prx_ctary_now_i = pUSARTcbrl->prx_ctary_begin; 	// isr pointer
 8001f62:	61a8      	str	r0, [r5, #24]
	*pUSARTcbrl->prx_ctary_now_m = 0; 				// Show no chars in initial line buffer
 8001f64:	8003      	strh	r3, [r0, #0]
	return 0;
 8001f66:	2000      	movs	r0, #0
 8001f68:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
{
	u32* ptr;
	struct USARTCBR* pUSARTcbrl; // Local pointer to control block setup on heap

	/* Bomb out just in case buffer size would be zero */
	if (rcvlinesize    == 0) return 2;
 8001f6a:	2002      	movs	r0, #2
 8001f6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (numberrcvlines == 0) return 3;
 8001f6e:	2003      	movs	r0, #3
 8001f70:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	*pUSARTcbrx = (struct USARTCBR*)ptr;	// Initialize static variable used by others
	 pUSARTcbrl = (struct USARTCBR*)ptr;	// Local pointer

	/* ---------------------------- receive buffers and pointers ------------------------------- */
	/* Allocate space and set pointer in USARTcbrx for receive line buffer(s) */
	if ( (pUSARTcbrl->prx_begin = (char*)mymalloc(rcvlinesize * numberrcvlines)) == 0 ) return 1;
 8001f72:	2001      	movs	r0, #1
 8001f74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	/* Save number of rx line buffers */
	pUSARTcbrl->rx_ln_ct = numberrcvlines;

	/* Allocate space and set pointer in USARTcbrx for char count array */
	if ( (pUSARTcbrl->prx_ctary_begin = mymalloc(sizeof(u16) * numberrcvlines)) == 0 ) return 1;
 8001f76:	2001      	movs	r0, #1
	 pUSARTcbrl->prx_ctary_now_m = pUSARTcbrl->prx_ctary_begin; 	// main pointer
	 pUSARTcbrl->prx_ctary_now_i = pUSARTcbrl->prx_ctary_begin; 	// isr pointer
	*pUSARTcbrl->prx_ctary_now_m = 0; 				// Show no chars in initial line buffer
	return 0;
}
 8001f78:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08001f7a <usartx_rxint_usart_init>:
 * @brief	: Setup USART baudrate, Rx interrupting with line buffers
 * @param	: USARTx = USART1, USART2, or USART3 base address
 * @param	: u32 BaudRate is the baud rate.
******************************************************************************/
void usartx_rxint_usart_init (u32 USARTx, u32 BaudRate)
{
 8001f7a:	b510      	push	{r4, lr}
 8001f7c:	4604      	mov	r4, r0
	/* Set baud rate */
	usartx_setbaud (USARTx,BaudRate);	// Compute divider settings and load BRR
 8001f7e:	f000 f8a5 	bl	80020cc <usartx_setbaud>

 	/* Setup CR2 ------------------------------------------------------------------- */
	/* After reset CR2 is 0x0000 and this is just fine */
	/* Set up CR1 (page 771) ------------------------------------------------------- */
	USART_CR1(USARTx) |= USART_UE | USART_RXNE_INTERRUPT_ENABLE | USART_RX_ENABLE;// Set UE, RNEIE, RE 
 8001f82:	68e3      	ldr	r3, [r4, #12]
 8001f84:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8001f88:	f043 0324 	orr.w	r3, r3, #36	; 0x24
 8001f8c:	60e3      	str	r3, [r4, #12]

	return;	
}
 8001f8e:	bd10      	pop	{r4, pc}

08001f90 <usartx_rxint_rxmainadvptr>:
char* usartx_rxint_rxmainadvptr (struct USARTCBR* pUSARTcbrx)
{
	char* p;	// Temp 

	/* If no chars, then we are caught up with incoming lines */
	if (*pUSARTcbrx->prx_ctary_now_m == 0) return 0;
 8001f90:	6941      	ldr	r1, [r0, #20]
 * @brief	: Advance pointers for mainline
 * @param	: Receive control block
 * @return	: 0 = caught up, not zero = pointer to completed line buffer
******************************************************************************/
char* usartx_rxint_rxmainadvptr (struct USARTCBR* pUSARTcbrx)
{
 8001f92:	4603      	mov	r3, r0
	char* p;	// Temp 

	/* If no chars, then we are caught up with incoming lines */
	if (*pUSARTcbrx->prx_ctary_now_m == 0) return 0;
 8001f94:	8808      	ldrh	r0, [r1, #0]
 8001f96:	b160      	cbz	r0, 8001fb2 <usartx_rxint_rxmainadvptr+0x22>
	
	p = pUSARTcbrx->prx_begin_m;		// Save pointer for later return

	/* Advance to next line buffer and companion array of char cts */
	pUSARTcbrx->prx_begin_m     += pUSARTcbrx->rx_ln_sz;	// Line buffer
	pUSARTcbrx->prx_ctary_now_m += 1;	// Array of char cts
 8001f98:	3102      	adds	r1, #2
	char* p;	// Temp 

	/* If no chars, then we are caught up with incoming lines */
	if (*pUSARTcbrx->prx_ctary_now_m == 0) return 0;
	
	p = pUSARTcbrx->prx_begin_m;		// Save pointer for later return
 8001f9a:	6858      	ldr	r0, [r3, #4]

	/* Advance to next line buffer and companion array of char cts */
	pUSARTcbrx->prx_begin_m     += pUSARTcbrx->rx_ln_sz;	// Line buffer
 8001f9c:	8c1a      	ldrh	r2, [r3, #32]
	pUSARTcbrx->prx_ctary_now_m += 1;	// Array of char cts
 8001f9e:	6159      	str	r1, [r3, #20]

	/* Check if at the end of all the line buffers */
	if (pUSARTcbrx->prx_begin_m >= pUSARTcbrx->prx_end)
 8001fa0:	6919      	ldr	r1, [r3, #16]
	if (*pUSARTcbrx->prx_ctary_now_m == 0) return 0;
	
	p = pUSARTcbrx->prx_begin_m;		// Save pointer for later return

	/* Advance to next line buffer and companion array of char cts */
	pUSARTcbrx->prx_begin_m     += pUSARTcbrx->rx_ln_sz;	// Line buffer
 8001fa2:	1882      	adds	r2, r0, r2
	pUSARTcbrx->prx_ctary_now_m += 1;	// Array of char cts

	/* Check if at the end of all the line buffers */
	if (pUSARTcbrx->prx_begin_m >= pUSARTcbrx->prx_end)
 8001fa4:	428a      	cmp	r2, r1
	if (*pUSARTcbrx->prx_ctary_now_m == 0) return 0;
	
	p = pUSARTcbrx->prx_begin_m;		// Save pointer for later return

	/* Advance to next line buffer and companion array of char cts */
	pUSARTcbrx->prx_begin_m     += pUSARTcbrx->rx_ln_sz;	// Line buffer
 8001fa6:	605a      	str	r2, [r3, #4]
	pUSARTcbrx->prx_ctary_now_m += 1;	// Array of char cts

	/* Check if at the end of all the line buffers */
	if (pUSARTcbrx->prx_begin_m >= pUSARTcbrx->prx_end)
 8001fa8:	d303      	bcc.n	8001fb2 <usartx_rxint_rxmainadvptr+0x22>
	{ // Here, end of line buffers, reset pointers to beginning
		pUSARTcbrx->prx_begin_m     = pUSARTcbrx->prx_begin;	// Line buffer
 8001faa:	68da      	ldr	r2, [r3, #12]
 8001fac:	605a      	str	r2, [r3, #4]
		pUSARTcbrx->prx_ctary_now_m = pUSARTcbrx->prx_ctary_begin;// Array of char cts
 8001fae:	69da      	ldr	r2, [r3, #28]
 8001fb0:	615a      	str	r2, [r3, #20]
	}
	return p;
}
 8001fb2:	4770      	bx	lr

08001fb4 <usartx_rxint_rxisrptradv2>:
 * void usartx_rxint_rxisrptradv2 (struct USARTCBR* pUSARTcbrx);
 * @brief	: Step pointers to next line buffer for rx isr routine
******************************************************************************/
void usartx_rxint_rxisrptradv2 (struct USARTCBR* pUSARTcbrx)
{
	pUSARTcbrx->prx_ctary_now_i += 1;			// Step to next char ct arrary position
 8001fb4:	6983      	ldr	r3, [r0, #24]
	pUSARTcbrx->prx_begin_i     += pUSARTcbrx->rx_ln_sz;	// Step to next line buffer beginning
 8001fb6:	6882      	ldr	r2, [r0, #8]
 * void usartx_rxint_rxisrptradv2 (struct USARTCBR* pUSARTcbrx);
 * @brief	: Step pointers to next line buffer for rx isr routine
******************************************************************************/
void usartx_rxint_rxisrptradv2 (struct USARTCBR* pUSARTcbrx)
{
	pUSARTcbrx->prx_ctary_now_i += 1;			// Step to next char ct arrary position
 8001fb8:	3302      	adds	r3, #2
 8001fba:	6183      	str	r3, [r0, #24]
	pUSARTcbrx->prx_begin_i     += pUSARTcbrx->rx_ln_sz;	// Step to next line buffer beginning
 8001fbc:	8c03      	ldrh	r3, [r0, #32]
 8001fbe:	18d3      	adds	r3, r2, r3
	if (pUSARTcbrx->prx_begin_i >= pUSARTcbrx->prx_end)	// Are we at end of the line buffers?
 8001fc0:	6902      	ldr	r2, [r0, #16]
 * @brief	: Step pointers to next line buffer for rx isr routine
******************************************************************************/
void usartx_rxint_rxisrptradv2 (struct USARTCBR* pUSARTcbrx)
{
	pUSARTcbrx->prx_ctary_now_i += 1;			// Step to next char ct arrary position
	pUSARTcbrx->prx_begin_i     += pUSARTcbrx->rx_ln_sz;	// Step to next line buffer beginning
 8001fc2:	6083      	str	r3, [r0, #8]
	if (pUSARTcbrx->prx_begin_i >= pUSARTcbrx->prx_end)	// Are we at end of the line buffers?
 8001fc4:	4293      	cmp	r3, r2
 8001fc6:	d303      	bcc.n	8001fd0 <usartx_rxint_rxisrptradv2+0x1c>
	{ // Here, yes.  Reset pointers to beginning
		pUSARTcbrx->prx_ctary_now_i  = pUSARTcbrx->prx_ctary_begin;
 8001fc8:	69c3      	ldr	r3, [r0, #28]
 8001fca:	6183      	str	r3, [r0, #24]
		pUSARTcbrx->prx_begin_i      = pUSARTcbrx->prx_begin;			
 8001fcc:	68c3      	ldr	r3, [r0, #12]
 8001fce:	6083      	str	r3, [r0, #8]
	}
	pUSARTcbrx->prx_now_i = pUSARTcbrx->prx_begin_i;	// Set working pointer.
 8001fd0:	6883      	ldr	r3, [r0, #8]
 8001fd2:	6003      	str	r3, [r0, #0]
	return;
}
 8001fd4:	4770      	bx	lr

08001fd6 <usartx_rxint_rxisrptradv>:
/******************************************************************************
 * void usartx_rxint_rxisrptradv (struct USARTCBR* pUSARTcbrx);
 * @brief	: Check for EOL, advance pointers for rx isr routine
******************************************************************************/
void usartx_rxint_rxisrptradv (struct USARTCBR* pUSARTcbrx)
{	
 8001fd6:	b530      	push	{r4, r5, lr}
	/* Was the char just stored an END_OF_LINE? */
	if ( *pUSARTcbrx->prx_now_i++ == END_OF_LINE)	// Check for end of line, step to next location
 8001fd8:	6804      	ldr	r4, [r0, #0]
/******************************************************************************
 * void usartx_rxint_rxisrptradv (struct USARTCBR* pUSARTcbrx);
 * @brief	: Check for EOL, advance pointers for rx isr routine
******************************************************************************/
void usartx_rxint_rxisrptradv (struct USARTCBR* pUSARTcbrx)
{	
 8001fda:	4603      	mov	r3, r0
	/* Was the char just stored an END_OF_LINE? */
	if ( *pUSARTcbrx->prx_now_i++ == END_OF_LINE)	// Check for end of line, step to next location
 8001fdc:	4622      	mov	r2, r4
 8001fde:	f812 1b01 	ldrb.w	r1, [r2], #1
 8001fe2:	290d      	cmp	r1, #13
 8001fe4:	6002      	str	r2, [r0, #0]
 8001fe6:	6881      	ldr	r1, [r0, #8]
 8001fe8:	d10a      	bne.n	8002000 <usartx_rxint_rxisrptradv+0x2a>
	{ // Here, EOL, so move to next line buffer.
		/* Store number of chars in line just completed */
		*pUSARTcbrx->prx_ctary_now_i = (pUSARTcbrx->prx_now_i - pUSARTcbrx->prx_begin_i);
 8001fea:	6980      	ldr	r0, [r0, #24]
 8001fec:	1a55      	subs	r5, r2, r1
 8001fee:	8005      	strh	r5, [r0, #0]
		/* Check if space to store zero string terminator */
		if (pUSARTcbrx->prx_now_i < (pUSARTcbrx->prx_begin_i + pUSARTcbrx->rx_ln_sz) )
 8001ff0:	8c18      	ldrh	r0, [r3, #32]
 8001ff2:	1809      	adds	r1, r1, r0
 8001ff4:	428a      	cmp	r2, r1
 8001ff6:	d201      	bcs.n	8001ffc <usartx_rxint_rxisrptradv+0x26>
		{ // Here, there is room for the zero
			*pUSARTcbrx->prx_now_i = 0; 	// Add zero for the string terminator			
 8001ff8:	2200      	movs	r2, #0
 8001ffa:	7062      	strb	r2, [r4, #1]
		}
		/* Step to next line buffer */
		usartx_rxint_rxisrptradv2 (pUSARTcbrx);
 8001ffc:	4618      	mov	r0, r3
 8001ffe:	e006      	b.n	800200e <usartx_rxint_rxisrptradv+0x38>
	}
	else
	{ // Here, not EOL, so check if we are at end of the current line buffer.
		if (pUSARTcbrx->prx_now_i >= (pUSARTcbrx->prx_begin_i + pUSARTcbrx->rx_ln_sz) )
 8002000:	8c04      	ldrh	r4, [r0, #32]
 8002002:	190c      	adds	r4, r1, r4
 8002004:	42a2      	cmp	r2, r4
 8002006:	d305      	bcc.n	8002014 <usartx_rxint_rxisrptradv+0x3e>
		{ // Here, we at end, so step to next line buffer
			/* Store number of chars in line just completed */
			*pUSARTcbrx->prx_ctary_now_i = (pUSARTcbrx->prx_now_i - pUSARTcbrx->prx_begin_i);
 8002008:	6983      	ldr	r3, [r0, #24]
 800200a:	1a52      	subs	r2, r2, r1
 800200c:	801a      	strh	r2, [r3, #0]
			usartx_rxint_rxisrptradv2 (pUSARTcbrx);
		}
	}
	return;
}
 800200e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	{ // Here, not EOL, so check if we are at end of the current line buffer.
		if (pUSARTcbrx->prx_now_i >= (pUSARTcbrx->prx_begin_i + pUSARTcbrx->rx_ln_sz) )
		{ // Here, we at end, so step to next line buffer
			/* Store number of chars in line just completed */
			*pUSARTcbrx->prx_ctary_now_i = (pUSARTcbrx->prx_now_i - pUSARTcbrx->prx_begin_i);
			usartx_rxint_rxisrptradv2 (pUSARTcbrx);
 8002012:	e7cf      	b.n	8001fb4 <usartx_rxint_rxisrptradv2>
 8002014:	bd30      	pop	{r4, r5, pc}

08002016 <usartx_txint_send>:
*******************************************************************************/
char usartx_txint_send(struct USARTCBT* pUSARTcbtx)
{

	/* Compute number of chars to send */ 
 	u16 temp = (pUSARTcbtx->ptx_now_m - pUSARTcbtx->ptx_begin_m);
 8002016:	6801      	ldr	r1, [r0, #0]
 8002018:	6842      	ldr	r2, [r0, #4]
* @brief	: Step to next line tx line buffer; if USART not sending, start it now.
* @param	: pUSARTcbtx	Pointer to struct--pUSARTcbid1,2,3
** @return	: 0 = OK; 1 = NG
*******************************************************************************/
char usartx_txint_send(struct USARTCBT* pUSARTcbtx)
{
 800201a:	b508      	push	{r3, lr}

	/* Compute number of chars to send */ 
 	u16 temp = (pUSARTcbtx->ptx_now_m - pUSARTcbtx->ptx_begin_m);
 800201c:	1a8a      	subs	r2, r1, r2
 800201e:	b292      	uxth	r2, r2

	/* A zero count would cause 65536 chars to sent, i.e. a full wrap around */
	/* So, zero would mean a bogus 'send' call was issued */
	if ( temp == 0 ) return 1; // Show no chars to send
 8002020:	b12a      	cbz	r2, 800202e <usartx_txint_send+0x18>
			
	/* Place count in array that holds the counts */
	*pUSARTcbtx->ptx_ctary_now_m = temp;	
 8002022:	6983      	ldr	r3, [r0, #24]
 8002024:	801a      	strh	r2, [r3, #0]

	/* Advance to next line buffer for 'main' pointer */
	usartx_txmain_advlnptr (pUSARTcbtx);
 8002026:	f7ff ff20 	bl	8001e6a <usartx_txmain_advlnptr>

	return 0; // Show chars were sent
 800202a:	2000      	movs	r0, #0
 800202c:	bd08      	pop	{r3, pc}
	/* Compute number of chars to send */ 
 	u16 temp = (pUSARTcbtx->ptx_now_m - pUSARTcbtx->ptx_begin_m);

	/* A zero count would cause 65536 chars to sent, i.e. a full wrap around */
	/* So, zero would mean a bogus 'send' call was issued */
	if ( temp == 0 ) return 1; // Show no chars to send
 800202e:	2001      	movs	r0, #1

	/* Advance to next line buffer for 'main' pointer */
	usartx_txmain_advlnptr (pUSARTcbtx);

	return 0; // Show chars were sent
}
 8002030:	bd08      	pop	{r3, pc}

08002032 <usartx_txint_allocatebuffers>:
 * @param	: numberxmtlines is the number of receive line buffers (e.g. 4)
 * @param	: pUSARTcbtx points to pointer in static memory that points to control block
 * @return	: 0 = success; 1 = fail malloc; 2 = rcvlinesize zero; 3 = numberrcvlines = 0; 
******************************************************************************/
u16 usartx_txint_allocatebuffers (u16 xmtlinesize,u16 numberxmtlines, struct USARTCBT** pUSARTcbtx)
{
 8002032:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002034:	460c      	mov	r4, r1
 8002036:	4617      	mov	r7, r2
	u32* ptr;
	struct USARTCBT* pUSARTcbtl; // Local pointer to control block setup on heap

	/* Bomb out just in case buffer size would be zero */
	if (xmtlinesize    == 0) return 2;
 8002038:	4606      	mov	r6, r0
 800203a:	b310      	cbz	r0, 8002082 <usartx_txint_allocatebuffers+0x50>
	if (numberxmtlines == 0) return 3;
 800203c:	b319      	cbz	r1, 8002086 <usartx_txint_allocatebuffers+0x54>

	/* Allocate space and set pointer for the struct USARTcbtx */
	ptr = (u32*)mymalloc(sizeof (struct USARTCBT));
 800203e:	2028      	movs	r0, #40	; 0x28
 8002040:	f000 f832 	bl	80020a8 <mymalloc>
	if  ( ptr  == 0)  return 1;
 8002044:	4605      	mov	r5, r0
 8002046:	b300      	cbz	r0, 800208a <usartx_txint_allocatebuffers+0x58>
	*pUSARTcbtx = (struct USARTCBT*)ptr;	// Initialize static variable used by others
 8002048:	6038      	str	r0, [r7, #0]
	 pUSARTcbtl = (struct USARTCBT*)ptr;	

	/* ---------------------------- transmit (dma) buffers and pointers -------------------------- */

	/* Allocate space and set pointer in USARTcbx for transmit line buffer(s) */
	if ( (pUSARTcbtl->ptx_begin = (char*)mymalloc(xmtlinesize * numberxmtlines)) == 0 ) return 1;
 800204a:	fb06 f704 	mul.w	r7, r6, r4
 800204e:	b2b8      	uxth	r0, r7
 8002050:	f000 f82a 	bl	80020a8 <mymalloc>
 8002054:	6128      	str	r0, [r5, #16]
 8002056:	b1c0      	cbz	r0, 800208a <usartx_txint_allocatebuffers+0x58>

	/* These tx pointers start out on the same line buffer */	
	pUSARTcbtl->ptx_begin_m = pUSARTcbtl->ptx_begin;	// Beginning of line being filled (main)
 8002058:	6068      	str	r0, [r5, #4]
	pUSARTcbtl->ptx_begin_d = pUSARTcbtl->ptx_begin;	// Beginning of line being sent (int)
 800205a:	60e8      	str	r0, [r5, #12]
	pUSARTcbtl->ptx_now_m   = pUSARTcbtl->ptx_begin;	// Pointer in line being filled (main)
 800205c:	6028      	str	r0, [r5, #0]
	pUSARTcbtl->ptx_now_d   = pUSARTcbtl->ptx_begin;	// Pointer in line being filled (int)
 800205e:	60a8      	str	r0, [r5, #8]

	/* Use this for testing for end of line buffers wraparound */
	pUSARTcbtl->ptx_end     = pUSARTcbtl->ptx_begin + (xmtlinesize * numberxmtlines); 
 8002060:	19c7      	adds	r7, r0, r7

	/* Save tx line buffer size */
	pUSARTcbtl->tx_ln_sz = xmtlinesize;

	/* Save number of tx line buffers */
	pUSARTcbtl->tx_ln_ct = numberxmtlines;
 8002062:	84ec      	strh	r4, [r5, #38]	; 0x26

	/* Setup an array with the line buffer transfer count for each tx line buffer */
	if ( (pUSARTcbtl->ptx_ctary_begin = mymalloc(sizeof(u16) * numberxmtlines)) == 0 ) return 1;
 8002064:	f64f 70fe 	movw	r0, #65534	; 0xfffe
 8002068:	0064      	lsls	r4, r4, #1
	pUSARTcbtl->ptx_begin_d = pUSARTcbtl->ptx_begin;	// Beginning of line being sent (int)
	pUSARTcbtl->ptx_now_m   = pUSARTcbtl->ptx_begin;	// Pointer in line being filled (main)
	pUSARTcbtl->ptx_now_d   = pUSARTcbtl->ptx_begin;	// Pointer in line being filled (int)

	/* Use this for testing for end of line buffers wraparound */
	pUSARTcbtl->ptx_end     = pUSARTcbtl->ptx_begin + (xmtlinesize * numberxmtlines); 
 800206a:	616f      	str	r7, [r5, #20]

	/* Save tx line buffer size */
	pUSARTcbtl->tx_ln_sz = xmtlinesize;
 800206c:	84ae      	strh	r6, [r5, #36]	; 0x24

	/* Save number of tx line buffers */
	pUSARTcbtl->tx_ln_ct = numberxmtlines;

	/* Setup an array with the line buffer transfer count for each tx line buffer */
	if ( (pUSARTcbtl->ptx_ctary_begin = mymalloc(sizeof(u16) * numberxmtlines)) == 0 ) return 1;
 800206e:	ea04 0000 	and.w	r0, r4, r0
 8002072:	f000 f819 	bl	80020a8 <mymalloc>
 8002076:	6228      	str	r0, [r5, #32]
 8002078:	b148      	cbz	r0, 800208e <usartx_txint_allocatebuffers+0x5c>
	pUSARTcbtl->ptx_ctary_now_m = pUSARTcbtl->ptx_ctary_begin;	// Set working pointer, (main)
 800207a:	61a8      	str	r0, [r5, #24]
	pUSARTcbtl->ptx_ctary_now_d = pUSARTcbtl->ptx_ctary_begin;	// Set working pointer, (int)
 800207c:	61e8      	str	r0, [r5, #28]

	return 0;
 800207e:	2000      	movs	r0, #0
 8002080:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
{
	u32* ptr;
	struct USARTCBT* pUSARTcbtl; // Local pointer to control block setup on heap

	/* Bomb out just in case buffer size would be zero */
	if (xmtlinesize    == 0) return 2;
 8002082:	2002      	movs	r0, #2
 8002084:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (numberxmtlines == 0) return 3;
 8002086:	2003      	movs	r0, #3
 8002088:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	 pUSARTcbtl = (struct USARTCBT*)ptr;	

	/* ---------------------------- transmit (dma) buffers and pointers -------------------------- */

	/* Allocate space and set pointer in USARTcbx for transmit line buffer(s) */
	if ( (pUSARTcbtl->ptx_begin = (char*)mymalloc(xmtlinesize * numberxmtlines)) == 0 ) return 1;
 800208a:	2001      	movs	r0, #1
 800208c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	/* Save number of tx line buffers */
	pUSARTcbtl->tx_ln_ct = numberxmtlines;

	/* Setup an array with the line buffer transfer count for each tx line buffer */
	if ( (pUSARTcbtl->ptx_ctary_begin = mymalloc(sizeof(u16) * numberxmtlines)) == 0 ) return 1;
 800208e:	2001      	movs	r0, #1
	pUSARTcbtl->ptx_ctary_now_m = pUSARTcbtl->ptx_ctary_begin;	// Set working pointer, (main)
	pUSARTcbtl->ptx_ctary_now_d = pUSARTcbtl->ptx_ctary_begin;	// Set working pointer, (int)

	return 0;
}
 8002090:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08002092 <usartx_txint_usart_init>:
/******************************************************************************
 * void usartx_txint_usart_init (u32 USARTx, u32 BaudRate);
 * @brief	: Setup USART baudrate, Tx for dma
******************************************************************************/
void usartx_txint_usart_init (u32 USARTx, u32 BaudRate)
{
 8002092:	b510      	push	{r4, lr}
 8002094:	4604      	mov	r4, r0
	/* Set baud rate */
	usartx_setbaud (USARTx,BaudRate);	// Compute divider settings and load BRR
 8002096:	f000 f819 	bl	80020cc <usartx_setbaud>

 	/* Setup CR2 ------------------------------------------------------------------- */
	/* After reset CR2 is 0x0000 and this is just fine */
	/* Set up CR1 (page 771) ------------------------------------------------------- */
	USART_CR1(USARTx) |= USART_UE | USART_TX_ENABLE;// Set UE, TE
 800209a:	68e3      	ldr	r3, [r4, #12]
 800209c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80020a0:	f043 0308 	orr.w	r3, r3, #8
 80020a4:	60e3      	str	r3, [r4, #12]
	// Note Tx interrupt enable is set when there is data ready to be sent		

	return;	
}
 80020a6:	bd10      	pop	{r4, pc}

080020a8 <mymalloc>:

void* mymalloc(u16 size)
{
	unsigned char* prev_heap = myheap;

	prev_heap = myheap;
 80020a8:	4a06      	ldr	r2, [pc, #24]	; (80020c4 <mymalloc+0x1c>)
 80020aa:	6813      	ldr	r3, [r2, #0]
	myheap += size;
 80020ac:	1819      	adds	r1, r3, r0
	
	myheap += 3;
 80020ae:	3103      	adds	r1, #3
// $	if (myheap >= &_MYHEAP_END)		// Are we out of space?
	if (myheap >= (&myheapblock[0] + MYHEAPBLOCKSIZE))	// Are we out of space?
		return 0;		// Here, yes.  Return zero (null)  

	return prev_heap;		// Return pointer to beginning of block
}
 80020b0:	4805      	ldr	r0, [pc, #20]	; (80020c8 <mymalloc+0x20>)

	prev_heap = myheap;
	myheap += size;
	
	myheap += 3;
	myheap = (unsigned char*)((u32)myheap & ~0x03);	// Round upwards to align to full words
 80020b2:	f021 0103 	bic.w	r1, r1, #3
 80020b6:	6011      	str	r1, [r2, #0]
// $	if (myheap >= &_MYHEAP_END)		// Are we out of space?
	if (myheap >= (&myheapblock[0] + MYHEAPBLOCKSIZE))	// Are we out of space?
		return 0;		// Here, yes.  Return zero (null)  

	return prev_heap;		// Return pointer to beginning of block
}
 80020b8:	4281      	cmp	r1, r0
 80020ba:	bf34      	ite	cc
 80020bc:	4618      	movcc	r0, r3
 80020be:	2000      	movcs	r0, #0
 80020c0:	4770      	bx	lr
 80020c2:	bf00      	nop
 80020c4:	2000050c 	.word	0x2000050c
 80020c8:	200015f4 	.word	0x200015f4

080020cc <usartx_setbaud>:
	u32 tmpreg = 0x00;
	u32 fractionaldivider = 0x00;
	u32 integerdivider = 0x00;

	/* USART1 is driven from a different clock, than USART2,3 */
	if ( usartx == USART1_BASE)	// Are doing USART1?
 80020cc:	4b0e      	ldr	r3, [pc, #56]	; (8002108 <usartx_setbaud+0x3c>)
 * void usartx_setbaud (u32 usartx, u32 u32BaudRate);
 * @brief	: set baudrate register (BRR)
 * @param	: u32BaudRate is the baud rate.
******************************************************************************/
void usartx_setbaud (u32 usartx, u32 u32BaudRate)
{
 80020ce:	b510      	push	{r4, lr}
	u32 tmpreg = 0x00;
	u32 fractionaldivider = 0x00;
	u32 integerdivider = 0x00;

	/* USART1 is driven from a different clock, than USART2,3 */
	if ( usartx == USART1_BASE)	// Are doing USART1?
 80020d0:	4298      	cmp	r0, r3
	{  // Here, yes.
		apbclock = pclk2_freq;
 80020d2:	bf0c      	ite	eq
 80020d4:	4b0d      	ldreq	r3, [pc, #52]	; (800210c <usartx_setbaud+0x40>)
	}
	else
	{ // Here, no.  It is presumed to be USART2, USART3, UART4, UART5
		apbclock = pclk1_freq;	
 80020d6:	4b0e      	ldrne	r3, [pc, #56]	; (8002110 <usartx_setbaud+0x44>)
	}

	/* Determine the integer part */
	integerdivider = ((0x19 * apbclock) / (0x04 * u32BaudRate));
 80020d8:	2219      	movs	r2, #25
	{  // Here, yes.
		apbclock = pclk2_freq;
	}
	else
	{ // Here, no.  It is presumed to be USART2, USART3, UART4, UART5
		apbclock = pclk1_freq;	
 80020da:	681b      	ldr	r3, [r3, #0]
	}

	/* Determine the integer part */
	integerdivider = ((0x19 * apbclock) / (0x04 * u32BaudRate));
 80020dc:	0089      	lsls	r1, r1, #2
 80020de:	4353      	muls	r3, r2
 80020e0:	fbb3 f1f1 	udiv	r1, r3, r1
	tmpreg = (integerdivider / 0x64) << 0x04;
 80020e4:	2364      	movs	r3, #100	; 0x64
 80020e6:	fbb1 f2f3 	udiv	r2, r1, r3
 80020ea:	0112      	lsls	r2, r2, #4

	/* Determine the fractional part */
	fractionaldivider = integerdivider - (0x64 * (tmpreg >> 0x04));
 80020ec:	0914      	lsrs	r4, r2, #4
 80020ee:	fb03 1114 	mls	r1, r3, r4, r1
	tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) & ((u8)0x0F);
 80020f2:	0109      	lsls	r1, r1, #4
 80020f4:	3132      	adds	r1, #50	; 0x32
 80020f6:	fbb1 f3f3 	udiv	r3, r1, r3
 80020fa:	f003 030f 	and.w	r3, r3, #15
 80020fe:	ea43 0202 	orr.w	r2, r3, r2

	/* Set USART BRR --------------------------------------------------------------- */
	  USART_BRR(usartx) = (u16)tmpreg;
 8002102:	b292      	uxth	r2, r2
 8002104:	6082      	str	r2, [r0, #8]
	return;
}
 8002106:	bd10      	pop	{r4, pc}
 8002108:	40013800 	.word	0x40013800
 800210c:	20000dd0 	.word	0x20000dd0
 8002110:	20000dd4 	.word	0x20000dd4

08002114 <usartx_txmin_init>:
 * @brief	: Initializes the USARTx to 8N1 and the baudrate 
 * @param	: u32 Baudrate		- baudrate 		(e.g. 115200)
 * @return	: none
******************************************************************************/
void usartx_txmin_init (u32 USARTx, u32 BaudRate)
{
 8002114:	b510      	push	{r4, lr}
 8002116:	4604      	mov	r4, r0
	/* Set baud rate */
	usartx_setbaud (USARTx,BaudRate);	// Compute divider settings and load BRR
 8002118:	f7ff ffd8 	bl	80020cc <usartx_setbaud>

	 	/* Setup CR2 ------------------------------------------------------------------- */
		/* After reset CR2 is 0x0000 and this is just fine */
		/* Set up CR1 (page 771) ------------------------------------------------------- */
		USART_CR1(USARTx) |= USART_UE | USART_TX_ENABLE;// Set UE, TE
 800211c:	68e3      	ldr	r3, [r4, #12]
 800211e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8002122:	f043 0308 	orr.w	r3, r3, #8
 8002126:	60e3      	str	r3, [r4, #12]
		// Note Tx interrupt enable is set when there is data ready to be sent		

	return;	
}
 8002128:	bd10      	pop	{r4, pc}

0800212a <usartx_rxdma_allocatebuffers>:
 * @param	: numberrcvlines is the number of receive line buffers (e.g. 4)
 * @param	: pUSARTcbrx points to pointer in static memory that points to control block
 * @return	: 0 = success;1 = fail mymallocl; 2 = zero getlinesize zero; 3 = numbergetlinesize zero
******************************************************************************/
u16 usartx_rxdma_allocatebuffers (u16 rcvcircularsize, u16 getlinesize, struct USARTCBR** pUSARTcbrx)
{
 800212a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800212c:	4604      	mov	r4, r0
 800212e:	4615      	mov	r5, r2
	u32* ptr;
	struct USARTCBR* pUSARTcbrl; // Local pointer to control block setup on heap

	/* Zero buffer size would cause trouble */
	if (getlinesize     == 0 ) return 2;
 8002130:	460f      	mov	r7, r1
 8002132:	b1d1      	cbz	r1, 800216a <usartx_rxdma_allocatebuffers+0x40>
	if (rcvcircularsize == 0 ) return 3;
 8002134:	b1d8      	cbz	r0, 800216e <usartx_rxdma_allocatebuffers+0x44>

	/* Allocate space and set pointer for the struct USARTcbtx */
	ptr = (u32*)mymalloc(sizeof (struct USARTCBR));
 8002136:	2024      	movs	r0, #36	; 0x24
 8002138:	f7ff ffb6 	bl	80020a8 <mymalloc>
	if  ( ptr  == 0)  return 1;
 800213c:	4606      	mov	r6, r0
 800213e:	b1c0      	cbz	r0, 8002172 <usartx_rxdma_allocatebuffers+0x48>
	*pUSARTcbrx = (struct USARTCBR*)ptr;	// Initialize static variable used by others
 8002140:	6028      	str	r0, [r5, #0]
u16*	prx_ctary_begin;// Constant: --not used--
u16	rx_ln_sz;	// Constant: size of circular line buffer  
u16	rx_ln_ct;	// Constant: size of getline buffer
*/
	/* Allocate space and set pointer in USARTcbrx for receive circular buffer */
	if ( (pUSARTcbrl->prx_begin = (char*)mymalloc(rcvcircularsize)) == 0 ) return 1;
 8002142:	4620      	mov	r0, r4
 8002144:	f7ff ffb0 	bl	80020a8 <mymalloc>
 8002148:	60f0      	str	r0, [r6, #12]
 800214a:	b190      	cbz	r0, 8002172 <usartx_rxdma_allocatebuffers+0x48>

	/* These tx pointers start out on the same line buffer */	
	pUSARTcbrl->prx_now_i = pUSARTcbrl->prx_begin;	// main's working pointer in circular rx buffer
 800214c:	6030      	str	r0, [r6, #0]

	/* Use this for testing for end of line buffers wraparound */
	pUSARTcbrl->prx_end     = pUSARTcbrl->prx_begin + rcvcircularsize;	// pointer to end 
 800214e:	1900      	adds	r0, r0, r4
 8002150:	6130      	str	r0, [r6, #16]

	/* Save rx circular buffer size */
	pUSARTcbrl->rx_ln_sz = rcvcircularsize;
 8002152:	8434      	strh	r4, [r6, #32]

	/* Save rx line buffer size */
	pUSARTcbrl->rx_ln_ct = getlinesize;
 8002154:	8477      	strh	r7, [r6, #34]	; 0x22

	/* Setup getline line buffer */
	if ( (pUSARTcbrl->prx_begin_i = (char*)(mymalloc(getlinesize))) == 0 ) return 1;
 8002156:	4638      	mov	r0, r7
 8002158:	f7ff ffa6 	bl	80020a8 <mymalloc>
 800215c:	60b0      	str	r0, [r6, #8]
 800215e:	b150      	cbz	r0, 8002176 <usartx_rxdma_allocatebuffers+0x4c>
	pUSARTcbrl->prx_begin_m = pUSARTcbrl->prx_begin_i;	// Set working pointer: main
	pUSARTcbrl->prx_ctary_now_i = (u16*)(pUSARTcbrl->prx_begin_i + getlinesize);	// Set constant: pointer end
 8002160:	19c7      	adds	r7, r0, r7
	/* Save rx line buffer size */
	pUSARTcbrl->rx_ln_ct = getlinesize;

	/* Setup getline line buffer */
	if ( (pUSARTcbrl->prx_begin_i = (char*)(mymalloc(getlinesize))) == 0 ) return 1;
	pUSARTcbrl->prx_begin_m = pUSARTcbrl->prx_begin_i;	// Set working pointer: main
 8002162:	6070      	str	r0, [r6, #4]
	pUSARTcbrl->prx_ctary_now_i = (u16*)(pUSARTcbrl->prx_begin_i + getlinesize);	// Set constant: pointer end
 8002164:	61b7      	str	r7, [r6, #24]

	return 0;
 8002166:	2000      	movs	r0, #0
 8002168:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
{
	u32* ptr;
	struct USARTCBR* pUSARTcbrl; // Local pointer to control block setup on heap

	/* Zero buffer size would cause trouble */
	if (getlinesize     == 0 ) return 2;
 800216a:	2002      	movs	r0, #2
 800216c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (rcvcircularsize == 0 ) return 3;
 800216e:	2003      	movs	r0, #3
 8002170:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
u16*	prx_ctary_begin;// Constant: --not used--
u16	rx_ln_sz;	// Constant: size of circular line buffer  
u16	rx_ln_ct;	// Constant: size of getline buffer
*/
	/* Allocate space and set pointer in USARTcbrx for receive circular buffer */
	if ( (pUSARTcbrl->prx_begin = (char*)mymalloc(rcvcircularsize)) == 0 ) return 1;
 8002172:	2001      	movs	r0, #1
 8002174:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	/* Save rx line buffer size */
	pUSARTcbrl->rx_ln_ct = getlinesize;

	/* Setup getline line buffer */
	if ( (pUSARTcbrl->prx_begin_i = (char*)(mymalloc(getlinesize))) == 0 ) return 1;
 8002176:	2001      	movs	r0, #1
	pUSARTcbrl->prx_begin_m = pUSARTcbrl->prx_begin_i;	// Set working pointer: main
	pUSARTcbrl->prx_ctary_now_i = (u16*)(pUSARTcbrl->prx_begin_i + getlinesize);	// Set constant: pointer end

	return 0;
}
 8002178:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800217a <usartx_rxdma_usart_init>:
 * void usartx_rxdma_usart_init (u32 USARTx, u32 BaudRate);
 * @brief	: Setup USART baudrate, rx for dma
 * @return	: none
******************************************************************************/
void usartx_rxdma_usart_init (u32 USARTx, u32 BaudRate)
{
 800217a:	b510      	push	{r4, lr}
 800217c:	4604      	mov	r4, r0
	/* Set baud rate */
	usartx_setbaud(USARTx,BaudRate);	// Compute divider settings and load BRR
 800217e:	f7ff ffa5 	bl	80020cc <usartx_setbaud>

 	/* Setup CR2 ------------------------------------------------------------------- */
	/* After reset CR2 is 0x0000 and this is just fine */

	/* Set up CR1 (page 771) ------------------------------------------------------- */
	USART_CR1(USARTx) |= USART_UE | USART_RX_ENABLE;// Set Usart enable, receive enable
 8002182:	68e3      	ldr	r3, [r4, #12]
 8002184:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8002188:	f043 0304 	orr.w	r3, r3, #4
 800218c:	60e3      	str	r3, [r4, #12]
	
	/* Hook up usart rx to dma channel */
	USART_CR3(USARTx) |= USART_DMAR;			// CR3 setup
 800218e:	6963      	ldr	r3, [r4, #20]
 8002190:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8002194:	6163      	str	r3, [r4, #20]

	return;	
}
 8002196:	bd10      	pop	{r4, pc}

08002198 <rc_crc32>:
 * @param	: pData = pointer input bytes
 * @param	: len = byte count
 * @return	: crc
*******************************************************************************/
uint32_t rc_crc32(u8* buf, u32 len)
{
 8002198:	b510      	push	{r4, lr}
	u8 octet;
	u8 *p, *q;
 	u32 crc = ~0;
	
	q = buf + len;
 800219a:	1841      	adds	r1, r0, r1
*******************************************************************************/
uint32_t rc_crc32(u8* buf, u32 len)
{
	u8 octet;
	u8 *p, *q;
 	u32 crc = ~0;
 800219c:	f04f 33ff 	mov.w	r3, #4294967295
	
	q = buf + len;
	for (p = buf; p < q; p++) {
 80021a0:	e009      	b.n	80021b6 <rc_crc32+0x1e>
		octet = *p;  /* Cast to unsigned octet. */
		crc = (crc >> 8) ^ crctable[(crc & 0xff) ^ octet];
 80021a2:	f810 2b01 	ldrb.w	r2, [r0], #1
 80021a6:	f003 04ff 	and.w	r4, r3, #255	; 0xff
 80021aa:	4054      	eors	r4, r2
 80021ac:	4a04      	ldr	r2, [pc, #16]	; (80021c0 <rc_crc32+0x28>)
 80021ae:	f852 2024 	ldr.w	r2, [r2, r4, lsl #2]
 80021b2:	ea82 2313 	eor.w	r3, r2, r3, lsr #8
	u8 octet;
	u8 *p, *q;
 	u32 crc = ~0;
	
	q = buf + len;
	for (p = buf; p < q; p++) {
 80021b6:	4288      	cmp	r0, r1
 80021b8:	d3f3      	bcc.n	80021a2 <rc_crc32+0xa>
		octet = *p;  /* Cast to unsigned octet. */
		crc = (crc >> 8) ^ crctable[(crc & 0xff) ^ octet];
	}
	return ~crc;
}
 80021ba:	43d8      	mvns	r0, r3
 80021bc:	bd10      	pop	{r4, pc}
 80021be:	bf00      	nop
 80021c0:	08003aa4 	.word	0x08003aa4

080021c4 <can_nxp_setRS>:
 * @param	: rs: 0 = NORMAL mode; not-zero = SILENT mode 
 * @param	: board: 0 = POD, 1 = sensor RxT6 board
 * @return	: Nothing for now.
*******************************************************************************/
void can_nxp_setRS(int rs, int board)
{
 80021c4:	b510      	push	{r4, lr}
 80021c6:	4604      	mov	r4, r0
	/* RS (S) control PB7 (on sensor board) PD11 on pod board */
	// Floating input = resistor controls slope
	// Pin HI = standby;
	// Pin LO = high speed;
	if (board == 0)
 80021c8:	b961      	cbnz	r1, 80021e4 <can_nxp_setRS+0x20>
	{
		configure_pin ((volatile u32 *)GPIOD, 11);	// configured for push-pull output
 80021ca:	480d      	ldr	r0, [pc, #52]	; (8002200 <can_nxp_setRS+0x3c>)
 80021cc:	310b      	adds	r1, #11
 80021ce:	f000 f9cf 	bl	8002570 <configure_pin>
		if (rs == 0)
 80021d2:	b91c      	cbnz	r4, 80021dc <can_nxp_setRS+0x18>
			GPIO_BRR(GPIOD)  = (1<<11);	// Set bit LO for SILENT mode
 80021d4:	4b0b      	ldr	r3, [pc, #44]	; (8002204 <can_nxp_setRS+0x40>)
 80021d6:	f44f 6200 	mov.w	r2, #2048	; 0x800
 80021da:	e00a      	b.n	80021f2 <can_nxp_setRS+0x2e>
		else
			GPIO_BSRR(GPIOD) = (1<<11);	// Set bit HI for NORMAL mode
 80021dc:	f44f 6200 	mov.w	r2, #2048	; 0x800
 80021e0:	4b09      	ldr	r3, [pc, #36]	; (8002208 <can_nxp_setRS+0x44>)
 80021e2:	e00a      	b.n	80021fa <can_nxp_setRS+0x36>
	}
	else
	{
		configure_pin ((volatile u32 *)GPIOB,  7);	// configured for push-pull output	
 80021e4:	4809      	ldr	r0, [pc, #36]	; (800220c <can_nxp_setRS+0x48>)
 80021e6:	2107      	movs	r1, #7
 80021e8:	f000 f9c2 	bl	8002570 <configure_pin>
		if (rs == 0)
 80021ec:	b91c      	cbnz	r4, 80021f6 <can_nxp_setRS+0x32>
			GPIO_BRR(GPIOB)  = (1<< 7);	// Set bit LO for SILENT mode
 80021ee:	4b08      	ldr	r3, [pc, #32]	; (8002210 <can_nxp_setRS+0x4c>)
 80021f0:	2280      	movs	r2, #128	; 0x80
 80021f2:	801a      	strh	r2, [r3, #0]
 80021f4:	bd10      	pop	{r4, pc}
		else
			GPIO_BSRR(GPIOB) = (1<< 7);	// Set bit HI for NORMAL mode
 80021f6:	4b07      	ldr	r3, [pc, #28]	; (8002214 <can_nxp_setRS+0x50>)
 80021f8:	2280      	movs	r2, #128	; 0x80
 80021fa:	601a      	str	r2, [r3, #0]
 80021fc:	bd10      	pop	{r4, pc}
 80021fe:	bf00      	nop
 8002200:	40011400 	.word	0x40011400
 8002204:	40011414 	.word	0x40011414
 8002208:	40011410 	.word	0x40011410
 800220c:	40010c00 	.word	0x40010c00
 8002210:	40010c14 	.word	0x40010c14
 8002214:	40010c10 	.word	0x40010c10

08002218 <canwinch_setup_F103_pod_clocks>:
 * @return	:  pointer to struct
*******************************************************************************/
struct CLOCKS* canwinch_setup_F103_pod_clocks(void)
{
	return (struct CLOCKS*)&clocks;
}
 8002218:	4800      	ldr	r0, [pc, #0]	; (800221c <canwinch_setup_F103_pod_clocks+0x4>)
 800221a:	4770      	bx	lr
 800221c:	08003ea4 	.word	0x08003ea4

08002220 <canwinch_setup_F103_pod>:
 *		:  -5 port pin setup failed
 *		:  -6 CAN initialization mode timed out
 *		:  -7 Leave initialization mode timed out
*******************************************************************************/
struct CAN_CTLBLOCK* canwinch_setup_F103_pod(const struct CAN_INIT* pinit, u32 canid)
{
 8002220:	4603      	mov	r3, r0
 8002222:	b570      	push	{r4, r5, r6, lr}
	//                                parameters, TX buff, RX0 buff, RX1 buff
	struct CAN_CTLBLOCK* pctl;
	pctl = can_driver_init( (struct CAN_PARAMS2*)&params, pinit);
 8002224:	4811      	ldr	r0, [pc, #68]	; (800226c <canwinch_setup_F103_pod+0x4c>)
 *		:  -5 port pin setup failed
 *		:  -6 CAN initialization mode timed out
 *		:  -7 Leave initialization mode timed out
*******************************************************************************/
struct CAN_CTLBLOCK* canwinch_setup_F103_pod(const struct CAN_INIT* pinit, u32 canid)
{
 8002226:	460e      	mov	r6, r1
	//                                parameters, TX buff, RX0 buff, RX1 buff
	struct CAN_CTLBLOCK* pctl;
	pctl = can_driver_init( (struct CAN_PARAMS2*)&params, pinit);
 8002228:	4619      	mov	r1, r3
 800222a:	f000 fb89 	bl	8002940 <can_driver_init>

	/* Early CAN init failure returns NULL. */
	if (pctl == NULL) return NULL;
 800222e:	4604      	mov	r4, r0
 8002230:	b1d0      	cbz	r0, 8002268 <canwinch_setup_F103_pod+0x48>

	/* Check for more init problems. */
	if (pctl->ret != 0) return pctl;
 8002232:	f990 3090 	ldrsb.w	r3, [r0, #144]	; 0x90
 8002236:	b9bb      	cbnz	r3, 8002268 <canwinch_setup_F103_pod+0x48>
 * @return	: 0 = success; -1 for error
*******************************************************************************/
static int canwinch_setup_F103_filter(u32 canid)
{
	/* Turn off active bit for all filters (including those for CAN2!). */
	can_driver_filter_deactivate_all();
 8002238:	f000 ff2a 	bl	8003090 <can_driver_filter_deactivate_all>

	/* Insert new filters and activate. */
	int ret;
	ret  = can_driver_filter_insert((struct CANFILTERPARAM*)&fb0); // Hi-priority group
 800223c:	480c      	ldr	r0, [pc, #48]	; (8002270 <canwinch_setup_F103_pod+0x50>)
 800223e:	f000 ff67 	bl	8003110 <can_driver_filter_insert>
	ret |= can_driver_filter_add_two_32b_id(canid, CANID_DUMMY, 1, 1); // Unit ID
 8002242:	2201      	movs	r2, #1
	/* Turn off active bit for all filters (including those for CAN2!). */
	can_driver_filter_deactivate_all();

	/* Insert new filters and activate. */
	int ret;
	ret  = can_driver_filter_insert((struct CANFILTERPARAM*)&fb0); // Hi-priority group
 8002244:	4605      	mov	r5, r0
	ret |= can_driver_filter_add_two_32b_id(canid, CANID_DUMMY, 1, 1); // Unit ID
 8002246:	f06f 0103 	mvn.w	r1, #3
 800224a:	4630      	mov	r0, r6
 800224c:	4613      	mov	r3, r2
 800224e:	f001 f851 	bl	80032f4 <can_driver_filter_add_two_32b_id>
 8002252:	4606      	mov	r6, r0
	ret |= can_driver_filter_insert((struct CANFILTERPARAM*)&fb2); // FIFO0 gets all others
 8002254:	4807      	ldr	r0, [pc, #28]	; (8002274 <canwinch_setup_F103_pod+0x54>)
 8002256:	f000 ff5b 	bl	8003110 <can_driver_filter_insert>
	can_driver_filter_deactivate_all();

	/* Insert new filters and activate. */
	int ret;
	ret  = can_driver_filter_insert((struct CANFILTERPARAM*)&fb0); // Hi-priority group
	ret |= can_driver_filter_add_two_32b_id(canid, CANID_DUMMY, 1, 1); // Unit ID
 800225a:	ea46 0505 	orr.w	r5, r6, r5
	/* Check for more init problems. */
	if (pctl->ret != 0) return pctl;

	/* Here, CAN init OK.  Setup hardware msg filtering */
	int ret = canwinch_setup_F103_filter(canid);
	if (ret != 0) pctl->ret = (ret - 7); // Set ret to -8 or -9
 800225e:	4305      	orrs	r5, r0
 8002260:	d002      	beq.n	8002268 <canwinch_setup_F103_pod+0x48>
 8002262:	3d07      	subs	r5, #7
 8002264:	f884 5090 	strb.w	r5, [r4, #144]	; 0x90

	return pctl;
	
}
 8002268:	4620      	mov	r0, r4
 800226a:	bd70      	pop	{r4, r5, r6, pc}
 800226c:	08003eb0 	.word	0x08003eb0
 8002270:	08003ed8 	.word	0x08003ed8
 8002274:	08003ee4 	.word	0x08003ee4

08002278 <loop>:
{
	GPIO_BSRR(GPIOE) = 0x38;
	return;
}	
static void loop(volatile int ct)
{
 8002278:	b082      	sub	sp, #8
 800227a:	9001      	str	r0, [sp, #4]
	while (ct > 0) ct -= 1; 
 800227c:	e002      	b.n	8002284 <loop+0xc>
 800227e:	9b01      	ldr	r3, [sp, #4]
 8002280:	3b01      	subs	r3, #1
 8002282:	9301      	str	r3, [sp, #4]
 8002284:	9b01      	ldr	r3, [sp, #4]
 8002286:	2b00      	cmp	r3, #0
 8002288:	dcf9      	bgt.n	800227e <loop+0x6>
	return;
}
 800228a:	b002      	add	sp, #8
 800228c:	4770      	bx	lr

0800228e <panic_leds_pod>:
void panic_leds_pod(unsigned int count);
 * @param	: Number of fast flashes
 * @brief	: Configure gpio pins
 ******************************************************************************/
void panic_leds_pod(unsigned int count)
{
 800228e:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	volatile int x;		// Loop ct for timing pause
	volatile int xon;	// Loop ct for timing LED on duration
	volatile int xoff;	// Loop ct for timing LED off duration

	/* Have clocks been setup? */
	if (sysclk_freq < 1000000)
 8002290:	4b19      	ldr	r3, [pc, #100]	; (80022f8 <panic_leds_pod+0x6a>)
 8002292:	4a1a      	ldr	r2, [pc, #104]	; (80022fc <panic_leds_pod+0x6e>)
 8002294:	6819      	ldr	r1, [r3, #0]
void panic_leds_pod(unsigned int count);
 * @param	: Number of fast flashes
 * @brief	: Configure gpio pins
 ******************************************************************************/
void panic_leds_pod(unsigned int count)
{
 8002296:	4604      	mov	r4, r0
	volatile int x;		// Loop ct for timing pause
	volatile int xon;	// Loop ct for timing LED on duration
	volatile int xoff;	// Loop ct for timing LED off duration

	/* Have clocks been setup? */
	if (sysclk_freq < 1000000)
 8002298:	4291      	cmp	r1, r2
	{ // Here, no.  We are running on the 8 MHz HSI oscillator
		sysclk_freq = 8000000;	// Set default
 800229a:	bf9c      	itt	ls
 800229c:	4a18      	ldrls	r2, [pc, #96]	; (8002300 <panic_leds_pod+0x72>)
 800229e:	601a      	strls	r2, [r3, #0]
	}

	/* Setup timing for pause */
	x = sysclk_freq/10;
 80022a0:	681b      	ldr	r3, [r3, #0]
 80022a2:	220a      	movs	r2, #10
 80022a4:	fbb3 f2f2 	udiv	r2, r3, r2
 80022a8:	9203      	str	r2, [sp, #12]

	/* Setup timing for fast flash */
	xon =  sysclk_freq/250;
 80022aa:	22fa      	movs	r2, #250	; 0xfa
 80022ac:	fbb3 f2f2 	udiv	r2, r3, r2
 80022b0:	9202      	str	r2, [sp, #8]
	xoff = sysclk_freq/40;
 80022b2:	2228      	movs	r2, #40	; 0x28
 80022b4:	fbb3 f3f2 	udiv	r3, r3, r2
 80022b8:	9301      	str	r3, [sp, #4]

	/* Limit max count */
	if (count == 0) count = 6; // Bogus count
 80022ba:	b118      	cbz	r0, 80022c4 <panic_leds_pod+0x36>
	if (count > 6)  count = 7; // Bogus count
 80022bc:	2c07      	cmp	r4, #7
 80022be:	bf28      	it	cs
 80022c0:	2407      	movcs	r4, #7
 80022c2:	e000      	b.n	80022c6 <panic_leds_pod+0x38>
	/* Setup timing for fast flash */
	xon =  sysclk_freq/250;
	xoff = sysclk_freq/40;

	/* Limit max count */
	if (count == 0) count = 6; // Bogus count
 80022c4:	2406      	movs	r4, #6
	if (count > 6)  count = 7; // Bogus count

	/* Be sure we have the ports and pins setup for the LEDs */
	PODgpiopins_default();	// Set gpio port register bits for low power
 80022c6:	f000 fa19 	bl	80026fc <PODgpiopins_default>
	PODgpiopins_Config();	// Now, configure pins
 80022ca:	f000 f9a9 	bl	8002620 <PODgpiopins_Config>
 80022ce:	e010      	b.n	80022f2 <panic_leds_pod+0x64>

extern unsigned int	sysclk_freq;	/* 	SYSCLK freq		E.g. 72000000	*/

static void allon(void)
{
	GPIO_BRR(GPIOE) = 0x38;
 80022d0:	4b0c      	ldr	r3, [pc, #48]	; (8002304 <panic_leds_pod+0x76>)
 80022d2:	2638      	movs	r6, #56	; 0x38
 80022d4:	801e      	strh	r6, [r3, #0]
	/* Now flash, flash, flash away, ye' rummies.  Batten the hatches, 'er there be trouble. */
	while (1==1)
	{
		for (i = 0; i < count; i++)
		{
			allon();	loop(xon);
 80022d6:	9802      	ldr	r0, [sp, #8]
 80022d8:	f7ff ffce 	bl	8002278 <loop>
	GPIO_BRR(GPIOE) = 0x38;
	return;
}
static void alloff(void)
{
	GPIO_BSRR(GPIOE) = 0x38;
 80022dc:	4b0a      	ldr	r3, [pc, #40]	; (8002308 <panic_leds_pod+0x7a>)
	PODgpiopins_Config();	// Now, configure pins
	
	/* Now flash, flash, flash away, ye' rummies.  Batten the hatches, 'er there be trouble. */
	while (1==1)
	{
		for (i = 0; i < count; i++)
 80022de:	3501      	adds	r5, #1
	GPIO_BRR(GPIOE) = 0x38;
	return;
}
static void alloff(void)
{
	GPIO_BSRR(GPIOE) = 0x38;
 80022e0:	601e      	str	r6, [r3, #0]
	while (1==1)
	{
		for (i = 0; i < count; i++)
		{
			allon();	loop(xon);
			alloff();	loop(xoff);			
 80022e2:	9801      	ldr	r0, [sp, #4]
 80022e4:	f7ff ffc8 	bl	8002278 <loop>
	PODgpiopins_Config();	// Now, configure pins
	
	/* Now flash, flash, flash away, ye' rummies.  Batten the hatches, 'er there be trouble. */
	while (1==1)
	{
		for (i = 0; i < count; i++)
 80022e8:	42a5      	cmp	r5, r4
 80022ea:	d3f1      	bcc.n	80022d0 <panic_leds_pod+0x42>
		{
			allon();	loop(xon);
			alloff();	loop(xoff);			
		}
		loop(x);
 80022ec:	9803      	ldr	r0, [sp, #12]
 80022ee:	f7ff ffc3 	bl	8002278 <loop>
	PODgpiopins_Config();	// Now, configure pins
	
	/* Now flash, flash, flash away, ye' rummies.  Batten the hatches, 'er there be trouble. */
	while (1==1)
	{
		for (i = 0; i < count; i++)
 80022f2:	2500      	movs	r5, #0
 80022f4:	e7f8      	b.n	80022e8 <panic_leds_pod+0x5a>
 80022f6:	bf00      	nop
 80022f8:	20000dcc 	.word	0x20000dcc
 80022fc:	000f423f 	.word	0x000f423f
 8002300:	007a1200 	.word	0x007a1200
 8002304:	40011814 	.word	0x40011814
 8002308:	40011810 	.word	0x40011810

0800230c <flash_write_ram>:
 800230c:	b530      	push	{r4, r5, lr}
 800230e:	2a00      	cmp	r2, #0
 8002310:	f100 0004 	add.w	r0, r0, #4
 8002314:	f101 0104 	add.w	r1, r1, #4
 8002318:	dd1b      	ble.n	8002352 <flash_write_ram+0x46>
 800231a:	4b0f      	ldr	r3, [pc, #60]	; (8002358 <flash_write_ram+0x4c>)
 800231c:	681c      	ldr	r4, [r3, #0]
 800231e:	f014 0f01 	tst.w	r4, #1
 8002322:	461c      	mov	r4, r3
 8002324:	d1f9      	bne.n	800231a <flash_write_ram+0xe>
 8002326:	3304      	adds	r3, #4
 8002328:	681d      	ldr	r5, [r3, #0]
 800232a:	f045 0501 	orr.w	r5, r5, #1
 800232e:	601d      	str	r5, [r3, #0]
 8002330:	f831 5c04 	ldrh.w	r5, [r1, #-4]
 8002334:	f820 5c04 	strh.w	r5, [r0, #-4]
 8002338:	6825      	ldr	r5, [r4, #0]
 800233a:	07ed      	lsls	r5, r5, #31
 800233c:	d4fc      	bmi.n	8002338 <flash_write_ram+0x2c>
 800233e:	681c      	ldr	r4, [r3, #0]
 8002340:	3a01      	subs	r2, #1
 8002342:	f044 0401 	orr.w	r4, r4, #1
 8002346:	601c      	str	r4, [r3, #0]
 8002348:	f831 3c02 	ldrh.w	r3, [r1, #-2]
 800234c:	f820 3c02 	strh.w	r3, [r0, #-2]
 8002350:	e7dd      	b.n	800230e <flash_write_ram+0x2>
 8002352:	2000      	movs	r0, #0
 8002354:	bd30      	pop	{r4, r5, pc}
 8002356:	bf00      	nop
 8002358:	4002200c 	.word	0x4002200c

0800235c <flash_unlock>:
 800235c:	4b04      	ldr	r3, [pc, #16]	; (8002370 <flash_unlock+0x14>)
 800235e:	4a05      	ldr	r2, [pc, #20]	; (8002374 <flash_unlock+0x18>)
 8002360:	601a      	str	r2, [r3, #0]
 8002362:	f102 3288 	add.w	r2, r2, #2290649224	; 0x88888888
 8002366:	601a      	str	r2, [r3, #0]
 8002368:	68d8      	ldr	r0, [r3, #12]
 800236a:	f000 0080 	and.w	r0, r0, #128	; 0x80
 800236e:	4770      	bx	lr
 8002370:	40022004 	.word	0x40022004
 8002374:	45670123 	.word	0x45670123

08002378 <flash_unlock2>:
 8002378:	4b04      	ldr	r3, [pc, #16]	; (800238c <flash_unlock2+0x14>)
 800237a:	4a05      	ldr	r2, [pc, #20]	; (8002390 <flash_unlock2+0x18>)
 800237c:	601a      	str	r2, [r3, #0]
 800237e:	f102 3288 	add.w	r2, r2, #2290649224	; 0x88888888
 8002382:	601a      	str	r2, [r3, #0]
 8002384:	68d8      	ldr	r0, [r3, #12]
 8002386:	f000 0080 	and.w	r0, r0, #128	; 0x80
 800238a:	4770      	bx	lr
 800238c:	40022044 	.word	0x40022044
 8002390:	45670123 	.word	0x45670123

08002394 <flash_write>:
 8002394:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002398:	4690      	mov	r8, r2
 800239a:	4605      	mov	r5, r0
 800239c:	4c2c      	ldr	r4, [pc, #176]	; (8002450 <flash_write+0xbc>)
 800239e:	2600      	movs	r6, #0
 80023a0:	6026      	str	r6, [r4, #0]
 80023a2:	f101 0902 	add.w	r9, r1, #2
 80023a6:	4546      	cmp	r6, r8
 80023a8:	da39      	bge.n	800241e <flash_write+0x8a>
 80023aa:	4b2a      	ldr	r3, [pc, #168]	; (8002454 <flash_write+0xc0>)
 80023ac:	429d      	cmp	r5, r3
 80023ae:	d917      	bls.n	80023e0 <flash_write+0x4c>
 80023b0:	4b29      	ldr	r3, [pc, #164]	; (8002458 <flash_write+0xc4>)
 80023b2:	429d      	cmp	r5, r3
 80023b4:	d83c      	bhi.n	8002430 <flash_write+0x9c>
 80023b6:	4f29      	ldr	r7, [pc, #164]	; (800245c <flash_write+0xc8>)
 80023b8:	683b      	ldr	r3, [r7, #0]
 80023ba:	07d8      	lsls	r0, r3, #31
 80023bc:	d4fb      	bmi.n	80023b6 <flash_write+0x22>
 80023be:	f7ff ffdb 	bl	8002378 <flash_unlock2>
 80023c2:	2800      	cmp	r0, #0
 80023c4:	d138      	bne.n	8002438 <flash_write+0xa4>
 80023c6:	2334      	movs	r3, #52	; 0x34
 80023c8:	603b      	str	r3, [r7, #0]
 80023ca:	4b25      	ldr	r3, [pc, #148]	; (8002460 <flash_write+0xcc>)
 80023cc:	2201      	movs	r2, #1
 80023ce:	601a      	str	r2, [r3, #0]
 80023d0:	f839 3c02 	ldrh.w	r3, [r9, #-2]
 80023d4:	802b      	strh	r3, [r5, #0]
 80023d6:	683b      	ldr	r3, [r7, #0]
 80023d8:	07d9      	lsls	r1, r3, #31
 80023da:	d4fc      	bmi.n	80023d6 <flash_write+0x42>
 80023dc:	4b1f      	ldr	r3, [pc, #124]	; (800245c <flash_write+0xc8>)
 80023de:	e015      	b.n	800240c <flash_write+0x78>
 80023e0:	f5b5 0f00 	cmp.w	r5, #8388608	; 0x800000
 80023e4:	d32c      	bcc.n	8002440 <flash_write+0xac>
 80023e6:	4f1f      	ldr	r7, [pc, #124]	; (8002464 <flash_write+0xd0>)
 80023e8:	683b      	ldr	r3, [r7, #0]
 80023ea:	07da      	lsls	r2, r3, #31
 80023ec:	d4fb      	bmi.n	80023e6 <flash_write+0x52>
 80023ee:	f7ff ffb5 	bl	800235c <flash_unlock>
 80023f2:	bb48      	cbnz	r0, 8002448 <flash_write+0xb4>
 80023f4:	2334      	movs	r3, #52	; 0x34
 80023f6:	603b      	str	r3, [r7, #0]
 80023f8:	4b1b      	ldr	r3, [pc, #108]	; (8002468 <flash_write+0xd4>)
 80023fa:	2201      	movs	r2, #1
 80023fc:	601a      	str	r2, [r3, #0]
 80023fe:	f839 3c02 	ldrh.w	r3, [r9, #-2]
 8002402:	802b      	strh	r3, [r5, #0]
 8002404:	683b      	ldr	r3, [r7, #0]
 8002406:	07db      	lsls	r3, r3, #31
 8002408:	d4fc      	bmi.n	8002404 <flash_write+0x70>
 800240a:	4b16      	ldr	r3, [pc, #88]	; (8002464 <flash_write+0xd0>)
 800240c:	681b      	ldr	r3, [r3, #0]
 800240e:	6822      	ldr	r2, [r4, #0]
 8002410:	3601      	adds	r6, #1
 8002412:	4313      	orrs	r3, r2
 8002414:	6023      	str	r3, [r4, #0]
 8002416:	3502      	adds	r5, #2
 8002418:	f109 0902 	add.w	r9, r9, #2
 800241c:	e7c3      	b.n	80023a6 <flash_write+0x12>
 800241e:	6823      	ldr	r3, [r4, #0]
 8002420:	f013 0f14 	tst.w	r3, #20
 8002424:	bf14      	ite	ne
 8002426:	f06f 0004 	mvnne.w	r0, #4
 800242a:	2000      	moveq	r0, #0
 800242c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8002430:	f04f 30ff 	mov.w	r0, #4294967295
 8002434:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8002438:	f06f 0001 	mvn.w	r0, #1
 800243c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8002440:	f06f 0002 	mvn.w	r0, #2
 8002444:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8002448:	f06f 0003 	mvn.w	r0, #3
 800244c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8002450:	200015f4 	.word	0x200015f4
 8002454:	0807ffff 	.word	0x0807ffff
 8002458:	080ffffe 	.word	0x080ffffe
 800245c:	4002204c 	.word	0x4002204c
 8002460:	40022050 	.word	0x40022050
 8002464:	4002200c 	.word	0x4002200c
 8002468:	40022010 	.word	0x40022010

0800246c <flash_erase>:
 800246c:	b570      	push	{r4, r5, r6, lr}
 800246e:	4c2d      	ldr	r4, [pc, #180]	; (8002524 <flash_erase+0xb8>)
 8002470:	2300      	movs	r3, #0
 8002472:	6023      	str	r3, [r4, #0]
 8002474:	4b2c      	ldr	r3, [pc, #176]	; (8002528 <flash_erase+0xbc>)
 8002476:	4605      	mov	r5, r0
 8002478:	4298      	cmp	r0, r3
 800247a:	d91e      	bls.n	80024ba <flash_erase+0x4e>
 800247c:	4b2b      	ldr	r3, [pc, #172]	; (800252c <flash_erase+0xc0>)
 800247e:	4298      	cmp	r0, r3
 8002480:	d844      	bhi.n	800250c <flash_erase+0xa0>
 8002482:	4b2b      	ldr	r3, [pc, #172]	; (8002530 <flash_erase+0xc4>)
 8002484:	681a      	ldr	r2, [r3, #0]
 8002486:	461e      	mov	r6, r3
 8002488:	f012 0f01 	tst.w	r2, #1
 800248c:	d1f9      	bne.n	8002482 <flash_erase+0x16>
 800248e:	f7ff ff73 	bl	8002378 <flash_unlock2>
 8002492:	2800      	cmp	r0, #0
 8002494:	d13d      	bne.n	8002512 <flash_erase+0xa6>
 8002496:	4b27      	ldr	r3, [pc, #156]	; (8002534 <flash_erase+0xc8>)
 8002498:	2202      	movs	r2, #2
 800249a:	601a      	str	r2, [r3, #0]
 800249c:	4a26      	ldr	r2, [pc, #152]	; (8002538 <flash_erase+0xcc>)
 800249e:	6015      	str	r5, [r2, #0]
 80024a0:	681a      	ldr	r2, [r3, #0]
 80024a2:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80024a6:	601a      	str	r2, [r3, #0]
 80024a8:	6832      	ldr	r2, [r6, #0]
 80024aa:	07d1      	lsls	r1, r2, #31
 80024ac:	d4fc      	bmi.n	80024a8 <flash_erase+0x3c>
 80024ae:	681a      	ldr	r2, [r3, #0]
 80024b0:	f022 0202 	bic.w	r2, r2, #2
 80024b4:	601a      	str	r2, [r3, #0]
 80024b6:	4b1e      	ldr	r3, [pc, #120]	; (8002530 <flash_erase+0xc4>)
 80024b8:	e01c      	b.n	80024f4 <flash_erase+0x88>
 80024ba:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 80024be:	d32b      	bcc.n	8002518 <flash_erase+0xac>
 80024c0:	4b1e      	ldr	r3, [pc, #120]	; (800253c <flash_erase+0xd0>)
 80024c2:	681a      	ldr	r2, [r3, #0]
 80024c4:	461e      	mov	r6, r3
 80024c6:	f012 0f01 	tst.w	r2, #1
 80024ca:	d1f9      	bne.n	80024c0 <flash_erase+0x54>
 80024cc:	f7ff ff46 	bl	800235c <flash_unlock>
 80024d0:	bb28      	cbnz	r0, 800251e <flash_erase+0xb2>
 80024d2:	4b1b      	ldr	r3, [pc, #108]	; (8002540 <flash_erase+0xd4>)
 80024d4:	2202      	movs	r2, #2
 80024d6:	601a      	str	r2, [r3, #0]
 80024d8:	4a1a      	ldr	r2, [pc, #104]	; (8002544 <flash_erase+0xd8>)
 80024da:	6015      	str	r5, [r2, #0]
 80024dc:	681a      	ldr	r2, [r3, #0]
 80024de:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80024e2:	601a      	str	r2, [r3, #0]
 80024e4:	6832      	ldr	r2, [r6, #0]
 80024e6:	07d2      	lsls	r2, r2, #31
 80024e8:	d4fc      	bmi.n	80024e4 <flash_erase+0x78>
 80024ea:	681a      	ldr	r2, [r3, #0]
 80024ec:	f022 0202 	bic.w	r2, r2, #2
 80024f0:	601a      	str	r2, [r3, #0]
 80024f2:	4b12      	ldr	r3, [pc, #72]	; (800253c <flash_erase+0xd0>)
 80024f4:	681b      	ldr	r3, [r3, #0]
 80024f6:	6822      	ldr	r2, [r4, #0]
 80024f8:	4313      	orrs	r3, r2
 80024fa:	6023      	str	r3, [r4, #0]
 80024fc:	6823      	ldr	r3, [r4, #0]
 80024fe:	f013 0f14 	tst.w	r3, #20
 8002502:	bf14      	ite	ne
 8002504:	f06f 0004 	mvnne.w	r0, #4
 8002508:	2000      	moveq	r0, #0
 800250a:	bd70      	pop	{r4, r5, r6, pc}
 800250c:	f04f 30ff 	mov.w	r0, #4294967295
 8002510:	bd70      	pop	{r4, r5, r6, pc}
 8002512:	f06f 0001 	mvn.w	r0, #1
 8002516:	bd70      	pop	{r4, r5, r6, pc}
 8002518:	f06f 0002 	mvn.w	r0, #2
 800251c:	bd70      	pop	{r4, r5, r6, pc}
 800251e:	f06f 0003 	mvn.w	r0, #3
 8002522:	bd70      	pop	{r4, r5, r6, pc}
 8002524:	200015f4 	.word	0x200015f4
 8002528:	0807ffff 	.word	0x0807ffff
 800252c:	080ffffe 	.word	0x080ffffe
 8002530:	4002204c 	.word	0x4002204c
 8002534:	40022050 	.word	0x40022050
 8002538:	40022054 	.word	0x40022054
 800253c:	4002200c 	.word	0x4002200c
 8002540:	40022010 	.word	0x40022010
 8002544:	40022014 	.word	0x40022014

08002548 <SENSORgpiopins_Config>:
 8002548:	b538      	push	{r3, r4, r5, lr}
 800254a:	4d08      	ldr	r5, [pc, #32]	; (800256c <SENSORgpiopins_Config+0x24>)
 800254c:	4628      	mov	r0, r5
 800254e:	f000 f821 	bl	8002594 <pinconfig_all>
 8002552:	4604      	mov	r4, r0
 8002554:	f105 0008 	add.w	r0, r5, #8
 8002558:	f000 f81c 	bl	8002594 <pinconfig_all>
 800255c:	4304      	orrs	r4, r0
 800255e:	f105 0010 	add.w	r0, r5, #16
 8002562:	f000 f817 	bl	8002594 <pinconfig_all>
 8002566:	4320      	orrs	r0, r4
 8002568:	bd38      	pop	{r3, r4, r5, pc}
 800256a:	bf00      	nop
 800256c:	08003ef0 	.word	0x08003ef0

08002570 <configure_pin>:
 8002570:	2907      	cmp	r1, #7
 8002572:	bfc4      	itt	gt
 8002574:	3004      	addgt	r0, #4
 8002576:	3908      	subgt	r1, #8
 8002578:	6802      	ldr	r2, [r0, #0]
 800257a:	0089      	lsls	r1, r1, #2
 800257c:	230f      	movs	r3, #15
 800257e:	408b      	lsls	r3, r1
 8002580:	ea22 0303 	bic.w	r3, r2, r3
 8002584:	6003      	str	r3, [r0, #0]
 8002586:	6802      	ldr	r2, [r0, #0]
 8002588:	2303      	movs	r3, #3
 800258a:	408b      	lsls	r3, r1
 800258c:	4313      	orrs	r3, r2
 800258e:	6003      	str	r3, [r0, #0]
 8002590:	4770      	bx	lr
 8002592:	bf00      	nop

08002594 <pinconfig_all>:
 * @brief	: configure a pin according to the parameters in the struct
 * @param	: p = pointer to struct (see .h file)
 * @return	: negative = error; 0 = OK
 **************************************************************************************************************** */
int pinconfig_all (struct PINCONFIGALL *p)
{
 8002594:	b510      	push	{r4, lr}
	u8 mode;	// Temp for building 'mode'
	u8 cnf;		// Temp for building 'cnf'
	u8 n = p->pin;			// bit number for port pin.  Save for later
 8002596:	7902      	ldrb	r2, [r0, #4]
	volatile u32 *pp = p->port;	// port register address.  Save for later
 8002598:	6803      	ldr	r3, [r0, #0]
	
	/* Check for out-of-bounds parameters */
	if (p->pin > 15) return -3;	// Pin number out of range
 800259a:	2a0f      	cmp	r2, #15
 800259c:	d833      	bhi.n	8002606 <pinconfig_all+0x72>
	if (p->speed > 3) return -2;	// Speed code out of range
 800259e:	7981      	ldrb	r1, [r0, #6]
 80025a0:	2903      	cmp	r1, #3
 80025a2:	d833      	bhi.n	800260c <pinconfig_all+0x78>
	if (p->usecode > 7) return -1;	// Useage code out of range
 80025a4:	7941      	ldrb	r1, [r0, #5]
 80025a6:	2907      	cmp	r1, #7
 80025a8:	d833      	bhi.n	8002612 <pinconfig_all+0x7e>

	/* For input pull-up/dn set ODR register first */
	if (p->usecode == IN_PU)
 80025aa:	d102      	bne.n	80025b2 <pinconfig_all+0x1e>
		// Here, input with pull up, set bit in ODR register
		GPIO_BSRR((unsigned int)p->port) = (1 << p->pin); // Set bit
 80025ac:	2101      	movs	r1, #1
 80025ae:	4091      	lsls	r1, r2
 80025b0:	6119      	str	r1, [r3, #16]
	if (p->usecode == IN_PD)
 80025b2:	7941      	ldrb	r1, [r0, #5]
 80025b4:	2906      	cmp	r1, #6
 80025b6:	d104      	bne.n	80025c2 <pinconfig_all+0x2e>
		// Here, input with pull down, clear bit in ODR register
		GPIO_BRR((unsigned int)p->port) = (1 << p->pin); // Reset bit
 80025b8:	7901      	ldrb	r1, [r0, #4]
 80025ba:	2401      	movs	r4, #1
 80025bc:	fa14 f101 	lsls.w	r1, r4, r1
 80025c0:	8299      	strh	r1, [r3, #20]
	
	/* Adjust for port address for high and low registers that have the CNF|MODE bits. */
	if (n >= 8)	// Is this pin in the high or low register?
 80025c2:	2a07      	cmp	r2, #7
 80025c4:	d902      	bls.n	80025cc <pinconfig_all+0x38>
	{ // Here, the high byte register (CRH), else low byte register (CRL)
		pp = pp + 0x01;	// point to high register (pins 8-15)
		n -= 8;		// adjust shift count 
 80025c6:	3a08      	subs	r2, #8
		GPIO_BRR((unsigned int)p->port) = (1 << p->pin); // Reset bit
	
	/* Adjust for port address for high and low registers that have the CNF|MODE bits. */
	if (n >= 8)	// Is this pin in the high or low register?
	{ // Here, the high byte register (CRH), else low byte register (CRL)
		pp = pp + 0x01;	// point to high register (pins 8-15)
 80025c8:	3304      	adds	r3, #4
		n -= 8;		// adjust shift count 
 80025ca:	b2d2      	uxtb	r2, r2
	}

	/* Reset CNF & MODE bits */
	*pp &= ~((0x000f ) << ( 4 * n ));	// Clear CNF reset bit 01 = Floating input (reset state)
 80025cc:	0094      	lsls	r4, r2, #2
 80025ce:	220f      	movs	r2, #15
 80025d0:	40a2      	lsls	r2, r4
 80025d2:	6819      	ldr	r1, [r3, #0]
 80025d4:	ea21 0202 	bic.w	r2, r1, r2
 80025d8:	601a      	str	r2, [r3, #0]

	/* Derive 'mode' code from use code */
	if (p->usecode < 4)	// Is this an output useage?
 80025da:	7942      	ldrb	r2, [r0, #5]
 80025dc:	2a03      	cmp	r2, #3
 80025de:	d802      	bhi.n	80025e6 <pinconfig_all+0x52>
	{ // Here, yes.
		if (p->speed == 0) return -4;	// Outputs require a speed code
 80025e0:	7981      	ldrb	r1, [r0, #6]
 80025e2:	b939      	cbnz	r1, 80025f4 <pinconfig_all+0x60>
 80025e4:	e018      	b.n	8002618 <pinconfig_all+0x84>
	}
	else
	{ // Here, input use
		mode = 0;
		cnf = (p->usecode - 4);	// cnf = 0-3
		if (p->usecode > 5)	// 6 or 7 = input pull up/dn
 80025e6:	2a05      	cmp	r2, #5
 80025e8:	d802      	bhi.n	80025f0 <pinconfig_all+0x5c>
		cnf = p->usecode; 	// cnf = 0-3.
	}
	else
	{ // Here, input use
		mode = 0;
		cnf = (p->usecode - 4);	// cnf = 0-3
 80025ea:	3a04      	subs	r2, #4
 80025ec:	b2d2      	uxtb	r2, r2
 80025ee:	e000      	b.n	80025f2 <pinconfig_all+0x5e>
		if (p->usecode > 5)	// 6 or 7 = input pull up/dn
			cnf = 2;	// Same cnf code for pull up & pull dn.
 80025f0:	2202      	movs	r2, #2
		mode = p->speed;	// mode 1,2,3
		cnf = p->usecode; 	// cnf = 0-3.
	}
	else
	{ // Here, input use
		mode = 0;
 80025f2:	2100      	movs	r1, #0
		if (p->usecode > 5)	// 6 or 7 = input pull up/dn
			cnf = 2;	// Same cnf code for pull up & pull dn.
	}

	/* Set cnf and mode */
	*pp |=  (( (cnf << 2) | (mode) ) << ( 4 * n ));	
 80025f4:	ea41 0282 	orr.w	r2, r1, r2, lsl #2
 80025f8:	fa12 f404 	lsls.w	r4, r2, r4
 80025fc:	6818      	ldr	r0, [r3, #0]
 80025fe:	4304      	orrs	r4, r0
 8002600:	601c      	str	r4, [r3, #0]
		
	return 0;
 8002602:	2000      	movs	r0, #0
 8002604:	bd10      	pop	{r4, pc}
	u8 cnf;		// Temp for building 'cnf'
	u8 n = p->pin;			// bit number for port pin.  Save for later
	volatile u32 *pp = p->port;	// port register address.  Save for later
	
	/* Check for out-of-bounds parameters */
	if (p->pin > 15) return -3;	// Pin number out of range
 8002606:	f06f 0002 	mvn.w	r0, #2
 800260a:	bd10      	pop	{r4, pc}
	if (p->speed > 3) return -2;	// Speed code out of range
 800260c:	f06f 0001 	mvn.w	r0, #1
 8002610:	bd10      	pop	{r4, pc}
	if (p->usecode > 7) return -1;	// Useage code out of range
 8002612:	f04f 30ff 	mov.w	r0, #4294967295
 8002616:	bd10      	pop	{r4, pc}
	*pp &= ~((0x000f ) << ( 4 * n ));	// Clear CNF reset bit 01 = Floating input (reset state)

	/* Derive 'mode' code from use code */
	if (p->usecode < 4)	// Is this an output useage?
	{ // Here, yes.
		if (p->speed == 0) return -4;	// Outputs require a speed code
 8002618:	f06f 0003 	mvn.w	r0, #3

	/* Set cnf and mode */
	*pp |=  (( (cnf << 2) | (mode) ) << ( 4 * n ));	
		
	return 0;
}
 800261c:	bd10      	pop	{r4, pc}
	...

08002620 <PODgpiopins_Config>:
/* ----------------------------- PORTA -------------------------------------- */
	//  PA0- - POD_box (external) LED: gpio out
//	GPIO_CRL(GPIOA) &= ~((0x000f ) << (4*0));	// Clear CNF reset bit 01 = Floating input (reset state)
//	GPIO_CRL(GPIOA) |=  (( (GPIO_CNF_OUTPUT_PUSHPULL<<2) | (GPIO_MODE_OUTPUT_50_MHZ) ) << (4*0));
	//  PA4 - AD7799_2 /CS: gpio out
	GPIO_CRL(GPIOA) &= ~((0x000f ) << (4*4));	// Clear CNF reset bit 01 = Floating input (reset state)
 8002620:	4b2e      	ldr	r3, [pc, #184]	; (80026dc <PODgpiopins_Config+0xbc>)
 8002622:	681a      	ldr	r2, [r3, #0]
 8002624:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
 8002628:	601a      	str	r2, [r3, #0]
	GPIO_CRL(GPIOA) |=  (( (GPIO_CNF_OUTPUT_PUSHPULL<<2) | (GPIO_MODE_OUTPUT_50_MHZ) ) << (4*4));
 800262a:	681a      	ldr	r2, [r3, #0]
 800262c:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
 8002630:	601a      	str	r2, [r3, #0]
	//  PA7 - SPI1_MOSI: gpio out
	GPIO_CRL(GPIOA) &= ~((0x000f ) << (4*7));	// Clear CNF reset bit 01 = Floating input (reset state)
 8002632:	681a      	ldr	r2, [r3, #0]
 8002634:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 8002638:	601a      	str	r2, [r3, #0]
	GPIO_CRL(GPIOA) |=  (( (GPIO_CNF_OUTPUT_PUSHPULL<<2) | (GPIO_MODE_OUTPUT_50_MHZ) ) << (4*7));
 800263a:	681a      	ldr	r2, [r3, #0]
 800263c:	f042 5240 	orr.w	r2, r2, #805306368	; 0x30000000
 8002640:	601a      	str	r2, [r3, #0]
	
	//  PA8 - 3.3v SD Card reg enable: gpio out
	GPIO_CRH(GPIOA) &= ~((0x000f ) << (4*0));	// Clear CNF reset bit 01 = Floating input (reset state)
 8002642:	685a      	ldr	r2, [r3, #4]
 8002644:	f022 020f 	bic.w	r2, r2, #15
 8002648:	605a      	str	r2, [r3, #4]
	GPIO_CRH(GPIOA) |=  (( (GPIO_CNF_OUTPUT_PUSHPULL<<2 | GPIO_MODE_OUTPUT_50_MHZ) << (4*0) ) );	
 800264a:	685a      	ldr	r2, [r3, #4]
 800264c:	f042 0203 	orr.w	r2, r2, #3
 8002650:	605a      	str	r2, [r3, #4]
/* ----------------------------- PORTB -------------------------------------- */
	// PB5	3.3v reg enable--XBee : gpio out
	GPIO_CRL(GPIOB) &= ~((0x000f ) << (4*5));	// Clear CNF reset bit 01 = Floating input (reset state)
 8002652:	4b23      	ldr	r3, [pc, #140]	; (80026e0 <PODgpiopins_Config+0xc0>)
 8002654:	681a      	ldr	r2, [r3, #0]
 8002656:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
 800265a:	601a      	str	r2, [r3, #0]
	GPIO_CRL(GPIOB) |=  (( (GPIO_CNF_OUTPUT_PUSHPULL<<2 | GPIO_MODE_OUTPUT_50_MHZ) << (4*5)));	
 800265c:	681a      	ldr	r2, [r3, #0]
 800265e:	f442 1240 	orr.w	r2, r2, #3145728	; 0x300000
 8002662:	601a      	str	r2, [r3, #0]
	// PB8	XBee /DTR/SLEEP_RQ: gpio_out 
	// PB9	XBee /RESET: gpio_out 
	// PB10	AD7799_1 /CS:gpio_out
	// PB12	SD_CARD_CD/DAT3/CS:SPI2_NSS
	GPIO_CRH(GPIOB) &=  ~(  ((0x000f) << (4*0)) | ((0x000f) << (4*1)) | ((0x000f) << (4*2)) | ((0x000f ) << (4*4)) );
 8002664:	6859      	ldr	r1, [r3, #4]
 8002666:	4a1f      	ldr	r2, [pc, #124]	; (80026e4 <PODgpiopins_Config+0xc4>)
 8002668:	ea01 0202 	and.w	r2, r1, r2
 800266c:	605a      	str	r2, [r3, #4]

	GPIO_CRH(GPIOB) |=      (((GPIO_CNF_OUTPUT_PUSHPULL<<2) | GPIO_MODE_OUTPUT_50_MHZ) << (4*0)) |\
 800266e:	6859      	ldr	r1, [r3, #4]
 8002670:	4a1d      	ldr	r2, [pc, #116]	; (80026e8 <PODgpiopins_Config+0xc8>)
 8002672:	ea41 0202 	orr.w	r2, r1, r2
 8002676:	605a      	str	r2, [r3, #4]
				(((GPIO_CNF_OUTPUT_PUSHPULL<<2) | GPIO_MODE_OUTPUT_50_MHZ) << (4*2)) |\
				(((GPIO_CNF_OUTPUT_PUSHPULL<<2) | GPIO_MODE_OUTPUT_50_MHZ) << (4*4)) ;
/* ----------------------------- PORTC -------------------------------------- */
	// PC4	Top Cell V ADC divider enable: gpio
	// PC5	Bottom Cell V ADC divider enable: gpio
	GPIO_CRL(GPIOC) &=  ~( ( 0x000f<<(4*4) ) | ( 0x000f<<(4*5) ) );
 8002678:	4b1c      	ldr	r3, [pc, #112]	; (80026ec <PODgpiopins_Config+0xcc>)
 800267a:	681a      	ldr	r2, [r3, #0]
 800267c:	f422 027f 	bic.w	r2, r2, #16711680	; 0xff0000
 8002680:	601a      	str	r2, [r3, #0]

	GPIO_CRL(GPIOC) |=	(((GPIO_CNF_OUTPUT_PUSHPULL<<2) | GPIO_MODE_OUTPUT_2_MHZ) << (4*4)) |\
 8002682:	681a      	ldr	r2, [r3, #0]
 8002684:	f442 1208 	orr.w	r2, r2, #2228224	; 0x220000
 8002688:	601a      	str	r2, [r3, #0]
				(((GPIO_CNF_OUTPUT_PUSHPULL<<2) | GPIO_MODE_OUTPUT_2_MHZ) << (4*5)) ;

/* ----------------------------- PORTD -------------------------------------- */
	// PD1	TXCO Vcc switch:gpio out
	// PD7	MAX3232 Vcc switch: gpio out
	GPIO_CRL(GPIOD) &= ~( ( 0x000f<<(4*1) ) | ( 0x000f<<(4*7) ) );
 800268a:	4b19      	ldr	r3, [pc, #100]	; (80026f0 <PODgpiopins_Config+0xd0>)
 800268c:	681a      	ldr	r2, [r3, #0]
 800268e:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 8002692:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8002696:	601a      	str	r2, [r3, #0]

	GPIO_CRL(GPIOD) |=  	(((GPIO_CNF_OUTPUT_PUSHPULL<<2) | GPIO_MODE_OUTPUT_50_MHZ) << (4*1)) |\
 8002698:	681a      	ldr	r2, [r3, #0]
 800269a:	f042 5240 	orr.w	r2, r2, #805306368	; 0x30000000
 800269e:	f042 0230 	orr.w	r2, r2, #48	; 0x30
 80026a2:	601a      	str	r2, [r3, #0]
				(((GPIO_CNF_OUTPUT_PUSHPULL<<2) | GPIO_MODE_OUTPUT_50_MHZ) << (4*7)) ;


	// PD10	5V reg enable--Analog--strain guage & AD7799: gpio_out
	// PD14	5v reg enable--Encoders & GPS : gpio
	GPIO_CRH(GPIOD) &= ~( ((0x000f ) << (4*2)) | ((0x000f ) << (4*6)) );
 80026a4:	685a      	ldr	r2, [r3, #4]
 80026a6:	f022 220f 	bic.w	r2, r2, #251662080	; 0xf000f00
 80026aa:	605a      	str	r2, [r3, #4]

	GPIO_CRH(GPIOD) |= 	( ((GPIO_CNF_OUTPUT_PUSHPULL<<2 | GPIO_MODE_OUTPUT_50_MHZ) << (4*2)) |\
 80026ac:	685a      	ldr	r2, [r3, #4]
 80026ae:	f042 2203 	orr.w	r2, r2, #50332416	; 0x3000300
 80026b2:	605a      	str	r2, [r3, #4]
	// PE3	LED43_1: gpio out
	// PE4	LED43_2: gpio out
	// PE5	LED65_1: gpio out
	// PE6	LED65_2: gpio out
	// PE7	3.2 Regulator EN, Analog: gpio
	GPIO_CRL(GPIOE) &=     ~(((0x000f ) << (4*2)) | ((0x000f ) << (4*3)) | ((0x000f ) << (4*4)) |\
 80026b4:	4b0f      	ldr	r3, [pc, #60]	; (80026f4 <PODgpiopins_Config+0xd4>)
 80026b6:	681a      	ldr	r2, [r3, #0]
 80026b8:	f002 02ff 	and.w	r2, r2, #255	; 0xff
 80026bc:	601a      	str	r2, [r3, #0]
			   	 ((0x000f ) << (4*5)) | ((0x000f ) << (4*6)) | ((0x000f ) << (4*7)) );


	GPIO_CRL(GPIOE) |=	(((GPIO_CNF_OUTPUT_PUSHPULL<<2) | GPIO_MODE_OUTPUT_50_MHZ) << (4*2)) |\
 80026be:	6819      	ldr	r1, [r3, #0]
 80026c0:	4a0d      	ldr	r2, [pc, #52]	; (80026f8 <PODgpiopins_Config+0xd8>)
 80026c2:	ea41 0202 	orr.w	r2, r1, r2
 80026c6:	601a      	str	r2, [r3, #0]
				(((GPIO_CNF_OUTPUT_PUSHPULL<<2) | GPIO_MODE_OUTPUT_50_MHZ) << (4*6)) |\
				(((GPIO_CNF_OUTPUT_PUSHPULL<<2) | GPIO_MODE_OUTPUT_50_MHZ) << (4*7)) ;

	
	// PE15	AD7799 Vcc switch: gpio out
	GPIO_CRH(GPIOE) &=  (~((0x000f ) << (4*7)));	// Clear CNF reset bit 01 = Floating input (reset state)
 80026c8:	685a      	ldr	r2, [r3, #4]
 80026ca:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 80026ce:	605a      	str	r2, [r3, #4]
	GPIO_CRH(GPIOE) |=  (( (GPIO_CNF_OUTPUT_PUSHPULL<<2) | (GPIO_MODE_OUTPUT_50_MHZ) ) << (4*7));	
 80026d0:	685a      	ldr	r2, [r3, #4]
 80026d2:	f042 5240 	orr.w	r2, r2, #805306368	; 0x30000000
 80026d6:	605a      	str	r2, [r3, #4]


	return;
}
 80026d8:	4770      	bx	lr
 80026da:	bf00      	nop
 80026dc:	40010800 	.word	0x40010800
 80026e0:	40010c00 	.word	0x40010c00
 80026e4:	fff0f000 	.word	0xfff0f000
 80026e8:	00030333 	.word	0x00030333
 80026ec:	40011000 	.word	0x40011000
 80026f0:	40011400 	.word	0x40011400
 80026f4:	40011800 	.word	0x40011800
 80026f8:	33333300 	.word	0x33333300

080026fc <PODgpiopins_default>:
 ******************************************************************************/
void PODgpiopins_default(void)
{
/* ----------------------------- PORTA -------------------------------------- */
	//  PA4 - AD7799_2 /CS: gpio out
	AD7799_2_CS_hi	// Set bit
 80026fc:	4a15      	ldr	r2, [pc, #84]	; (8002754 <PODgpiopins_default+0x58>)
	//  PA8 - 3.3v SD Card regulator enable: gpio out
	SDCARDREG_off	// Reset bit
 80026fe:	4916      	ldr	r1, [pc, #88]	; (8002758 <PODgpiopins_default+0x5c>)
/******************************************************************************
 * void PODgpiopins_default(void);
 * @brief	: Set pins to low power (default setting)
 ******************************************************************************/
void PODgpiopins_default(void)
{
 8002700:	b530      	push	{r4, r5, lr}
/* ----------------------------- PORTA -------------------------------------- */
	//  PA4 - AD7799_2 /CS: gpio out
	AD7799_2_CS_hi	// Set bit
 8002702:	2310      	movs	r3, #16
	//  PA8 - 3.3v SD Card regulator enable: gpio out
	SDCARDREG_off	// Reset bit
 8002704:	f44f 7480 	mov.w	r4, #256	; 0x100
/* ----------------------------- PORTB -------------------------------------- */
	// PB5	3.3v regulator enable--XBee : gpio out
	XBEEREG_off	// Reset bit
 8002708:	4814      	ldr	r0, [pc, #80]	; (800275c <PODgpiopins_default+0x60>)
	// PB8	XBee /DTR/SLEEP_RQ: gpio_out 
	XBEESLEEPRQ_hi	// Set bit
 800270a:	4d15      	ldr	r5, [pc, #84]	; (8002760 <PODgpiopins_default+0x64>)
 ******************************************************************************/
void PODgpiopins_default(void)
{
/* ----------------------------- PORTA -------------------------------------- */
	//  PA4 - AD7799_2 /CS: gpio out
	AD7799_2_CS_hi	// Set bit
 800270c:	6013      	str	r3, [r2, #0]
	//  PA8 - 3.3v SD Card regulator enable: gpio out
	SDCARDREG_off	// Reset bit
 800270e:	800c      	strh	r4, [r1, #0]
/* ----------------------------- PORTB -------------------------------------- */
	// PB5	3.3v regulator enable--XBee : gpio out
	XBEEREG_off	// Reset bit
 8002710:	2120      	movs	r1, #32
 8002712:	8001      	strh	r1, [r0, #0]
	// PB8	XBee /DTR/SLEEP_RQ: gpio_out 
	XBEESLEEPRQ_hi	// Set bit
 8002714:	602c      	str	r4, [r5, #0]
	// PB9	XBee /RESET: gpio_out 
	XBEE_RESET_low	// Reset bit
 8002716:	f44f 7400 	mov.w	r4, #512	; 0x200
 800271a:	8004      	strh	r4, [r0, #0]
	// PB10	AD7799_1 /CS:gpio_out
	AD7799_2_CS_hi	// Set bit
 800271c:	6013      	str	r3, [r2, #0]
/* ----------------------------- PORTC -------------------------------------- */
	// PC4	Top Cell V ADC divider enable: gpio
	TOPCELLADC_off	// Reset bit
 800271e:	4a11      	ldr	r2, [pc, #68]	; (8002764 <PODgpiopins_default+0x68>)
	// PD7	MAX3232 Vcc switch: gpio out
	MAX3232SW_off	// Set bit
	// PD10	5V regulator enable--Analog--strain guage & AD7799: gpio_out
	STRAINGAUGEPWR_off	// Set bit
	// PD14	5v regulator enable--Encoders & GPS : gpio
	ENCODERGPSPWR_off	// Reset bit
 8002720:	f44f 4480 	mov.w	r4, #16384	; 0x4000
	XBEE_RESET_low	// Reset bit
	// PB10	AD7799_1 /CS:gpio_out
	AD7799_2_CS_hi	// Set bit
/* ----------------------------- PORTC -------------------------------------- */
	// PC4	Top Cell V ADC divider enable: gpio
	TOPCELLADC_off	// Reset bit
 8002724:	8013      	strh	r3, [r2, #0]
	// PC5	Bottom Cell V ADC divider enable: gpio
	BOTTMCELLADC_off// Reset bit

/* ----------------------------- PORTD -------------------------------------- */
	// PD1	TXCO Vcc switch:gpio out
	TXCOSW_off	// Set bit
 8002726:	4b10      	ldr	r3, [pc, #64]	; (8002768 <PODgpiopins_default+0x6c>)
	AD7799_2_CS_hi	// Set bit
/* ----------------------------- PORTC -------------------------------------- */
	// PC4	Top Cell V ADC divider enable: gpio
	TOPCELLADC_off	// Reset bit
	// PC5	Bottom Cell V ADC divider enable: gpio
	BOTTMCELLADC_off// Reset bit
 8002728:	8011      	strh	r1, [r2, #0]

/* ----------------------------- PORTD -------------------------------------- */
	// PD1	TXCO Vcc switch:gpio out
	TXCOSW_off	// Set bit
 800272a:	2202      	movs	r2, #2
 800272c:	601a      	str	r2, [r3, #0]
	// PD7	MAX3232 Vcc switch: gpio out
	MAX3232SW_off	// Set bit
	// PD10	5V regulator enable--Analog--strain guage & AD7799: gpio_out
	STRAINGAUGEPWR_off	// Set bit
 800272e:	f44f 6180 	mov.w	r1, #1024	; 0x400

/* ----------------------------- PORTD -------------------------------------- */
	// PD1	TXCO Vcc switch:gpio out
	TXCOSW_off	// Set bit
	// PD7	MAX3232 Vcc switch: gpio out
	MAX3232SW_off	// Set bit
 8002732:	327e      	adds	r2, #126	; 0x7e
 8002734:	601a      	str	r2, [r3, #0]
	// PD10	5V regulator enable--Analog--strain guage & AD7799: gpio_out
	STRAINGAUGEPWR_off	// Set bit
 8002736:	8099      	strh	r1, [r3, #4]
	// PD14	5v regulator enable--Encoders & GPS : gpio
	ENCODERGPSPWR_off	// Reset bit
 8002738:	809c      	strh	r4, [r3, #4]

/* ----------------------------- PORTE -------------------------------------- */
	// PE2	EXTERNAL LED FET-PAD3: gpio out
	EXTERNALLED_off	// Reset bit
 800273a:	4b0c      	ldr	r3, [pc, #48]	; (800276c <PODgpiopins_default+0x70>)
 800273c:	2104      	movs	r1, #4
 800273e:	8019      	strh	r1, [r3, #0]
	// PE3	LED43_1: gpio out
	// PE7	3.3 Regulator EN, Analog: gpio
	ANALOGREG_off	// Reset bit
 8002740:	801a      	strh	r2, [r3, #0]
	// PE15	AD7799 Vcc switch: gpio out
	ADC7799VCCSW_off	// Set bit
 8002742:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8002746:	f843 2c04 	str.w	r2, [r3, #-4]
	// LED 43_1,_2 and LED 65_1, _2 *all* off
	LEDSALL_off
 800274a:	2278      	movs	r2, #120	; 0x78
 800274c:	f843 2c04 	str.w	r2, [r3, #-4]

	return;
}
 8002750:	bd30      	pop	{r4, r5, pc}
 8002752:	bf00      	nop
 8002754:	40010810 	.word	0x40010810
 8002758:	40010814 	.word	0x40010814
 800275c:	40010c14 	.word	0x40010c14
 8002760:	40010c10 	.word	0x40010c10
 8002764:	40011014 	.word	0x40011014
 8002768:	40011410 	.word	0x40011410
 800276c:	40011814 	.word	0x40011814

08002770 <PA0_reconfig>:
 * void PA0_reconfig(char x);
 * @param	: 0 = output; not-zero = floating input
 * @brief	: Reconfigure PA0 
 ******************************************************************************/
void PA0_reconfig(char x)
{
 8002770:	4b09      	ldr	r3, [pc, #36]	; (8002798 <PA0_reconfig+0x28>)
	if (x == 0)
 8002772:	b938      	cbnz	r0, 8002784 <PA0_reconfig+0x14>
	{ // Here, setup for output
		//  PA0- - POD_box (external) LED: gpio out
		GPIO_CRL(GPIOA) &= ~((0x000f ) << (4*0));	// Clear CNF
 8002774:	681a      	ldr	r2, [r3, #0]
 8002776:	f022 020f 	bic.w	r2, r2, #15
 800277a:	601a      	str	r2, [r3, #0]
		GPIO_CRL(GPIOA) |=  (( (GPIO_CNF_OUTPUT_PUSHPULL<<2) | (GPIO_MODE_OUTPUT_50_MHZ) ) << (4*0));		
 800277c:	681a      	ldr	r2, [r3, #0]
 800277e:	f042 0203 	orr.w	r2, r2, #3
 8002782:	e006      	b.n	8002792 <PA0_reconfig+0x22>
	}
	else
	{ // Here, setup for input
		//  PA0- - POD_box (external) pushbutton input
		GPIO_CRL(GPIOA) &= ~((0x000f ) << (4*0));	// Clear CNF
 8002784:	681a      	ldr	r2, [r3, #0]
 8002786:	f022 020f 	bic.w	r2, r2, #15
 800278a:	601a      	str	r2, [r3, #0]
		GPIO_CRL(GPIOA) |=  (( (GPIO_CNF_INPUT_FLOAT<<2) | (GPIO_MODE_INPUT) ) << (4*0));
 800278c:	681a      	ldr	r2, [r3, #0]
 800278e:	f042 0204 	orr.w	r2, r2, #4
 8002792:	601a      	str	r2, [r3, #0]
 8002794:	4770      	bx	lr
 8002796:	bf00      	nop
 8002798:	40010800 	.word	0x40010800

0800279c <configure_pin_pod>:
 * @param	: bit in port to set or reset
 **************************************************************************************************************** */
void configure_pin_pod ( volatile u32 * p, int n)
{
		
	if (n >= 8)
 800279c:	2907      	cmp	r1, #7
 800279e:	dd01      	ble.n	80027a4 <configure_pin_pod+0x8>
	{ // Here, the high byte register (CRH), else low byte register (CRL)
		p = p + 0x01;	// point to high register
 80027a0:	3004      	adds	r0, #4
		n -= 8;		// adjust shift count 
 80027a2:	3908      	subs	r1, #8
	}

	/* Reset CNF bits */
	*p &= ~((0x000f ) << ( 4 * n ));	// Clear CNF reset bit 01 = Floating input (reset state)
 80027a4:	0089      	lsls	r1, r1, #2
 80027a6:	230f      	movs	r3, #15
 80027a8:	408b      	lsls	r3, r1
 80027aa:	6802      	ldr	r2, [r0, #0]
 80027ac:	ea22 0303 	bic.w	r3, r2, r3

	/* Set for pushpull output */
	*p |=  (( (GPIO_CNF_OUTPUT_PUSHPULL<<2) | (GPIO_MODE_OUTPUT_50_MHZ) ) << ( 4 * n ));	
 80027b0:	2203      	movs	r2, #3
 80027b2:	fa12 f101 	lsls.w	r1, r2, r1
		p = p + 0x01;	// point to high register
		n -= 8;		// adjust shift count 
	}

	/* Reset CNF bits */
	*p &= ~((0x000f ) << ( 4 * n ));	// Clear CNF reset bit 01 = Floating input (reset state)
 80027b6:	6003      	str	r3, [r0, #0]

	/* Set for pushpull output */
	*p |=  (( (GPIO_CNF_OUTPUT_PUSHPULL<<2) | (GPIO_MODE_OUTPUT_50_MHZ) ) << ( 4 * n ));	
 80027b8:	6803      	ldr	r3, [r0, #0]
 80027ba:	4319      	orrs	r1, r3
 80027bc:	6001      	str	r1, [r0, #0]

	return;		
}
 80027be:	4770      	bx	lr

080027c0 <configure_pin_in_pd>:
void configure_pin_in_pd ( volatile u32 * p, int n, char pd)
{		
	/* Set output bit register (ODR) p 159 */
	// Mask out ODR bit, then or in the new bit (pd) *.
	p += 0X03;	// Point to ODR register
	*p = ( *p & ~(2 << n) ) | ( *p | ((pd & 0x01) << n) );
 80027c0:	2302      	movs	r3, #2
 80027c2:	408b      	lsls	r3, r1
 80027c4:	f002 0201 	and.w	r2, r2, #1
 80027c8:	408a      	lsls	r2, r1
 * @param	: pointer to port base
 * @param	: bit in port to set or reset
 * @pararm	: 0 = pull-down, 1 = pull-up
 **************************************************************************************************************** */
void configure_pin_in_pd ( volatile u32 * p, int n, char pd)
{		
 80027ca:	b530      	push	{r4, r5, lr}
	/* Set output bit register (ODR) p 159 */
	// Mask out ODR bit, then or in the new bit (pd) *.
	p += 0X03;	// Point to ODR register
	*p = ( *p & ~(2 << n) ) | ( *p | ((pd & 0x01) << n) );
 80027cc:	68c5      	ldr	r5, [r0, #12]
 80027ce:	68c4      	ldr	r4, [r0, #12]
 80027d0:	ea25 0303 	bic.w	r3, r5, r3
 80027d4:	4323      	orrs	r3, r4
 80027d6:	4313      	orrs	r3, r2
	p -= 0x03;	// Back to original

	if (n >= 8)
 80027d8:	2907      	cmp	r1, #7
void configure_pin_in_pd ( volatile u32 * p, int n, char pd)
{		
	/* Set output bit register (ODR) p 159 */
	// Mask out ODR bit, then or in the new bit (pd) *.
	p += 0X03;	// Point to ODR register
	*p = ( *p & ~(2 << n) ) | ( *p | ((pd & 0x01) << n) );
 80027da:	60c3      	str	r3, [r0, #12]
	p -= 0x03;	// Back to original

	if (n >= 8)
 80027dc:	dd01      	ble.n	80027e2 <configure_pin_in_pd+0x22>
	{ // Here, the high byte register (CRH), ('else' = low byte register (CRL))
		p = p + 0x01;	// point to high register
 80027de:	3004      	adds	r0, #4
		n -= 8;		// adjust shift count 
 80027e0:	3908      	subs	r1, #8
	}

	/* Reset CNF bits and Mode bits */
	*p &= ~((0x000f ) << ( 4 * n ));	// Clear CNF and mode
 80027e2:	0089      	lsls	r1, r1, #2
 80027e4:	230f      	movs	r3, #15
 80027e6:	408b      	lsls	r3, r1
 80027e8:	6802      	ldr	r2, [r0, #0]
 80027ea:	ea22 0303 	bic.w	r3, r2, r3

	/* Set for input, pull-up/pull-down */
	*p |=  (( (GPIO_CNF_INPUT_PULL_UPDOWN<<2) | (GPIO_MODE_INPUT) ) << ( 4 * n ));	
 80027ee:	2208      	movs	r2, #8
 80027f0:	fa12 f101 	lsls.w	r1, r2, r1
		p = p + 0x01;	// point to high register
		n -= 8;		// adjust shift count 
	}

	/* Reset CNF bits and Mode bits */
	*p &= ~((0x000f ) << ( 4 * n ));	// Clear CNF and mode
 80027f4:	6003      	str	r3, [r0, #0]

	/* Set for input, pull-up/pull-down */
	*p |=  (( (GPIO_CNF_INPUT_PULL_UPDOWN<<2) | (GPIO_MODE_INPUT) ) << ( 4 * n ));	
 80027f6:	6803      	ldr	r3, [r0, #0]
 80027f8:	4319      	orrs	r1, r3
 80027fa:	6001      	str	r1, [r0, #0]

	return;		
}
 80027fc:	bd30      	pop	{r4, r5, pc}
 80027fe:	bf00      	nop

08002800 <disable_ints>:
 8002800:	4a15      	ldr	r2, [pc, #84]	; (8002858 <disable_ints+0x58>)
 8002802:	b510      	push	{r4, lr}
 8002804:	6813      	ldr	r3, [r2, #0]
 8002806:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800280a:	6003      	str	r3, [r0, #0]
 800280c:	4b13      	ldr	r3, [pc, #76]	; (800285c <disable_ints+0x5c>)
 800280e:	6819      	ldr	r1, [r3, #0]
 8002810:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8002814:	6041      	str	r1, [r0, #4]
 8002816:	6811      	ldr	r1, [r2, #0]
 8002818:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
 800281c:	6011      	str	r1, [r2, #0]
 800281e:	6819      	ldr	r1, [r3, #0]
 8002820:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
 8002824:	6019      	str	r1, [r3, #0]
 8002826:	490e      	ldr	r1, [pc, #56]	; (8002860 <disable_ints+0x60>)
 8002828:	680c      	ldr	r4, [r1, #0]
 800282a:	6810      	ldr	r0, [r2, #0]
 800282c:	f010 0f13 	tst.w	r0, #19
 8002830:	d005      	beq.n	800283e <disable_ints+0x3e>
 8002832:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
 8002836:	3001      	adds	r0, #1
 8002838:	f8c4 0080 	str.w	r0, [r4, #128]	; 0x80
 800283c:	e7f5      	b.n	800282a <disable_ints+0x2a>
 800283e:	6849      	ldr	r1, [r1, #4]
 8002840:	681a      	ldr	r2, [r3, #0]
 8002842:	f012 0f13 	tst.w	r2, #19
 8002846:	d005      	beq.n	8002854 <disable_ints+0x54>
 8002848:	f8d1 2080 	ldr.w	r2, [r1, #128]	; 0x80
 800284c:	3201      	adds	r2, #1
 800284e:	f8c1 2080 	str.w	r2, [r1, #128]	; 0x80
 8002852:	e7f5      	b.n	8002840 <disable_ints+0x40>
 8002854:	bd10      	pop	{r4, pc}
 8002856:	bf00      	nop
 8002858:	40006414 	.word	0x40006414
 800285c:	40006814 	.word	0x40006814
 8002860:	200015f8 	.word	0x200015f8

08002864 <reenable_ints>:
 8002864:	4a05      	ldr	r2, [pc, #20]	; (800287c <reenable_ints+0x18>)
 8002866:	6803      	ldr	r3, [r0, #0]
 8002868:	6811      	ldr	r1, [r2, #0]
 800286a:	430b      	orrs	r3, r1
 800286c:	6013      	str	r3, [r2, #0]
 800286e:	f8d2 1400 	ldr.w	r1, [r2, #1024]	; 0x400
 8002872:	6843      	ldr	r3, [r0, #4]
 8002874:	430b      	orrs	r3, r1
 8002876:	f8c2 3400 	str.w	r3, [r2, #1024]	; 0x400
 800287a:	4770      	bx	lr
 800287c:	40006414 	.word	0x40006414

08002880 <can_driver_toss>:
 8002880:	b513      	push	{r0, r1, r4, lr}
 8002882:	4604      	mov	r4, r0
 8002884:	4668      	mov	r0, sp
 8002886:	f7ff ffbb 	bl	8002800 <disable_ints>
 800288a:	68a3      	ldr	r3, [r4, #8]
 800288c:	3b01      	subs	r3, #1
 800288e:	60a3      	str	r3, [r4, #8]
 8002890:	4b0e      	ldr	r3, [pc, #56]	; (80028cc <can_driver_toss+0x4c>)
 8002892:	689a      	ldr	r2, [r3, #8]
 8002894:	3201      	adds	r2, #1
 8002896:	609a      	str	r2, [r3, #8]
 8002898:	6822      	ldr	r2, [r4, #0]
 800289a:	6912      	ldr	r2, [r2, #16]
 800289c:	6911      	ldr	r1, [r2, #16]
 800289e:	428a      	cmp	r2, r1
 80028a0:	bf19      	ittee	ne
 80028a2:	6821      	ldrne	r1, [r4, #0]
 80028a4:	6910      	ldrne	r0, [r2, #16]
 80028a6:	2100      	moveq	r1, #0
 80028a8:	6021      	streq	r1, [r4, #0]
 80028aa:	bf15      	itete	ne
 80028ac:	6108      	strne	r0, [r1, #16]
 80028ae:	68d9      	ldreq	r1, [r3, #12]
 80028b0:	6919      	ldrne	r1, [r3, #16]
 80028b2:	3101      	addeq	r1, #1
 80028b4:	bf16      	itet	ne
 80028b6:	3101      	addne	r1, #1
 80028b8:	60d9      	streq	r1, [r3, #12]
 80028ba:	6119      	strne	r1, [r3, #16]
 80028bc:	6a99      	ldr	r1, [r3, #40]	; 0x28
 80028be:	4668      	mov	r0, sp
 80028c0:	6111      	str	r1, [r2, #16]
 80028c2:	629a      	str	r2, [r3, #40]	; 0x28
 80028c4:	f7ff ffce 	bl	8002864 <reenable_ints>
 80028c8:	b002      	add	sp, #8
 80028ca:	bd10      	pop	{r4, pc}
 80028cc:	200015f8 	.word	0x200015f8

080028d0 <loadmbx2>:
 80028d0:	6983      	ldr	r3, [r0, #24]
 80028d2:	b90b      	cbnz	r3, 80028d8 <loadmbx2+0x8>
 80028d4:	6203      	str	r3, [r0, #32]
 80028d6:	4770      	bx	lr
 80028d8:	f100 0208 	add.w	r2, r0, #8
 80028dc:	6202      	str	r2, [r0, #32]
 80028de:	6859      	ldr	r1, [r3, #4]
 80028e0:	6802      	ldr	r2, [r0, #0]
 80028e2:	f8c2 1184 	str.w	r1, [r2, #388]	; 0x184
 80028e6:	6899      	ldr	r1, [r3, #8]
 80028e8:	6802      	ldr	r2, [r0, #0]
 80028ea:	f8c2 1188 	str.w	r1, [r2, #392]	; 0x188
 80028ee:	6802      	ldr	r2, [r0, #0]
 80028f0:	68d9      	ldr	r1, [r3, #12]
 80028f2:	f8c2 118c 	str.w	r1, [r2, #396]	; 0x18c
 80028f6:	681b      	ldr	r3, [r3, #0]
 80028f8:	6802      	ldr	r2, [r0, #0]
 80028fa:	f043 0301 	orr.w	r3, r3, #1
 80028fe:	f8c2 3180 	str.w	r3, [r2, #384]	; 0x180
 8002902:	4770      	bx	lr

08002904 <moveremove2>:
 8002904:	b513      	push	{r0, r1, r4, lr}
 8002906:	4604      	mov	r4, r0
 8002908:	4668      	mov	r0, sp
 800290a:	f7ff ff79 	bl	8002800 <disable_ints>
 800290e:	6a23      	ldr	r3, [r4, #32]
 8002910:	4668      	mov	r0, sp
 8002912:	691a      	ldr	r2, [r3, #16]
 8002914:	6a23      	ldr	r3, [r4, #32]
 8002916:	6911      	ldr	r1, [r2, #16]
 8002918:	6119      	str	r1, [r3, #16]
 800291a:	4b08      	ldr	r3, [pc, #32]	; (800293c <moveremove2+0x38>)
 800291c:	6a99      	ldr	r1, [r3, #40]	; 0x28
 800291e:	6111      	str	r1, [r2, #16]
 8002920:	629a      	str	r2, [r3, #40]	; 0x28
 8002922:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
 8002926:	3a01      	subs	r2, #1
 8002928:	f8c4 2084 	str.w	r2, [r4, #132]	; 0x84
 800292c:	689a      	ldr	r2, [r3, #8]
 800292e:	3201      	adds	r2, #1
 8002930:	609a      	str	r2, [r3, #8]
 8002932:	f7ff ff97 	bl	8002864 <reenable_ints>
 8002936:	b002      	add	sp, #8
 8002938:	bd10      	pop	{r4, pc}
 800293a:	bf00      	nop
 800293c:	200015f8 	.word	0x200015f8

08002940 <can_driver_init>:
 8002940:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002944:	7906      	ldrb	r6, [r0, #4]
 8002946:	4605      	mov	r5, r0
 8002948:	1e73      	subs	r3, r6, #1
 800294a:	2b01      	cmp	r3, #1
 800294c:	468a      	mov	sl, r1
 800294e:	d902      	bls.n	8002956 <can_driver_init+0x16>
 8002950:	2000      	movs	r0, #0
 8002952:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8002956:	2001      	movs	r0, #1
 8002958:	2198      	movs	r1, #152	; 0x98
 800295a:	f000 fd4d 	bl	80033f8 <calloc>
 800295e:	4604      	mov	r4, r0
 8002960:	2800      	cmp	r0, #0
 8002962:	d0f5      	beq.n	8002950 <can_driver_init+0x10>
 8002964:	2e01      	cmp	r6, #1
 8002966:	4e99      	ldr	r6, [pc, #612]	; (8002bcc <can_driver_init+0x28c>)
 8002968:	f040 812c 	bne.w	8002bc4 <can_driver_init+0x284>
 800296c:	4b98      	ldr	r3, [pc, #608]	; (8002bd0 <can_driver_init+0x290>)
 800296e:	6030      	str	r0, [r6, #0]
 8002970:	6b37      	ldr	r7, [r6, #48]	; 0x30
 8002972:	6023      	str	r3, [r4, #0]
 8002974:	f8df 8254 	ldr.w	r8, [pc, #596]	; 8002bcc <can_driver_init+0x28c>
 8002978:	b1bf      	cbz	r7, 80029aa <can_driver_init+0x6a>
 800297a:	2300      	movs	r3, #0
 800297c:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
 8002980:	62e3      	str	r3, [r4, #44]	; 0x2c
 8002982:	63e3      	str	r3, [r4, #60]	; 0x3c
 8002984:	f8da 3004 	ldr.w	r3, [sl, #4]
 8002988:	7968      	ldrb	r0, [r5, #5]
 800298a:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
 800298e:	f8da 3008 	ldr.w	r3, [sl, #8]
 8002992:	7929      	ldrb	r1, [r5, #4]
 8002994:	6323      	str	r3, [r4, #48]	; 0x30
 8002996:	f8da 300c 	ldr.w	r3, [sl, #12]
 800299a:	6423      	str	r3, [r4, #64]	; 0x40
 800299c:	f000 fae8 	bl	8002f70 <can_driver_port>
 80029a0:	b300      	cbz	r0, 80029e4 <can_driver_init+0xa4>
 80029a2:	380a      	subs	r0, #10
 80029a4:	f884 0090 	strb.w	r0, [r4, #144]	; 0x90
 80029a8:	e109      	b.n	8002bbe <can_driver_init+0x27e>
 80029aa:	f8da 9000 	ldr.w	r9, [sl]
 80029ae:	f1b9 0f00 	cmp.w	r9, #0
 80029b2:	d0e2      	beq.n	800297a <can_driver_init+0x3a>
 80029b4:	4648      	mov	r0, r9
 80029b6:	2118      	movs	r1, #24
 80029b8:	f8c8 9030 	str.w	r9, [r8, #48]	; 0x30
 80029bc:	f8c8 9008 	str.w	r9, [r8, #8]
 80029c0:	f000 fd1a 	bl	80033f8 <calloc>
 80029c4:	b908      	cbnz	r0, 80029ca <can_driver_init+0x8a>
 80029c6:	23fe      	movs	r3, #254	; 0xfe
 80029c8:	e098      	b.n	8002afc <can_driver_init+0x1bc>
 80029ca:	463b      	mov	r3, r7
 80029cc:	f108 0818 	add.w	r8, r8, #24
 80029d0:	3301      	adds	r3, #1
 80029d2:	454b      	cmp	r3, r9
 80029d4:	f8c8 0010 	str.w	r0, [r8, #16]
 80029d8:	f100 0218 	add.w	r2, r0, #24
 80029dc:	4680      	mov	r8, r0
 80029de:	d0cc      	beq.n	800297a <can_driver_init+0x3a>
 80029e0:	4610      	mov	r0, r2
 80029e2:	e7f5      	b.n	80029d0 <can_driver_init+0x90>
 80029e4:	6822      	ldr	r2, [r4, #0]
 80029e6:	6813      	ldr	r3, [r2, #0]
 80029e8:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80029ec:	6013      	str	r3, [r2, #0]
 80029ee:	7aeb      	ldrb	r3, [r5, #11]
 80029f0:	6822      	ldr	r2, [r4, #0]
 80029f2:	2b00      	cmp	r3, #0
 80029f4:	bf14      	ite	ne
 80029f6:	f04f 1301 	movne.w	r3, #65537	; 0x10001
 80029fa:	2301      	moveq	r3, #1
 80029fc:	6013      	str	r3, [r2, #0]
 80029fe:	6821      	ldr	r1, [r4, #0]
 8002a00:	4b74      	ldr	r3, [pc, #464]	; (8002bd4 <can_driver_init+0x294>)
 8002a02:	1d0a      	adds	r2, r1, #4
 8002a04:	6810      	ldr	r0, [r2, #0]
 8002a06:	07c0      	lsls	r0, r0, #31
 8002a08:	d403      	bmi.n	8002a12 <can_driver_init+0xd2>
 8002a0a:	f113 33ff 	adds.w	r3, r3, #4294967295
 8002a0e:	d2f9      	bcs.n	8002a04 <can_driver_init+0xc4>
 8002a10:	e002      	b.n	8002a18 <can_driver_init+0xd8>
 8002a12:	b90b      	cbnz	r3, 8002a18 <can_driver_init+0xd8>
 8002a14:	23fa      	movs	r3, #250	; 0xfa
 8002a16:	e071      	b.n	8002afc <can_driver_init+0x1bc>
 8002a18:	7aab      	ldrb	r3, [r5, #10]
 8002a1a:	7a6a      	ldrb	r2, [r5, #9]
 8002a1c:	3301      	adds	r3, #1
 8002a1e:	4413      	add	r3, r2
 8002a20:	4a6d      	ldr	r2, [pc, #436]	; (8002bd8 <can_driver_init+0x298>)
 8002a22:	6812      	ldr	r2, [r2, #0]
 8002a24:	fbb2 f3f3 	udiv	r3, r2, r3
 8002a28:	682a      	ldr	r2, [r5, #0]
 8002a2a:	fbb3 f3f2 	udiv	r3, r3, r2
 8002a2e:	79aa      	ldrb	r2, [r5, #6]
 8002a30:	3b01      	subs	r3, #1
 8002a32:	3200      	adds	r2, #0
 8002a34:	bf18      	it	ne
 8002a36:	2201      	movne	r2, #1
 8002a38:	07d2      	lsls	r2, r2, #31
 8002a3a:	61ca      	str	r2, [r1, #28]
 8002a3c:	6820      	ldr	r0, [r4, #0]
 8002a3e:	79ea      	ldrb	r2, [r5, #7]
 8002a40:	69c1      	ldr	r1, [r0, #28]
 8002a42:	3200      	adds	r2, #0
 8002a44:	bf18      	it	ne
 8002a46:	2201      	movne	r2, #1
 8002a48:	ea41 7282 	orr.w	r2, r1, r2, lsl #30
 8002a4c:	61c2      	str	r2, [r0, #28]
 8002a4e:	6820      	ldr	r0, [r4, #0]
 8002a50:	7a2a      	ldrb	r2, [r5, #8]
 8002a52:	69c1      	ldr	r1, [r0, #28]
 8002a54:	3a01      	subs	r2, #1
 8002a56:	f002 0203 	and.w	r2, r2, #3
 8002a5a:	ea41 6202 	orr.w	r2, r1, r2, lsl #24
 8002a5e:	61c2      	str	r2, [r0, #28]
 8002a60:	6820      	ldr	r0, [r4, #0]
 8002a62:	7a6a      	ldrb	r2, [r5, #9]
 8002a64:	69c1      	ldr	r1, [r0, #28]
 8002a66:	3a01      	subs	r2, #1
 8002a68:	f002 0207 	and.w	r2, r2, #7
 8002a6c:	ea41 5202 	orr.w	r2, r1, r2, lsl #20
 8002a70:	61c2      	str	r2, [r0, #28]
 8002a72:	6820      	ldr	r0, [r4, #0]
 8002a74:	7aaa      	ldrb	r2, [r5, #10]
 8002a76:	69c1      	ldr	r1, [r0, #28]
 8002a78:	3a01      	subs	r2, #1
 8002a7a:	f002 020f 	and.w	r2, r2, #15
 8002a7e:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
 8002a82:	61c2      	str	r2, [r0, #28]
 8002a84:	6821      	ldr	r1, [r4, #0]
 8002a86:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8002a8a:	69ca      	ldr	r2, [r1, #28]
 8002a8c:	4313      	orrs	r3, r2
 8002a8e:	61cb      	str	r3, [r1, #28]
 8002a90:	6822      	ldr	r2, [r4, #0]
 8002a92:	6813      	ldr	r3, [r2, #0]
 8002a94:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
 8002a98:	6013      	str	r3, [r2, #0]
 8002a9a:	6821      	ldr	r1, [r4, #0]
 8002a9c:	7b2b      	ldrb	r3, [r5, #12]
 8002a9e:	680a      	ldr	r2, [r1, #0]
 8002aa0:	3300      	adds	r3, #0
 8002aa2:	bf18      	it	ne
 8002aa4:	2301      	movne	r3, #1
 8002aa6:	ea42 13c3 	orr.w	r3, r2, r3, lsl #7
 8002aaa:	600b      	str	r3, [r1, #0]
 8002aac:	6821      	ldr	r1, [r4, #0]
 8002aae:	680a      	ldr	r2, [r1, #0]
 8002ab0:	7b6b      	ldrb	r3, [r5, #13]
 8002ab2:	3300      	adds	r3, #0
 8002ab4:	bf18      	it	ne
 8002ab6:	2301      	movne	r3, #1
 8002ab8:	ea42 1383 	orr.w	r3, r2, r3, lsl #6
 8002abc:	600b      	str	r3, [r1, #0]
 8002abe:	6821      	ldr	r1, [r4, #0]
 8002ac0:	7bab      	ldrb	r3, [r5, #14]
 8002ac2:	680a      	ldr	r2, [r1, #0]
 8002ac4:	3300      	adds	r3, #0
 8002ac6:	bf18      	it	ne
 8002ac8:	2301      	movne	r3, #1
 8002aca:	ea42 1343 	orr.w	r3, r2, r3, lsl #5
 8002ace:	600b      	str	r3, [r1, #0]
 8002ad0:	6822      	ldr	r2, [r4, #0]
 8002ad2:	6813      	ldr	r3, [r2, #0]
 8002ad4:	f043 0310 	orr.w	r3, r3, #16
 8002ad8:	6013      	str	r3, [r2, #0]
 8002ada:	6822      	ldr	r2, [r4, #0]
 8002adc:	6813      	ldr	r3, [r2, #0]
 8002ade:	f023 0301 	bic.w	r3, r3, #1
 8002ae2:	6013      	str	r3, [r2, #0]
 8002ae4:	6823      	ldr	r3, [r4, #0]
 8002ae6:	1d1a      	adds	r2, r3, #4
 8002ae8:	4b3a      	ldr	r3, [pc, #232]	; (8002bd4 <can_driver_init+0x294>)
 8002aea:	6811      	ldr	r1, [r2, #0]
 8002aec:	07c9      	lsls	r1, r1, #31
 8002aee:	d503      	bpl.n	8002af8 <can_driver_init+0x1b8>
 8002af0:	f113 33ff 	adds.w	r3, r3, #4294967295
 8002af4:	d2f9      	bcs.n	8002aea <can_driver_init+0x1aa>
 8002af6:	e004      	b.n	8002b02 <can_driver_init+0x1c2>
 8002af8:	b91b      	cbnz	r3, 8002b02 <can_driver_init+0x1c2>
 8002afa:	23f9      	movs	r3, #249	; 0xf9
 8002afc:	f884 3090 	strb.w	r3, [r4, #144]	; 0x90
 8002b00:	e05d      	b.n	8002bbe <can_driver_init+0x27e>
 8002b02:	692a      	ldr	r2, [r5, #16]
 8002b04:	6969      	ldr	r1, [r5, #20]
 8002b06:	f022 0303 	bic.w	r3, r2, #3
 8002b0a:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 8002b0e:	f002 0203 	and.w	r2, r2, #3
 8002b12:	f503 4364 	add.w	r3, r3, #58368	; 0xe400
 8002b16:	00d2      	lsls	r2, r2, #3
 8002b18:	4091      	lsls	r1, r2
 8002b1a:	681a      	ldr	r2, [r3, #0]
 8002b1c:	4311      	orrs	r1, r2
 8002b1e:	6019      	str	r1, [r3, #0]
 8002b20:	692a      	ldr	r2, [r5, #16]
 8002b22:	0953      	lsrs	r3, r2, #5
 8002b24:	f103 2338 	add.w	r3, r3, #939538432	; 0x38003800
 8002b28:	3340      	adds	r3, #64	; 0x40
 8002b2a:	009b      	lsls	r3, r3, #2
 8002b2c:	6818      	ldr	r0, [r3, #0]
 8002b2e:	f002 011f 	and.w	r1, r2, #31
 8002b32:	2201      	movs	r2, #1
 8002b34:	fa02 f101 	lsl.w	r1, r2, r1
 8002b38:	4301      	orrs	r1, r0
 8002b3a:	6019      	str	r1, [r3, #0]
 8002b3c:	69a9      	ldr	r1, [r5, #24]
 8002b3e:	69e8      	ldr	r0, [r5, #28]
 8002b40:	f021 0303 	bic.w	r3, r1, #3
 8002b44:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 8002b48:	f001 0103 	and.w	r1, r1, #3
 8002b4c:	f503 4364 	add.w	r3, r3, #58368	; 0xe400
 8002b50:	00c9      	lsls	r1, r1, #3
 8002b52:	4088      	lsls	r0, r1
 8002b54:	6819      	ldr	r1, [r3, #0]
 8002b56:	4308      	orrs	r0, r1
 8002b58:	6018      	str	r0, [r3, #0]
 8002b5a:	69a9      	ldr	r1, [r5, #24]
 8002b5c:	094b      	lsrs	r3, r1, #5
 8002b5e:	f103 2338 	add.w	r3, r3, #939538432	; 0x38003800
 8002b62:	3340      	adds	r3, #64	; 0x40
 8002b64:	009b      	lsls	r3, r3, #2
 8002b66:	6818      	ldr	r0, [r3, #0]
 8002b68:	f001 011f 	and.w	r1, r1, #31
 8002b6c:	fa02 f101 	lsl.w	r1, r2, r1
 8002b70:	4301      	orrs	r1, r0
 8002b72:	6019      	str	r1, [r3, #0]
 8002b74:	6a29      	ldr	r1, [r5, #32]
 8002b76:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8002b78:	f021 0303 	bic.w	r3, r1, #3
 8002b7c:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 8002b80:	f001 0103 	and.w	r1, r1, #3
 8002b84:	f503 4364 	add.w	r3, r3, #58368	; 0xe400
 8002b88:	00c9      	lsls	r1, r1, #3
 8002b8a:	4088      	lsls	r0, r1
 8002b8c:	6819      	ldr	r1, [r3, #0]
 8002b8e:	4308      	orrs	r0, r1
 8002b90:	6018      	str	r0, [r3, #0]
 8002b92:	6a29      	ldr	r1, [r5, #32]
 8002b94:	094b      	lsrs	r3, r1, #5
 8002b96:	f103 2338 	add.w	r3, r3, #939538432	; 0x38003800
 8002b9a:	3340      	adds	r3, #64	; 0x40
 8002b9c:	009b      	lsls	r3, r3, #2
 8002b9e:	f001 011f 	and.w	r1, r1, #31
 8002ba2:	408a      	lsls	r2, r1
 8002ba4:	6819      	ldr	r1, [r3, #0]
 8002ba6:	430a      	orrs	r2, r1
 8002ba8:	601a      	str	r2, [r3, #0]
 8002baa:	6823      	ldr	r3, [r4, #0]
 8002bac:	689a      	ldr	r2, [r3, #8]
 8002bae:	0152      	lsls	r2, r2, #5
 8002bb0:	d402      	bmi.n	8002bb8 <can_driver_init+0x278>
 8002bb2:	2201      	movs	r2, #1
 8002bb4:	609a      	str	r2, [r3, #8]
 8002bb6:	e7f8      	b.n	8002baa <can_driver_init+0x26a>
 8002bb8:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8002bbc:	6373      	str	r3, [r6, #52]	; 0x34
 8002bbe:	4620      	mov	r0, r4
 8002bc0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8002bc4:	6070      	str	r0, [r6, #4]
 8002bc6:	4b05      	ldr	r3, [pc, #20]	; (8002bdc <can_driver_init+0x29c>)
 8002bc8:	e6d2      	b.n	8002970 <can_driver_init+0x30>
 8002bca:	bf00      	nop
 8002bcc:	200015f8 	.word	0x200015f8
 8002bd0:	40006400 	.word	0x40006400
 8002bd4:	005b8d80 	.word	0x005b8d80
 8002bd8:	20000dd4 	.word	0x20000dd4
 8002bdc:	40006800 	.word	0x40006800

08002be0 <can_driver_enable_interrupts>:
 8002be0:	4b09      	ldr	r3, [pc, #36]	; (8002c08 <can_driver_enable_interrupts+0x28>)
 8002be2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002be4:	b163      	cbz	r3, 8002c00 <can_driver_enable_interrupts+0x20>
 8002be6:	4a09      	ldr	r2, [pc, #36]	; (8002c0c <can_driver_enable_interrupts+0x2c>)
 8002be8:	2000      	movs	r0, #0
 8002bea:	6813      	ldr	r3, [r2, #0]
 8002bec:	f043 0313 	orr.w	r3, r3, #19
 8002bf0:	6013      	str	r3, [r2, #0]
 8002bf2:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
 8002bf6:	f043 0313 	orr.w	r3, r3, #19
 8002bfa:	f8c2 3400 	str.w	r3, [r2, #1024]	; 0x400
 8002bfe:	4770      	bx	lr
 8002c00:	f04f 30ff 	mov.w	r0, #4294967295
 8002c04:	4770      	bx	lr
 8002c06:	bf00      	nop
 8002c08:	200015f8 	.word	0x200015f8
 8002c0c:	40006414 	.word	0x40006414

08002c10 <can_driver_toss0>:
 8002c10:	3024      	adds	r0, #36	; 0x24
 8002c12:	e635      	b.n	8002880 <can_driver_toss>

08002c14 <can_driver_toss1>:
 8002c14:	3034      	adds	r0, #52	; 0x34
 8002c16:	e633      	b.n	8002880 <can_driver_toss>

08002c18 <can_driver_peek0>:
 8002c18:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8002c1a:	b113      	cbz	r3, 8002c22 <can_driver_peek0+0xa>
 8002c1c:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8002c1e:	6918      	ldr	r0, [r3, #16]
 8002c20:	4770      	bx	lr
 8002c22:	4618      	mov	r0, r3
 8002c24:	4770      	bx	lr

08002c26 <can_driver_peek1>:
 8002c26:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8002c28:	b133      	cbz	r3, 8002c38 <can_driver_peek1+0x12>
 8002c2a:	4a04      	ldr	r2, [pc, #16]	; (8002c3c <can_driver_peek1+0x16>)
 8002c2c:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8002c2e:	3301      	adds	r3, #1
 8002c30:	6393      	str	r3, [r2, #56]	; 0x38
 8002c32:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8002c34:	6918      	ldr	r0, [r3, #16]
 8002c36:	4770      	bx	lr
 8002c38:	4618      	mov	r0, r3
 8002c3a:	4770      	bx	lr
 8002c3c:	200015f8 	.word	0x200015f8

08002c40 <can_driver_put>:
 8002c40:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 8002c44:	4691      	mov	r9, r2
 8002c46:	680a      	ldr	r2, [r1, #0]
 8002c48:	4604      	mov	r4, r0
 8002c4a:	0750      	lsls	r0, r2, #29
 8002c4c:	460f      	mov	r7, r1
 8002c4e:	4698      	mov	r8, r3
 8002c50:	d40a      	bmi.n	8002c68 <can_driver_put+0x28>
 8002c52:	4b40      	ldr	r3, [pc, #256]	; (8002d54 <can_driver_put+0x114>)
 8002c54:	4013      	ands	r3, r2
 8002c56:	b13b      	cbz	r3, 8002c68 <can_driver_put+0x28>
 8002c58:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 8002c5c:	f06f 0001 	mvn.w	r0, #1
 8002c60:	3301      	adds	r3, #1
 8002c62:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
 8002c66:	e072      	b.n	8002d4e <can_driver_put+0x10e>
 8002c68:	4e3b      	ldr	r6, [pc, #236]	; (8002d58 <can_driver_put+0x118>)
 8002c6a:	4668      	mov	r0, sp
 8002c6c:	f7ff fdc8 	bl	8002800 <disable_ints>
 8002c70:	6ab5      	ldr	r5, [r6, #40]	; 0x28
 8002c72:	b12d      	cbz	r5, 8002c80 <can_driver_put+0x40>
 8002c74:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
 8002c78:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 8002c7c:	429a      	cmp	r2, r3
 8002c7e:	db08      	blt.n	8002c92 <can_driver_put+0x52>
 8002c80:	4668      	mov	r0, sp
 8002c82:	f7ff fdef 	bl	8002864 <reenable_ints>
 8002c86:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8002c88:	f04f 30ff 	mov.w	r0, #4294967295
 8002c8c:	3301      	adds	r3, #1
 8002c8e:	6563      	str	r3, [r4, #84]	; 0x54
 8002c90:	e05d      	b.n	8002d4e <can_driver_put+0x10e>
 8002c92:	692b      	ldr	r3, [r5, #16]
 8002c94:	4668      	mov	r0, sp
 8002c96:	62b3      	str	r3, [r6, #40]	; 0x28
 8002c98:	68b3      	ldr	r3, [r6, #8]
 8002c9a:	3b01      	subs	r3, #1
 8002c9c:	60b3      	str	r3, [r6, #8]
 8002c9e:	f7ff fde1 	bl	8002864 <reenable_ints>
 8002ca2:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
 8002ca6:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
 8002caa:	2300      	movs	r3, #0
 8002cac:	4a2b      	ldr	r2, [pc, #172]	; (8002d5c <can_driver_put+0x11c>)
 8002cae:	f885 9015 	strb.w	r9, [r5, #21]
 8002cb2:	f885 8016 	strb.w	r8, [r5, #22]
 8002cb6:	75eb      	strb	r3, [r5, #23]
 8002cb8:	752b      	strb	r3, [r5, #20]
 8002cba:	6813      	ldr	r3, [r2, #0]
 8002cbc:	6830      	ldr	r0, [r6, #0]
 8002cbe:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8002cc2:	9300      	str	r3, [sp, #0]
 8002cc4:	4b26      	ldr	r3, [pc, #152]	; (8002d60 <can_driver_put+0x120>)
 8002cc6:	6819      	ldr	r1, [r3, #0]
 8002cc8:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8002ccc:	9101      	str	r1, [sp, #4]
 8002cce:	6811      	ldr	r1, [r2, #0]
 8002cd0:	f021 0101 	bic.w	r1, r1, #1
 8002cd4:	6011      	str	r1, [r2, #0]
 8002cd6:	6819      	ldr	r1, [r3, #0]
 8002cd8:	f021 0101 	bic.w	r1, r1, #1
 8002cdc:	6019      	str	r1, [r3, #0]
 8002cde:	6811      	ldr	r1, [r2, #0]
 8002ce0:	07c9      	lsls	r1, r1, #31
 8002ce2:	d505      	bpl.n	8002cf0 <can_driver_put+0xb0>
 8002ce4:	f8d0 1080 	ldr.w	r1, [r0, #128]	; 0x80
 8002ce8:	3101      	adds	r1, #1
 8002cea:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
 8002cee:	e7f6      	b.n	8002cde <can_driver_put+0x9e>
 8002cf0:	6871      	ldr	r1, [r6, #4]
 8002cf2:	681a      	ldr	r2, [r3, #0]
 8002cf4:	07d2      	lsls	r2, r2, #31
 8002cf6:	d505      	bpl.n	8002d04 <can_driver_put+0xc4>
 8002cf8:	f8d1 2080 	ldr.w	r2, [r1, #128]	; 0x80
 8002cfc:	3201      	adds	r2, #1
 8002cfe:	f8c1 2080 	str.w	r2, [r1, #128]	; 0x80
 8002d02:	e7f6      	b.n	8002cf2 <can_driver_put+0xb2>
 8002d04:	f104 0308 	add.w	r3, r4, #8
 8002d08:	691a      	ldr	r2, [r3, #16]
 8002d0a:	b122      	cbz	r2, 8002d16 <can_driver_put+0xd6>
 8002d0c:	6829      	ldr	r1, [r5, #0]
 8002d0e:	691a      	ldr	r2, [r3, #16]
 8002d10:	6812      	ldr	r2, [r2, #0]
 8002d12:	4291      	cmp	r1, r2
 8002d14:	d208      	bcs.n	8002d28 <can_driver_put+0xe8>
 8002d16:	691a      	ldr	r2, [r3, #16]
 8002d18:	612a      	str	r2, [r5, #16]
 8002d1a:	611d      	str	r5, [r3, #16]
 8002d1c:	6a23      	ldr	r3, [r4, #32]
 8002d1e:	b92b      	cbnz	r3, 8002d2c <can_driver_put+0xec>
 8002d20:	4620      	mov	r0, r4
 8002d22:	f7ff fdd5 	bl	80028d0 <loadmbx2>
 8002d26:	e009      	b.n	8002d3c <can_driver_put+0xfc>
 8002d28:	691b      	ldr	r3, [r3, #16]
 8002d2a:	e7ed      	b.n	8002d08 <can_driver_put+0xc8>
 8002d2c:	6a23      	ldr	r3, [r4, #32]
 8002d2e:	691b      	ldr	r3, [r3, #16]
 8002d30:	42ab      	cmp	r3, r5
 8002d32:	bf01      	itttt	eq
 8002d34:	6e63      	ldreq	r3, [r4, #100]	; 0x64
 8002d36:	6225      	streq	r5, [r4, #32]
 8002d38:	3301      	addeq	r3, #1
 8002d3a:	6663      	streq	r3, [r4, #100]	; 0x64
 8002d3c:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
 8002d40:	4668      	mov	r0, sp
 8002d42:	3301      	adds	r3, #1
 8002d44:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
 8002d48:	f7ff fd8c 	bl	8002864 <reenable_ints>
 8002d4c:	2000      	movs	r0, #0
 8002d4e:	b003      	add	sp, #12
 8002d50:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8002d54:	001ffff8 	.word	0x001ffff8
 8002d58:	200015f8 	.word	0x200015f8
 8002d5c:	40006414 	.word	0x40006414
 8002d60:	40006814 	.word	0x40006814

08002d64 <can_driver_getcount>:
 8002d64:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8002d66:	4606      	mov	r6, r0
 8002d68:	4668      	mov	r0, sp
 8002d6a:	460d      	mov	r5, r1
 8002d6c:	4614      	mov	r4, r2
 8002d6e:	f7ff fd47 	bl	8002800 <disable_ints>
 8002d72:	b136      	cbz	r6, 8002d82 <can_driver_getcount+0x1e>
 8002d74:	f8d6 3084 	ldr.w	r3, [r6, #132]	; 0x84
 8002d78:	6023      	str	r3, [r4, #0]
 8002d7a:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8002d7c:	6063      	str	r3, [r4, #4]
 8002d7e:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
 8002d80:	60a3      	str	r3, [r4, #8]
 8002d82:	b135      	cbz	r5, 8002d92 <can_driver_getcount+0x2e>
 8002d84:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
 8002d88:	60e3      	str	r3, [r4, #12]
 8002d8a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8002d8c:	6123      	str	r3, [r4, #16]
 8002d8e:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8002d90:	6163      	str	r3, [r4, #20]
 8002d92:	4668      	mov	r0, sp
 8002d94:	f7ff fd66 	bl	8002864 <reenable_ints>
 8002d98:	4b01      	ldr	r3, [pc, #4]	; (8002da0 <can_driver_getcount+0x3c>)
 8002d9a:	6898      	ldr	r0, [r3, #8]
 8002d9c:	b002      	add	sp, #8
 8002d9e:	bd70      	pop	{r4, r5, r6, pc}
 8002da0:	200015f8 	.word	0x200015f8

08002da4 <CAN_TX_IRQHandler>:
 8002da4:	6802      	ldr	r2, [r0, #0]
 8002da6:	4b24      	ldr	r3, [pc, #144]	; (8002e38 <CAN_TX_IRQHandler+0x94>)
 8002da8:	6891      	ldr	r1, [r2, #8]
 8002daa:	b510      	push	{r4, lr}
 8002dac:	400b      	ands	r3, r1
 8002dae:	4604      	mov	r4, r0
 8002db0:	b12b      	cbz	r3, 8002dbe <CAN_TX_IRQHandler+0x1a>
 8002db2:	4b21      	ldr	r3, [pc, #132]	; (8002e38 <CAN_TX_IRQHandler+0x94>)
 8002db4:	6093      	str	r3, [r2, #8]
 8002db6:	6f03      	ldr	r3, [r0, #112]	; 0x70
 8002db8:	3301      	adds	r3, #1
 8002dba:	6703      	str	r3, [r0, #112]	; 0x70
 8002dbc:	e039      	b.n	8002e32 <CAN_TX_IRQHandler+0x8e>
 8002dbe:	2101      	movs	r1, #1
 8002dc0:	6893      	ldr	r3, [r2, #8]
 8002dc2:	6091      	str	r1, [r2, #8]
 8002dc4:	6982      	ldr	r2, [r0, #24]
 8002dc6:	b91a      	cbnz	r2, 8002dd0 <CAN_TX_IRQHandler+0x2c>
 8002dc8:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
 8002dca:	440b      	add	r3, r1
 8002dcc:	67c3      	str	r3, [r0, #124]	; 0x7c
 8002dce:	bd10      	pop	{r4, pc}
 8002dd0:	07d9      	lsls	r1, r3, #31
 8002dd2:	d52e      	bpl.n	8002e32 <CAN_TX_IRQHandler+0x8e>
 8002dd4:	079a      	lsls	r2, r3, #30
 8002dd6:	d415      	bmi.n	8002e04 <CAN_TX_IRQHandler+0x60>
 8002dd8:	0719      	lsls	r1, r3, #28
 8002dda:	d516      	bpl.n	8002e0a <CAN_TX_IRQHandler+0x66>
 8002ddc:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8002dde:	3301      	adds	r3, #1
 8002de0:	6443      	str	r3, [r0, #68]	; 0x44
 8002de2:	6a03      	ldr	r3, [r0, #32]
 8002de4:	691a      	ldr	r2, [r3, #16]
 8002de6:	7d13      	ldrb	r3, [r2, #20]
 8002de8:	3301      	adds	r3, #1
 8002dea:	b2db      	uxtb	r3, r3
 8002dec:	7513      	strb	r3, [r2, #20]
 8002dee:	6a03      	ldr	r3, [r0, #32]
 8002df0:	691b      	ldr	r3, [r3, #16]
 8002df2:	7d1a      	ldrb	r2, [r3, #20]
 8002df4:	6a03      	ldr	r3, [r0, #32]
 8002df6:	691b      	ldr	r3, [r3, #16]
 8002df8:	7d5b      	ldrb	r3, [r3, #21]
 8002dfa:	429a      	cmp	r2, r3
 8002dfc:	d916      	bls.n	8002e2c <CAN_TX_IRQHandler+0x88>
 8002dfe:	6c83      	ldr	r3, [r0, #72]	; 0x48
 8002e00:	3301      	adds	r3, #1
 8002e02:	6483      	str	r3, [r0, #72]	; 0x48
 8002e04:	f7ff fd7e 	bl	8002904 <moveremove2>
 8002e08:	e010      	b.n	8002e2c <CAN_TX_IRQHandler+0x88>
 8002e0a:	075a      	lsls	r2, r3, #29
 8002e0c:	d50b      	bpl.n	8002e26 <CAN_TX_IRQHandler+0x82>
 8002e0e:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8002e10:	3301      	adds	r3, #1
 8002e12:	64c3      	str	r3, [r0, #76]	; 0x4c
 8002e14:	6a03      	ldr	r3, [r0, #32]
 8002e16:	691b      	ldr	r3, [r3, #16]
 8002e18:	7d9b      	ldrb	r3, [r3, #22]
 8002e1a:	07db      	lsls	r3, r3, #31
 8002e1c:	d506      	bpl.n	8002e2c <CAN_TX_IRQHandler+0x88>
 8002e1e:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8002e20:	3301      	adds	r3, #1
 8002e22:	6503      	str	r3, [r0, #80]	; 0x50
 8002e24:	e7ee      	b.n	8002e04 <CAN_TX_IRQHandler+0x60>
 8002e26:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 8002e28:	3301      	adds	r3, #1
 8002e2a:	65c3      	str	r3, [r0, #92]	; 0x5c
 8002e2c:	4620      	mov	r0, r4
 8002e2e:	f7ff fd4f 	bl	80028d0 <loadmbx2>
 8002e32:	6823      	ldr	r3, [r4, #0]
 8002e34:	689b      	ldr	r3, [r3, #8]
 8002e36:	bd10      	pop	{r4, pc}
 8002e38:	00010100 	.word	0x00010100

08002e3c <CAN_RX_IRQHandler>:
 8002e3c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 8002e40:	4680      	mov	r8, r0
 8002e42:	460d      	mov	r5, r1
 8002e44:	6803      	ldr	r3, [r0, #0]
 8002e46:	681e      	ldr	r6, [r3, #0]
 8002e48:	4b2d      	ldr	r3, [pc, #180]	; (8002f00 <CAN_RX_IRQHandler+0xc4>)
 8002e4a:	f8d3 9000 	ldr.w	r9, [r3]
 8002e4e:	6832      	ldr	r2, [r6, #0]
 8002e50:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8002e54:	4f2b      	ldr	r7, [pc, #172]	; (8002f04 <CAN_RX_IRQHandler+0xc8>)
 8002e56:	4413      	add	r3, r2
 8002e58:	68db      	ldr	r3, [r3, #12]
 8002e5a:	f013 0f03 	tst.w	r3, #3
 8002e5e:	d049      	beq.n	8002ef4 <CAN_RX_IRQHandler+0xb8>
 8002e60:	4668      	mov	r0, sp
 8002e62:	f7ff fccd 	bl	8002800 <disable_ints>
 8002e66:	6abc      	ldr	r4, [r7, #40]	; 0x28
 8002e68:	b11c      	cbz	r4, 8002e72 <CAN_RX_IRQHandler+0x36>
 8002e6a:	68ab      	ldr	r3, [r5, #8]
 8002e6c:	68ea      	ldr	r2, [r5, #12]
 8002e6e:	4293      	cmp	r3, r2
 8002e70:	db0c      	blt.n	8002e8c <CAN_RX_IRQHandler+0x50>
 8002e72:	6832      	ldr	r2, [r6, #0]
 8002e74:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8002e78:	4668      	mov	r0, sp
 8002e7a:	4413      	add	r3, r2
 8002e7c:	2220      	movs	r2, #32
 8002e7e:	60da      	str	r2, [r3, #12]
 8002e80:	6d73      	ldr	r3, [r6, #84]	; 0x54
 8002e82:	3301      	adds	r3, #1
 8002e84:	6573      	str	r3, [r6, #84]	; 0x54
 8002e86:	f7ff fced 	bl	8002864 <reenable_ints>
 8002e8a:	e036      	b.n	8002efa <CAN_RX_IRQHandler+0xbe>
 8002e8c:	6922      	ldr	r2, [r4, #16]
 8002e8e:	3301      	adds	r3, #1
 8002e90:	62ba      	str	r2, [r7, #40]	; 0x28
 8002e92:	68ba      	ldr	r2, [r7, #8]
 8002e94:	60ab      	str	r3, [r5, #8]
 8002e96:	3a01      	subs	r2, #1
 8002e98:	f8c4 9014 	str.w	r9, [r4, #20]
 8002e9c:	f8d8 1004 	ldr.w	r1, [r8, #4]
 8002ea0:	60ba      	str	r2, [r7, #8]
 8002ea2:	6832      	ldr	r2, [r6, #0]
 8002ea4:	188b      	adds	r3, r1, r2
 8002ea6:	588a      	ldr	r2, [r1, r2]
 8002ea8:	6022      	str	r2, [r4, #0]
 8002eaa:	685a      	ldr	r2, [r3, #4]
 8002eac:	6062      	str	r2, [r4, #4]
 8002eae:	689b      	ldr	r3, [r3, #8]
 8002eb0:	60a3      	str	r3, [r4, #8]
 8002eb2:	6832      	ldr	r2, [r6, #0]
 8002eb4:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8002eb8:	4413      	add	r3, r2
 8002eba:	68db      	ldr	r3, [r3, #12]
 8002ebc:	60e3      	str	r3, [r4, #12]
 8002ebe:	6832      	ldr	r2, [r6, #0]
 8002ec0:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8002ec4:	4413      	add	r3, r2
 8002ec6:	2220      	movs	r2, #32
 8002ec8:	60da      	str	r2, [r3, #12]
 8002eca:	682b      	ldr	r3, [r5, #0]
 8002ecc:	b913      	cbnz	r3, 8002ed4 <CAN_RX_IRQHandler+0x98>
 8002ece:	602c      	str	r4, [r5, #0]
 8002ed0:	6124      	str	r4, [r4, #16]
 8002ed2:	e005      	b.n	8002ee0 <CAN_RX_IRQHandler+0xa4>
 8002ed4:	682b      	ldr	r3, [r5, #0]
 8002ed6:	691b      	ldr	r3, [r3, #16]
 8002ed8:	6123      	str	r3, [r4, #16]
 8002eda:	682b      	ldr	r3, [r5, #0]
 8002edc:	611c      	str	r4, [r3, #16]
 8002ede:	602c      	str	r4, [r5, #0]
 8002ee0:	4668      	mov	r0, sp
 8002ee2:	f7ff fcbf 	bl	8002864 <reenable_ints>
 8002ee6:	686b      	ldr	r3, [r5, #4]
 8002ee8:	2b00      	cmp	r3, #0
 8002eea:	d0b0      	beq.n	8002e4e <CAN_RX_IRQHandler+0x12>
 8002eec:	4630      	mov	r0, r6
 8002eee:	4621      	mov	r1, r4
 8002ef0:	4798      	blx	r3
 8002ef2:	e7ac      	b.n	8002e4e <CAN_RX_IRQHandler+0x12>
 8002ef4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8002ef6:	3301      	adds	r3, #1
 8002ef8:	63fb      	str	r3, [r7, #60]	; 0x3c
 8002efa:	b003      	add	sp, #12
 8002efc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8002f00:	e0001004 	.word	0xe0001004
 8002f04:	200015f8 	.word	0x200015f8

08002f08 <CAN1_TX_IRQHandler>:
 8002f08:	4b01      	ldr	r3, [pc, #4]	; (8002f10 <CAN1_TX_IRQHandler+0x8>)
 8002f0a:	6818      	ldr	r0, [r3, #0]
 8002f0c:	f7ff bf4a 	b.w	8002da4 <CAN_TX_IRQHandler>
 8002f10:	200015f8 	.word	0x200015f8

08002f14 <CAN2_TX_IRQHandler>:
 8002f14:	4b01      	ldr	r3, [pc, #4]	; (8002f1c <CAN2_TX_IRQHandler+0x8>)
 8002f16:	6858      	ldr	r0, [r3, #4]
 8002f18:	f7ff bf44 	b.w	8002da4 <CAN_TX_IRQHandler>
 8002f1c:	200015f8 	.word	0x200015f8

08002f20 <CAN1_RX0_IRQHandler>:
 8002f20:	4b02      	ldr	r3, [pc, #8]	; (8002f2c <CAN1_RX0_IRQHandler+0xc>)
 8002f22:	4803      	ldr	r0, [pc, #12]	; (8002f30 <CAN1_RX0_IRQHandler+0x10>)
 8002f24:	6819      	ldr	r1, [r3, #0]
 8002f26:	3124      	adds	r1, #36	; 0x24
 8002f28:	f7ff bf88 	b.w	8002e3c <CAN_RX_IRQHandler>
 8002f2c:	200015f8 	.word	0x200015f8
 8002f30:	08003f08 	.word	0x08003f08

08002f34 <CAN1_RX1_IRQHandler>:
 8002f34:	4b02      	ldr	r3, [pc, #8]	; (8002f40 <CAN1_RX1_IRQHandler+0xc>)
 8002f36:	4803      	ldr	r0, [pc, #12]	; (8002f44 <CAN1_RX1_IRQHandler+0x10>)
 8002f38:	6819      	ldr	r1, [r3, #0]
 8002f3a:	3134      	adds	r1, #52	; 0x34
 8002f3c:	f7ff bf7e 	b.w	8002e3c <CAN_RX_IRQHandler>
 8002f40:	200015f8 	.word	0x200015f8
 8002f44:	08003f14 	.word	0x08003f14

08002f48 <CAN2_RX0_IRQHandler>:
 8002f48:	4b02      	ldr	r3, [pc, #8]	; (8002f54 <CAN2_RX0_IRQHandler+0xc>)
 8002f4a:	4803      	ldr	r0, [pc, #12]	; (8002f58 <CAN2_RX0_IRQHandler+0x10>)
 8002f4c:	6859      	ldr	r1, [r3, #4]
 8002f4e:	3124      	adds	r1, #36	; 0x24
 8002f50:	f7ff bf74 	b.w	8002e3c <CAN_RX_IRQHandler>
 8002f54:	200015f8 	.word	0x200015f8
 8002f58:	08003f20 	.word	0x08003f20

08002f5c <CAN2_RX1_IRQHandler>:
 8002f5c:	4b02      	ldr	r3, [pc, #8]	; (8002f68 <CAN2_RX1_IRQHandler+0xc>)
 8002f5e:	4803      	ldr	r0, [pc, #12]	; (8002f6c <CAN2_RX1_IRQHandler+0x10>)
 8002f60:	6859      	ldr	r1, [r3, #4]
 8002f62:	3134      	adds	r1, #52	; 0x34
 8002f64:	f7ff bf6a 	b.w	8002e3c <CAN_RX_IRQHandler>
 8002f68:	200015f8 	.word	0x200015f8
 8002f6c:	08003f2c 	.word	0x08003f2c

08002f70 <can_driver_port>:
 8002f70:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002f72:	2901      	cmp	r1, #1
 8002f74:	b08d      	sub	sp, #52	; 0x34
 8002f76:	4684      	mov	ip, r0
 8002f78:	d159      	bne.n	800302e <can_driver_port+0xbe>
 8002f7a:	4a30      	ldr	r2, [pc, #192]	; (800303c <can_driver_port+0xcc>)
 8002f7c:	ae02      	add	r6, sp, #8
 8002f7e:	6813      	ldr	r3, [r2, #0]
 8002f80:	af06      	add	r7, sp, #24
 8002f82:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8002f86:	6013      	str	r3, [r2, #0]
 8002f88:	f852 3c04 	ldr.w	r3, [r2, #-4]
 8002f8c:	ad08      	add	r5, sp, #32
 8002f8e:	f043 0301 	orr.w	r3, r3, #1
 8002f92:	f842 3c04 	str.w	r3, [r2, #-4]
 8002f96:	4b2a      	ldr	r3, [pc, #168]	; (8003040 <can_driver_port+0xd0>)
 8002f98:	ac0a      	add	r4, sp, #40	; 0x28
 8002f9a:	f103 0208 	add.w	r2, r3, #8
 8002f9e:	e893 0003 	ldmia.w	r3, {r0, r1}
 8002fa2:	e88d 0003 	stmia.w	sp, {r0, r1}
 8002fa6:	e892 0003 	ldmia.w	r2, {r0, r1}
 8002faa:	aa04      	add	r2, sp, #16
 8002fac:	e886 0003 	stmia.w	r6, {r0, r1}
 8002fb0:	f103 0110 	add.w	r1, r3, #16
 8002fb4:	c903      	ldmia	r1, {r0, r1}
 8002fb6:	e882 0003 	stmia.w	r2, {r0, r1}
 8002fba:	f103 0118 	add.w	r1, r3, #24
 8002fbe:	c903      	ldmia	r1, {r0, r1}
 8002fc0:	f1bc 0f01 	cmp.w	ip, #1
 8002fc4:	e887 0003 	stmia.w	r7, {r0, r1}
 8002fc8:	f103 0120 	add.w	r1, r3, #32
 8002fcc:	f103 0328 	add.w	r3, r3, #40	; 0x28
 8002fd0:	c903      	ldmia	r1, {r0, r1}
 8002fd2:	46ee      	mov	lr, sp
 8002fd4:	e885 0003 	stmia.w	r5, {r0, r1}
 8002fd8:	e893 0003 	ldmia.w	r3, {r0, r1}
 8002fdc:	e884 0003 	stmia.w	r4, {r0, r1}
 8002fe0:	d018      	beq.n	8003014 <can_driver_port+0xa4>
 8002fe2:	d30d      	bcc.n	8003000 <can_driver_port+0x90>
 8002fe4:	f1bc 0f02 	cmp.w	ip, #2
 8002fe8:	d124      	bne.n	8003034 <can_driver_port+0xc4>
 8002fea:	4610      	mov	r0, r2
 8002fec:	f7ff fad2 	bl	8002594 <pinconfig_all>
 8002ff0:	4620      	mov	r0, r4
 8002ff2:	f7ff facf 	bl	8002594 <pinconfig_all>
 8002ff6:	4a13      	ldr	r2, [pc, #76]	; (8003044 <can_driver_port+0xd4>)
 8002ff8:	6813      	ldr	r3, [r2, #0]
 8002ffa:	f443 43c0 	orr.w	r3, r3, #24576	; 0x6000
 8002ffe:	e013      	b.n	8003028 <can_driver_port+0xb8>
 8003000:	4668      	mov	r0, sp
 8003002:	f7ff fac7 	bl	8002594 <pinconfig_all>
 8003006:	4638      	mov	r0, r7
 8003008:	f7ff fac4 	bl	8002594 <pinconfig_all>
 800300c:	4b0d      	ldr	r3, [pc, #52]	; (8003044 <can_driver_port+0xd4>)
 800300e:	681a      	ldr	r2, [r3, #0]
 8003010:	601a      	str	r2, [r3, #0]
 8003012:	e00a      	b.n	800302a <can_driver_port+0xba>
 8003014:	4630      	mov	r0, r6
 8003016:	f7ff fabd 	bl	8002594 <pinconfig_all>
 800301a:	4628      	mov	r0, r5
 800301c:	f7ff faba 	bl	8002594 <pinconfig_all>
 8003020:	4a08      	ldr	r2, [pc, #32]	; (8003044 <can_driver_port+0xd4>)
 8003022:	6813      	ldr	r3, [r2, #0]
 8003024:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8003028:	6013      	str	r3, [r2, #0]
 800302a:	2000      	movs	r0, #0
 800302c:	e004      	b.n	8003038 <can_driver_port+0xc8>
 800302e:	f04f 30ff 	mov.w	r0, #4294967295
 8003032:	e001      	b.n	8003038 <can_driver_port+0xc8>
 8003034:	f06f 0001 	mvn.w	r0, #1
 8003038:	b00d      	add	sp, #52	; 0x34
 800303a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800303c:	4002101c 	.word	0x4002101c
 8003040:	08003f38 	.word	0x08003f38
 8003044:	40010004 	.word	0x40010004

08003048 <can_driver_filter_deactivate_one>:
 8003048:	281b      	cmp	r0, #27
 800304a:	d81c      	bhi.n	8003086 <can_driver_filter_deactivate_one+0x3e>
 800304c:	4b0f      	ldr	r3, [pc, #60]	; (800308c <can_driver_filter_deactivate_one+0x44>)
 800304e:	681a      	ldr	r2, [r3, #0]
 8003050:	07d2      	lsls	r2, r2, #31
 8003052:	d404      	bmi.n	800305e <can_driver_filter_deactivate_one+0x16>
 8003054:	681a      	ldr	r2, [r3, #0]
 8003056:	f042 0201 	orr.w	r2, r2, #1
 800305a:	601a      	str	r2, [r3, #0]
 800305c:	e7f6      	b.n	800304c <can_driver_filter_deactivate_one+0x4>
 800305e:	69d9      	ldr	r1, [r3, #28]
 8003060:	2201      	movs	r2, #1
 8003062:	4082      	lsls	r2, r0
 8003064:	ea21 0102 	bic.w	r1, r1, r2
 8003068:	61d9      	str	r1, [r3, #28]
 800306a:	69d9      	ldr	r1, [r3, #28]
 800306c:	430a      	orrs	r2, r1
 800306e:	61da      	str	r2, [r3, #28]
 8003070:	4b06      	ldr	r3, [pc, #24]	; (800308c <can_driver_filter_deactivate_one+0x44>)
 8003072:	6818      	ldr	r0, [r3, #0]
 8003074:	f010 0001 	ands.w	r0, r0, #1
 8003078:	d004      	beq.n	8003084 <can_driver_filter_deactivate_one+0x3c>
 800307a:	681a      	ldr	r2, [r3, #0]
 800307c:	f022 0201 	bic.w	r2, r2, #1
 8003080:	601a      	str	r2, [r3, #0]
 8003082:	e7f5      	b.n	8003070 <can_driver_filter_deactivate_one+0x28>
 8003084:	4770      	bx	lr
 8003086:	f04f 30ff 	mov.w	r0, #4294967295
 800308a:	4770      	bx	lr
 800308c:	40006600 	.word	0x40006600

08003090 <can_driver_filter_deactivate_all>:
 8003090:	4b0a      	ldr	r3, [pc, #40]	; (80030bc <can_driver_filter_deactivate_all+0x2c>)
 8003092:	681a      	ldr	r2, [r3, #0]
 8003094:	07d1      	lsls	r1, r2, #31
 8003096:	d404      	bmi.n	80030a2 <can_driver_filter_deactivate_all+0x12>
 8003098:	681a      	ldr	r2, [r3, #0]
 800309a:	f042 0201 	orr.w	r2, r2, #1
 800309e:	601a      	str	r2, [r3, #0]
 80030a0:	e7f6      	b.n	8003090 <can_driver_filter_deactivate_all>
 80030a2:	2200      	movs	r2, #0
 80030a4:	61da      	str	r2, [r3, #28]
 80030a6:	4b05      	ldr	r3, [pc, #20]	; (80030bc <can_driver_filter_deactivate_all+0x2c>)
 80030a8:	681a      	ldr	r2, [r3, #0]
 80030aa:	07d2      	lsls	r2, r2, #31
 80030ac:	d504      	bpl.n	80030b8 <can_driver_filter_deactivate_all+0x28>
 80030ae:	681a      	ldr	r2, [r3, #0]
 80030b0:	f022 0201 	bic.w	r2, r2, #1
 80030b4:	601a      	str	r2, [r3, #0]
 80030b6:	e7f6      	b.n	80030a6 <can_driver_filter_deactivate_all+0x16>
 80030b8:	4770      	bx	lr
 80030ba:	bf00      	nop
 80030bc:	40006600 	.word	0x40006600

080030c0 <can_driver_filter_setCAN2boundary>:
 80030c0:	281c      	cmp	r0, #28
 80030c2:	d81e      	bhi.n	8003102 <can_driver_filter_setCAN2boundary+0x42>
 80030c4:	4b10      	ldr	r3, [pc, #64]	; (8003108 <can_driver_filter_setCAN2boundary+0x48>)
 80030c6:	681a      	ldr	r2, [r3, #0]
 80030c8:	f012 0f01 	tst.w	r2, #1
 80030cc:	681a      	ldr	r2, [r3, #0]
 80030ce:	d103      	bne.n	80030d8 <can_driver_filter_setCAN2boundary+0x18>
 80030d0:	f042 0201 	orr.w	r2, r2, #1
 80030d4:	601a      	str	r2, [r3, #0]
 80030d6:	e7f5      	b.n	80030c4 <can_driver_filter_setCAN2boundary+0x4>
 80030d8:	f422 52f8 	bic.w	r2, r2, #7936	; 0x1f00
 80030dc:	601a      	str	r2, [r3, #0]
 80030de:	681a      	ldr	r2, [r3, #0]
 80030e0:	ea62 2200 	orn	r2, r2, r0, lsl #8
 80030e4:	601a      	str	r2, [r3, #0]
 80030e6:	4b09      	ldr	r3, [pc, #36]	; (800310c <can_driver_filter_setCAN2boundary+0x4c>)
 80030e8:	6018      	str	r0, [r3, #0]
 80030ea:	6058      	str	r0, [r3, #4]
 80030ec:	4b06      	ldr	r3, [pc, #24]	; (8003108 <can_driver_filter_setCAN2boundary+0x48>)
 80030ee:	6818      	ldr	r0, [r3, #0]
 80030f0:	f010 0001 	ands.w	r0, r0, #1
 80030f4:	d004      	beq.n	8003100 <can_driver_filter_setCAN2boundary+0x40>
 80030f6:	681a      	ldr	r2, [r3, #0]
 80030f8:	f022 0201 	bic.w	r2, r2, #1
 80030fc:	601a      	str	r2, [r3, #0]
 80030fe:	e7f5      	b.n	80030ec <can_driver_filter_setCAN2boundary+0x2c>
 8003100:	4770      	bx	lr
 8003102:	f04f 30ff 	mov.w	r0, #4294967295
 8003106:	4770      	bx	lr
 8003108:	40006600 	.word	0x40006600
 800310c:	20000510 	.word	0x20000510

08003110 <can_driver_filter_insert>:
 8003110:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003112:	7a43      	ldrb	r3, [r0, #9]
 8003114:	2b1b      	cmp	r3, #27
 8003116:	d87e      	bhi.n	8003216 <can_driver_filter_insert+0x106>
 8003118:	7a03      	ldrb	r3, [r0, #8]
 800311a:	2b07      	cmp	r3, #7
 800311c:	d87e      	bhi.n	800321c <can_driver_filter_insert+0x10c>
 800311e:	0899      	lsrs	r1, r3, #2
 8003120:	f3c3 0540 	ubfx	r5, r3, #1, #1
 8003124:	f003 0401 	and.w	r4, r3, #1
 8003128:	4b3f      	ldr	r3, [pc, #252]	; (8003228 <can_driver_filter_insert+0x118>)
 800312a:	681a      	ldr	r2, [r3, #0]
 800312c:	07d2      	lsls	r2, r2, #31
 800312e:	d404      	bmi.n	800313a <can_driver_filter_insert+0x2a>
 8003130:	681a      	ldr	r2, [r3, #0]
 8003132:	f042 0201 	orr.w	r2, r2, #1
 8003136:	601a      	str	r2, [r3, #0]
 8003138:	e7f6      	b.n	8003128 <can_driver_filter_insert+0x18>
 800313a:	4a3c      	ldr	r2, [pc, #240]	; (800322c <can_driver_filter_insert+0x11c>)
 800313c:	7a47      	ldrb	r7, [r0, #9]
 800313e:	6816      	ldr	r6, [r2, #0]
 8003140:	2301      	movs	r3, #1
 8003142:	fa03 f707 	lsl.w	r7, r3, r7
 8003146:	ea26 0607 	bic.w	r6, r6, r7
 800314a:	6016      	str	r6, [r2, #0]
 800314c:	7a47      	ldrb	r7, [r0, #9]
 800314e:	6816      	ldr	r6, [r2, #0]
 8003150:	40b9      	lsls	r1, r7
 8003152:	4331      	orrs	r1, r6
 8003154:	6011      	str	r1, [r2, #0]
 8003156:	7a46      	ldrb	r6, [r0, #9]
 8003158:	f852 1c08 	ldr.w	r1, [r2, #-8]
 800315c:	fa03 f606 	lsl.w	r6, r3, r6
 8003160:	ea21 0106 	bic.w	r1, r1, r6
 8003164:	f842 1c08 	str.w	r1, [r2, #-8]
 8003168:	7a46      	ldrb	r6, [r0, #9]
 800316a:	f852 1c08 	ldr.w	r1, [r2, #-8]
 800316e:	fa05 f606 	lsl.w	r6, r5, r6
 8003172:	4331      	orrs	r1, r6
 8003174:	f842 1c08 	str.w	r1, [r2, #-8]
 8003178:	7a46      	ldrb	r6, [r0, #9]
 800317a:	f852 1c10 	ldr.w	r1, [r2, #-16]
 800317e:	40b3      	lsls	r3, r6
 8003180:	ea21 0303 	bic.w	r3, r1, r3
 8003184:	f842 3c10 	str.w	r3, [r2, #-16]
 8003188:	7a43      	ldrb	r3, [r0, #9]
 800318a:	f852 1c10 	ldr.w	r1, [r2, #-16]
 800318e:	fa04 f303 	lsl.w	r3, r4, r3
 8003192:	430b      	orrs	r3, r1
 8003194:	f842 3c10 	str.w	r3, [r2, #-16]
 8003198:	7a43      	ldrb	r3, [r0, #9]
 800319a:	6802      	ldr	r2, [r0, #0]
 800319c:	b9ad      	cbnz	r5, 80031ca <can_driver_filter_insert+0xba>
 800319e:	7a81      	ldrb	r1, [r0, #10]
 80031a0:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 80031a4:	f603 43c8 	addw	r3, r3, #3272	; 0xcc8
 80031a8:	2901      	cmp	r1, #1
 80031aa:	b291      	uxth	r1, r2
 80031ac:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80031b0:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
 80031b4:	d016      	beq.n	80031e4 <can_driver_filter_insert+0xd4>
 80031b6:	601a      	str	r2, [r3, #0]
 80031b8:	7a43      	ldrb	r3, [r0, #9]
 80031ba:	f04f 32ff 	mov.w	r2, #4294967295
 80031be:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 80031c2:	f603 43c8 	addw	r3, r3, #3272	; 0xcc8
 80031c6:	00db      	lsls	r3, r3, #3
 80031c8:	e00c      	b.n	80031e4 <can_driver_filter_insert+0xd4>
 80031ca:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 80031ce:	f603 43c8 	addw	r3, r3, #3272	; 0xcc8
 80031d2:	00db      	lsls	r3, r3, #3
 80031d4:	601a      	str	r2, [r3, #0]
 80031d6:	7a43      	ldrb	r3, [r0, #9]
 80031d8:	6842      	ldr	r2, [r0, #4]
 80031da:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 80031de:	f603 43c8 	addw	r3, r3, #3272	; 0xcc8
 80031e2:	00db      	lsls	r3, r3, #3
 80031e4:	605a      	str	r2, [r3, #4]
 80031e6:	4912      	ldr	r1, [pc, #72]	; (8003230 <can_driver_filter_insert+0x120>)
 80031e8:	7a44      	ldrb	r4, [r0, #9]
 80031ea:	680a      	ldr	r2, [r1, #0]
 80031ec:	2301      	movs	r3, #1
 80031ee:	40a3      	lsls	r3, r4
 80031f0:	4313      	orrs	r3, r2
 80031f2:	600b      	str	r3, [r1, #0]
 80031f4:	4a0c      	ldr	r2, [pc, #48]	; (8003228 <can_driver_filter_insert+0x118>)
 80031f6:	6813      	ldr	r3, [r2, #0]
 80031f8:	f013 0301 	ands.w	r3, r3, #1
 80031fc:	d004      	beq.n	8003208 <can_driver_filter_insert+0xf8>
 80031fe:	6813      	ldr	r3, [r2, #0]
 8003200:	f023 0301 	bic.w	r3, r3, #1
 8003204:	6013      	str	r3, [r2, #0]
 8003206:	e7f5      	b.n	80031f4 <can_driver_filter_insert+0xe4>
 8003208:	4a0a      	ldr	r2, [pc, #40]	; (8003234 <can_driver_filter_insert+0x124>)
 800320a:	7a41      	ldrb	r1, [r0, #9]
 800320c:	6810      	ldr	r0, [r2, #0]
 800320e:	4281      	cmp	r1, r0
 8003210:	d907      	bls.n	8003222 <can_driver_filter_insert+0x112>
 8003212:	6011      	str	r1, [r2, #0]
 8003214:	e005      	b.n	8003222 <can_driver_filter_insert+0x112>
 8003216:	f04f 30ff 	mov.w	r0, #4294967295
 800321a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800321c:	f06f 0001 	mvn.w	r0, #1
 8003220:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003222:	4618      	mov	r0, r3
 8003224:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003226:	bf00      	nop
 8003228:	40006600 	.word	0x40006600
 800322c:	40006614 	.word	0x40006614
 8003230:	4000661c 	.word	0x4000661c
 8003234:	20001644 	.word	0x20001644

08003238 <can_driver_filter_add_one_32b_id>:
 8003238:	2801      	cmp	r0, #1
 800323a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800323c:	d802      	bhi.n	8003244 <can_driver_filter_add_one_32b_id+0xc>
 800323e:	b920      	cbnz	r0, 800324a <can_driver_filter_add_one_32b_id+0x12>
 8003240:	4b28      	ldr	r3, [pc, #160]	; (80032e4 <can_driver_filter_add_one_32b_id+0xac>)
 8003242:	e003      	b.n	800324c <can_driver_filter_add_one_32b_id+0x14>
 8003244:	f06f 0001 	mvn.w	r0, #1
 8003248:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800324a:	4b27      	ldr	r3, [pc, #156]	; (80032e8 <can_driver_filter_add_one_32b_id+0xb0>)
 800324c:	681c      	ldr	r4, [r3, #0]
 800324e:	4b27      	ldr	r3, [pc, #156]	; (80032ec <can_driver_filter_add_one_32b_id+0xb4>)
 8003250:	681d      	ldr	r5, [r3, #0]
 8003252:	07ed      	lsls	r5, r5, #31
 8003254:	d404      	bmi.n	8003260 <can_driver_filter_add_one_32b_id+0x28>
 8003256:	681d      	ldr	r5, [r3, #0]
 8003258:	f045 0501 	orr.w	r5, r5, #1
 800325c:	601d      	str	r5, [r3, #0]
 800325e:	e7f6      	b.n	800324e <can_driver_filter_add_one_32b_id+0x16>
 8003260:	4d20      	ldr	r5, [pc, #128]	; (80032e4 <can_driver_filter_add_one_32b_id+0xac>)
 8003262:	f104 6300 	add.w	r3, r4, #134217728	; 0x8000000
 8003266:	686e      	ldr	r6, [r5, #4]
 8003268:	f603 43c8 	addw	r3, r3, #3272	; 0xcc8
 800326c:	00db      	lsls	r3, r3, #3
 800326e:	b916      	cbnz	r6, 8003276 <can_driver_filter_add_one_32b_id+0x3e>
 8003270:	6019      	str	r1, [r3, #0]
 8003272:	f06f 0103 	mvn.w	r1, #3
 8003276:	2a01      	cmp	r2, #1
 8003278:	6059      	str	r1, [r3, #4]
 800327a:	d82f      	bhi.n	80032dc <can_driver_filter_add_one_32b_id+0xa4>
 800327c:	491c      	ldr	r1, [pc, #112]	; (80032f0 <can_driver_filter_add_one_32b_id+0xb8>)
 800327e:	2601      	movs	r6, #1
 8003280:	680f      	ldr	r7, [r1, #0]
 8003282:	fa06 f304 	lsl.w	r3, r6, r4
 8003286:	ea27 0703 	bic.w	r7, r7, r3
 800328a:	600f      	str	r7, [r1, #0]
 800328c:	680f      	ldr	r7, [r1, #0]
 800328e:	40a2      	lsls	r2, r4
 8003290:	433a      	orrs	r2, r7
 8003292:	600a      	str	r2, [r1, #0]
 8003294:	f851 2c08 	ldr.w	r2, [r1, #-8]
 8003298:	431a      	orrs	r2, r3
 800329a:	f841 2c08 	str.w	r2, [r1, #-8]
 800329e:	f851 2c10 	ldr.w	r2, [r1, #-16]
 80032a2:	431a      	orrs	r2, r3
 80032a4:	f841 2c10 	str.w	r2, [r1, #-16]
 80032a8:	688a      	ldr	r2, [r1, #8]
 80032aa:	4313      	orrs	r3, r2
 80032ac:	608b      	str	r3, [r1, #8]
 80032ae:	686a      	ldr	r2, [r5, #4]
 80032b0:	4b0c      	ldr	r3, [pc, #48]	; (80032e4 <can_driver_filter_add_one_32b_id+0xac>)
 80032b2:	b12a      	cbz	r2, 80032c0 <can_driver_filter_add_one_32b_id+0x88>
 80032b4:	2200      	movs	r2, #0
 80032b6:	605a      	str	r2, [r3, #4]
 80032b8:	4434      	add	r4, r6
 80032ba:	b118      	cbz	r0, 80032c4 <can_driver_filter_add_one_32b_id+0x8c>
 80032bc:	4b0a      	ldr	r3, [pc, #40]	; (80032e8 <can_driver_filter_add_one_32b_id+0xb0>)
 80032be:	e001      	b.n	80032c4 <can_driver_filter_add_one_32b_id+0x8c>
 80032c0:	605e      	str	r6, [r3, #4]
 80032c2:	e000      	b.n	80032c6 <can_driver_filter_add_one_32b_id+0x8e>
 80032c4:	601c      	str	r4, [r3, #0]
 80032c6:	4b09      	ldr	r3, [pc, #36]	; (80032ec <can_driver_filter_add_one_32b_id+0xb4>)
 80032c8:	6818      	ldr	r0, [r3, #0]
 80032ca:	f010 0001 	ands.w	r0, r0, #1
 80032ce:	d004      	beq.n	80032da <can_driver_filter_add_one_32b_id+0xa2>
 80032d0:	681a      	ldr	r2, [r3, #0]
 80032d2:	f022 0201 	bic.w	r2, r2, #1
 80032d6:	601a      	str	r2, [r3, #0]
 80032d8:	e7f5      	b.n	80032c6 <can_driver_filter_add_one_32b_id+0x8e>
 80032da:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80032dc:	f06f 0002 	mvn.w	r0, #2
 80032e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80032e2:	bf00      	nop
 80032e4:	20001644 	.word	0x20001644
 80032e8:	20000510 	.word	0x20000510
 80032ec:	40006600 	.word	0x40006600
 80032f0:	40006614 	.word	0x40006614

080032f4 <can_driver_filter_add_two_32b_id>:
 80032f4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80032f6:	4614      	mov	r4, r2
 80032f8:	4607      	mov	r7, r0
 80032fa:	460e      	mov	r6, r1
 80032fc:	b085      	sub	sp, #20
 80032fe:	4a0c      	ldr	r2, [pc, #48]	; (8003330 <can_driver_filter_add_two_32b_id+0x3c>)
 8003300:	f004 0401 	and.w	r4, r4, #1
 8003304:	ad01      	add	r5, sp, #4
 8003306:	2b1c      	cmp	r3, #28
 8003308:	ea4f 0484 	mov.w	r4, r4, lsl #2
 800330c:	ca07      	ldmia	r2, {r0, r1, r2}
 800330e:	bf28      	it	cs
 8003310:	231c      	movcs	r3, #28
 8003312:	e885 0007 	stmia.w	r5, {r0, r1, r2}
 8003316:	f044 0403 	orr.w	r4, r4, #3
 800331a:	4628      	mov	r0, r5
 800331c:	9701      	str	r7, [sp, #4]
 800331e:	9602      	str	r6, [sp, #8]
 8003320:	f88d 400c 	strb.w	r4, [sp, #12]
 8003324:	f88d 300d 	strb.w	r3, [sp, #13]
 8003328:	f7ff fef2 	bl	8003110 <can_driver_filter_insert>
 800332c:	b005      	add	sp, #20
 800332e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003330:	08003f68 	.word	0x08003f68

08003334 <can_driver_filter_add_param_tbl>:
 8003334:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003338:	2400      	movs	r4, #0
 800333a:	4607      	mov	r7, r0
 800333c:	4688      	mov	r8, r1
 800333e:	4616      	mov	r6, r2
 8003340:	4699      	mov	r9, r3
 8003342:	4625      	mov	r5, r4
 8003344:	42b5      	cmp	r5, r6
 8003346:	d00a      	beq.n	800335e <can_driver_filter_add_param_tbl+0x2a>
 8003348:	f857 1025 	ldr.w	r1, [r7, r5, lsl #2]
 800334c:	4549      	cmp	r1, r9
 800334e:	d004      	beq.n	800335a <can_driver_filter_add_param_tbl+0x26>
 8003350:	4640      	mov	r0, r8
 8003352:	2200      	movs	r2, #0
 8003354:	f7ff ff70 	bl	8003238 <can_driver_filter_add_one_32b_id>
 8003358:	4304      	orrs	r4, r0
 800335a:	3501      	adds	r5, #1
 800335c:	e7f2      	b.n	8003344 <can_driver_filter_add_param_tbl+0x10>
 800335e:	4620      	mov	r0, r4
 8003360:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08003364 <can_driver_filter_setbanknum>:
 8003364:	4b05      	ldr	r3, [pc, #20]	; (800337c <can_driver_filter_setbanknum+0x18>)
 8003366:	b908      	cbnz	r0, 800336c <can_driver_filter_setbanknum+0x8>
 8003368:	601a      	str	r2, [r3, #0]
 800336a:	e003      	b.n	8003374 <can_driver_filter_setbanknum+0x10>
 800336c:	2801      	cmp	r0, #1
 800336e:	bf04      	itt	eq
 8003370:	4803      	ldreq	r0, [pc, #12]	; (8003380 <can_driver_filter_setbanknum+0x1c>)
 8003372:	6002      	streq	r2, [r0, #0]
 8003374:	f001 0101 	and.w	r1, r1, #1
 8003378:	6059      	str	r1, [r3, #4]
 800337a:	4770      	bx	lr
 800337c:	20001644 	.word	0x20001644
 8003380:	20000510 	.word	0x20000510

08003384 <can_driver_filter_getbanknum>:
 8003384:	4a06      	ldr	r2, [pc, #24]	; (80033a0 <can_driver_filter_getbanknum+0x1c>)
 8003386:	b908      	cbnz	r0, 800338c <can_driver_filter_getbanknum+0x8>
 8003388:	6813      	ldr	r3, [r2, #0]
 800338a:	e004      	b.n	8003396 <can_driver_filter_getbanknum+0x12>
 800338c:	2801      	cmp	r0, #1
 800338e:	bf0a      	itet	eq
 8003390:	4b04      	ldreq	r3, [pc, #16]	; (80033a4 <can_driver_filter_getbanknum+0x20>)
 8003392:	2300      	movne	r3, #0
 8003394:	681b      	ldreq	r3, [r3, #0]
 8003396:	6850      	ldr	r0, [r2, #4]
 8003398:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
 800339c:	4770      	bx	lr
 800339e:	bf00      	nop
 80033a0:	20001644 	.word	0x20001644
 80033a4:	20000510 	.word	0x20000510

080033a8 <can_msg_reset_msg>:
 80033a8:	4b0b      	ldr	r3, [pc, #44]	; (80033d8 <can_msg_reset_msg+0x30>)
 80033aa:	b510      	push	{r4, lr}
 80033ac:	681a      	ldr	r2, [r3, #0]
 80033ae:	680c      	ldr	r4, [r1, #0]
 80033b0:	4294      	cmp	r4, r2
 80033b2:	d10a      	bne.n	80033ca <can_msg_reset_msg+0x22>
 80033b4:	684a      	ldr	r2, [r1, #4]
 80033b6:	f002 020f 	and.w	r2, r2, #15
 80033ba:	2a01      	cmp	r2, #1
 80033bc:	d105      	bne.n	80033ca <can_msg_reset_msg+0x22>
 80033be:	7a0a      	ldrb	r2, [r1, #8]
 80033c0:	2a08      	cmp	r2, #8
 80033c2:	bf02      	ittt	eq
 80033c4:	4c05      	ldreq	r4, [pc, #20]	; (80033dc <can_msg_reset_msg+0x34>)
 80033c6:	4a06      	ldreq	r2, [pc, #24]	; (80033e0 <can_msg_reset_msg+0x38>)
 80033c8:	6014      	streq	r4, [r2, #0]
 80033ca:	685b      	ldr	r3, [r3, #4]
 80033cc:	b113      	cbz	r3, 80033d4 <can_msg_reset_msg+0x2c>
 80033ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80033d2:	4718      	bx	r3
 80033d4:	bd10      	pop	{r4, pc}
 80033d6:	bf00      	nop
 80033d8:	2000164c 	.word	0x2000164c
 80033dc:	05fa0004 	.word	0x05fa0004
 80033e0:	e000ed0c 	.word	0xe000ed0c

080033e4 <can_msg_reset_init>:
 80033e4:	4b02      	ldr	r3, [pc, #8]	; (80033f0 <can_msg_reset_init+0xc>)
 80033e6:	6019      	str	r1, [r3, #0]
 80033e8:	4b02      	ldr	r3, [pc, #8]	; (80033f4 <can_msg_reset_init+0x10>)
 80033ea:	6383      	str	r3, [r0, #56]	; 0x38
 80033ec:	2000      	movs	r0, #0
 80033ee:	4770      	bx	lr
 80033f0:	2000164c 	.word	0x2000164c
 80033f4:	080033a9 	.word	0x080033a9

080033f8 <calloc>:
 80033f8:	f240 0308 	movw	r3, #8
 80033fc:	460a      	mov	r2, r1
 80033fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003402:	4601      	mov	r1, r0
 8003404:	6818      	ldr	r0, [r3, #0]
 8003406:	f000 b801 	b.w	800340c <_calloc_r>
 800340a:	bf00      	nop

0800340c <_calloc_r>:
 800340c:	b538      	push	{r3, r4, r5, lr}
 800340e:	fb01 f102 	mul.w	r1, r1, r2
 8003412:	f7fd fead 	bl	8001170 <_malloc_r>
 8003416:	4604      	mov	r4, r0
 8003418:	b1f8      	cbz	r0, 800345a <_calloc_r+0x4e>
 800341a:	f850 2c04 	ldr.w	r2, [r0, #-4]
 800341e:	f022 0203 	bic.w	r2, r2, #3
 8003422:	3a04      	subs	r2, #4
 8003424:	2a24      	cmp	r2, #36	; 0x24
 8003426:	d81a      	bhi.n	800345e <_calloc_r+0x52>
 8003428:	2a13      	cmp	r2, #19
 800342a:	4603      	mov	r3, r0
 800342c:	d90f      	bls.n	800344e <_calloc_r+0x42>
 800342e:	2100      	movs	r1, #0
 8003430:	f840 1b04 	str.w	r1, [r0], #4
 8003434:	1d03      	adds	r3, r0, #4
 8003436:	2a1b      	cmp	r2, #27
 8003438:	6061      	str	r1, [r4, #4]
 800343a:	d908      	bls.n	800344e <_calloc_r+0x42>
 800343c:	1d1d      	adds	r5, r3, #4
 800343e:	6041      	str	r1, [r0, #4]
 8003440:	6059      	str	r1, [r3, #4]
 8003442:	3308      	adds	r3, #8
 8003444:	2a24      	cmp	r2, #36	; 0x24
 8003446:	bf02      	ittt	eq
 8003448:	6069      	streq	r1, [r5, #4]
 800344a:	6059      	streq	r1, [r3, #4]
 800344c:	3308      	addeq	r3, #8
 800344e:	461a      	mov	r2, r3
 8003450:	2100      	movs	r1, #0
 8003452:	f842 1b04 	str.w	r1, [r2], #4
 8003456:	6059      	str	r1, [r3, #4]
 8003458:	6051      	str	r1, [r2, #4]
 800345a:	4620      	mov	r0, r4
 800345c:	bd38      	pop	{r3, r4, r5, pc}
 800345e:	2100      	movs	r1, #0
 8003460:	f000 f802 	bl	8003468 <memset>
 8003464:	4620      	mov	r0, r4
 8003466:	bd38      	pop	{r3, r4, r5, pc}

08003468 <memset>:
 8003468:	2a03      	cmp	r2, #3
 800346a:	b2c9      	uxtb	r1, r1
 800346c:	b470      	push	{r4, r5, r6}
 800346e:	d808      	bhi.n	8003482 <memset+0x1a>
 8003470:	b12a      	cbz	r2, 800347e <memset+0x16>
 8003472:	4603      	mov	r3, r0
 8003474:	1812      	adds	r2, r2, r0
 8003476:	f803 1b01 	strb.w	r1, [r3], #1
 800347a:	4293      	cmp	r3, r2
 800347c:	d1fb      	bne.n	8003476 <memset+0xe>
 800347e:	bc70      	pop	{r4, r5, r6}
 8003480:	4770      	bx	lr
 8003482:	1882      	adds	r2, r0, r2
 8003484:	4604      	mov	r4, r0
 8003486:	e001      	b.n	800348c <memset+0x24>
 8003488:	f804 1b01 	strb.w	r1, [r4], #1
 800348c:	f014 0f03 	tst.w	r4, #3
 8003490:	d1fa      	bne.n	8003488 <memset+0x20>
 8003492:	f04f 3301 	mov.w	r3, #16843009	; 0x1010101
 8003496:	fb03 f301 	mul.w	r3, r3, r1
 800349a:	e01f      	b.n	80034dc <memset+0x74>
 800349c:	f844 3c40 	str.w	r3, [r4, #-64]
 80034a0:	f844 3c3c 	str.w	r3, [r4, #-60]
 80034a4:	f844 3c38 	str.w	r3, [r4, #-56]
 80034a8:	f844 3c34 	str.w	r3, [r4, #-52]
 80034ac:	f844 3c30 	str.w	r3, [r4, #-48]
 80034b0:	f844 3c2c 	str.w	r3, [r4, #-44]
 80034b4:	f844 3c28 	str.w	r3, [r4, #-40]
 80034b8:	f844 3c24 	str.w	r3, [r4, #-36]
 80034bc:	f844 3c20 	str.w	r3, [r4, #-32]
 80034c0:	f844 3c1c 	str.w	r3, [r4, #-28]
 80034c4:	f844 3c18 	str.w	r3, [r4, #-24]
 80034c8:	f844 3c14 	str.w	r3, [r4, #-20]
 80034cc:	f844 3c10 	str.w	r3, [r4, #-16]
 80034d0:	f844 3c0c 	str.w	r3, [r4, #-12]
 80034d4:	f844 3c08 	str.w	r3, [r4, #-8]
 80034d8:	f844 3c04 	str.w	r3, [r4, #-4]
 80034dc:	1b16      	subs	r6, r2, r4
 80034de:	4625      	mov	r5, r4
 80034e0:	3440      	adds	r4, #64	; 0x40
 80034e2:	2e3f      	cmp	r6, #63	; 0x3f
 80034e4:	dcda      	bgt.n	800349c <memset+0x34>
 80034e6:	462c      	mov	r4, r5
 80034e8:	e007      	b.n	80034fa <memset+0x92>
 80034ea:	f844 3c10 	str.w	r3, [r4, #-16]
 80034ee:	f844 3c0c 	str.w	r3, [r4, #-12]
 80034f2:	f844 3c08 	str.w	r3, [r4, #-8]
 80034f6:	f844 3c04 	str.w	r3, [r4, #-4]
 80034fa:	1b16      	subs	r6, r2, r4
 80034fc:	4625      	mov	r5, r4
 80034fe:	3410      	adds	r4, #16
 8003500:	2e0f      	cmp	r6, #15
 8003502:	dcf2      	bgt.n	80034ea <memset+0x82>
 8003504:	e001      	b.n	800350a <memset+0xa2>
 8003506:	f845 3b04 	str.w	r3, [r5], #4
 800350a:	1b54      	subs	r4, r2, r5
 800350c:	2c03      	cmp	r4, #3
 800350e:	dcfa      	bgt.n	8003506 <memset+0x9e>
 8003510:	e001      	b.n	8003516 <memset+0xae>
 8003512:	f805 1b01 	strb.w	r1, [r5], #1
 8003516:	4295      	cmp	r5, r2
 8003518:	d3fb      	bcc.n	8003512 <memset+0xaa>
 800351a:	e7b0      	b.n	800347e <memset+0x16>
 800351c:	0a0a0a0d 	.word	0x0a0a0a0d
 8003520:	23232320 	.word	0x23232320
 8003524:	2e2e2023 	.word	0x2e2e2023
 8003528:	52444c2f 	.word	0x52444c2f
 800352c:	45584946 	.word	0x45584946
 8003530:	444f5044 	.word	0x444f5044
 8003534:	5552542f 	.word	0x5552542f
 8003538:	4c2f4b4e 	.word	0x4c2f4b4e
 800353c:	23205244 	.word	0x23205244
 8003540:	20232323 	.word	0x20232323
 8003544:	322f3430 	.word	0x322f3430
 8003548:	30322f30 	.word	0x30322f30
 800354c:	76203631 	.word	0x76203631
 8003550:	0d0a2030 	.word	0x0d0a2030
 8003554:	68202000 	.word	0x68202000
 8003558:	5f6b6c63 	.word	0x5f6b6c63
 800355c:	71657266 	.word	0x71657266
 8003560:	484d2820 	.word	0x484d2820
 8003564:	3a20297a 	.word	0x3a20297a
 8003568:	75392520 	.word	0x75392520
 800356c:	20000d0a 	.word	0x20000d0a
 8003570:	6b6c6370 	.word	0x6b6c6370
 8003574:	72665f31 	.word	0x72665f31
 8003578:	28207165 	.word	0x28207165
 800357c:	297a484d 	.word	0x297a484d
 8003580:	25203a20 	.word	0x25203a20
 8003584:	0d0a7539 	.word	0x0d0a7539
 8003588:	63702000 	.word	0x63702000
 800358c:	5f326b6c 	.word	0x5f326b6c
 8003590:	71657266 	.word	0x71657266
 8003594:	484d2820 	.word	0x484d2820
 8003598:	3a20297a 	.word	0x3a20297a
 800359c:	75392520 	.word	0x75392520
 80035a0:	73000d0a 	.word	0x73000d0a
 80035a4:	6c637379 	.word	0x6c637379
 80035a8:	72665f6b 	.word	0x72665f6b
 80035ac:	28207165 	.word	0x28207165
 80035b0:	297a484d 	.word	0x297a484d
 80035b4:	25203a20 	.word	0x25203a20
 80035b8:	0d0a7539 	.word	0x0d0a7539
 80035bc:	430d0a00 	.word	0x430d0a00
 80035c0:	72746e6f 	.word	0x72746e6f
 80035c4:	732f6c6f 	.word	0x732f6c6f
 80035c8:	75746174 	.word	0x75746174
 80035cc:	65722073 	.word	0x65722073
 80035d0:	74736967 	.word	0x74736967
 80035d4:	28207265 	.word	0x28207265
 80035d8:	5f434352 	.word	0x5f434352
 80035dc:	29525343 	.word	0x29525343
 80035e0:	25203a20 	.word	0x25203a20
 80035e4:	0a783830 	.word	0x0a783830
 80035e8:	6f43000d 	.word	0x6f43000d
 80035ec:	6f72746e 	.word	0x6f72746e
 80035f0:	74732f6c 	.word	0x74732f6c
 80035f4:	73757461 	.word	0x73757461
 80035f8:	67657220 	.word	0x67657220
 80035fc:	65747369 	.word	0x65747369
 8003600:	52282072 	.word	0x52282072
 8003604:	435f4343 	.word	0x435f4343
 8003608:	20295253 	.word	0x20295253
 800360c:	3025203a 	.word	0x3025203a
 8003610:	41207838 	.word	0x41207838
 8003614:	72657466 	.word	0x72657466
 8003618:	564d5220 	.word	0x564d5220
 800361c:	72772046 	.word	0x72772046
 8003620:	65747469 	.word	0x65747469
 8003624:	0a0d0a6e 	.word	0x0a0d0a6e
 8003628:	6e6f4300 	.word	0x6e6f4300
 800362c:	6c6f7274 	.word	0x6c6f7274
 8003630:	6174732f 	.word	0x6174732f
 8003634:	20737574 	.word	0x20737574
 8003638:	69676572 	.word	0x69676572
 800363c:	72657473 	.word	0x72657473
 8003640:	43522820 	.word	0x43522820
 8003644:	53435f43 	.word	0x53435f43
 8003648:	3a202952 	.word	0x3a202952
 800364c:	38302520 	.word	0x38302520
 8003650:	66412078 	.word	0x66412078
 8003654:	20726574 	.word	0x20726574
 8003658:	5257504c 	.word	0x5257504c
 800365c:	69727720 	.word	0x69727720
 8003660:	6e657474 	.word	0x6e657474
 8003664:	000a0d0a 	.word	0x000a0d0a
 8003668:	314e4143 	.word	0x314e4143
 800366c:	696e6920 	.word	0x696e6920
 8003670:	61662074 	.word	0x61662074
 8003674:	64656c69 	.word	0x64656c69
 8003678:	554e203a 	.word	0x554e203a
 800367c:	70204c4c 	.word	0x70204c4c
 8003680:	0d0a7274 	.word	0x0d0a7274
 8003684:	4e414300 	.word	0x4e414300
 8003688:	696e6920 	.word	0x696e6920
 800368c:	61662074 	.word	0x61662074
 8003690:	64656c69 	.word	0x64656c69
 8003694:	6572203a 	.word	0x6572203a
 8003698:	6e727574 	.word	0x6e727574
 800369c:	646f6320 	.word	0x646f6320
 80036a0:	203d2065 	.word	0x203d2065
 80036a4:	0d0a6425 	.word	0x0d0a6425
 80036a8:	69202000 	.word	0x69202000
 80036ac:	202e652e 	.word	0x202e652e
 80036b0:	74696e75 	.word	0x74696e75
 80036b4:	25203a23 	.word	0x25203a23
 80036b8:	000d0a64 	.word	0x000d0a64
 80036bc:	53414c46 	.word	0x53414c46
 80036c0:	49532048 	.word	0x49532048
 80036c4:	203a455a 	.word	0x203a455a
 80036c8:	0d0a6425 	.word	0x0d0a6425
 80036cc:	33752800 	.word	0x33752800
 80036d0:	702a2932 	.word	0x702a2932
 80036d4:	62637263 	.word	0x62637263
 80036d8:	203a6b6c 	.word	0x203a6b6c
 80036dc:	58383025 	.word	0x58383025
 80036e0:	0a000d0a 	.word	0x0a000d0a
 80036e4:	23230a0d 	.word	0x23230a0d
 80036e8:	41202323 	.word	0x41202323
 80036ec:	666f2074 	.word	0x666f2074
 80036f0:	74657366 	.word	0x74657366
 80036f4:	38302520 	.word	0x38302520
 80036f8:	64612058 	.word	0x64612058
 80036fc:	73657264 	.word	0x73657264
 8003700:	30252073 	.word	0x30252073
 8003704:	69205838 	.word	0x69205838
 8003708:	6f622073 	.word	0x6f622073
 800370c:	20737567 	.word	0x20737567
 8003710:	23232323 	.word	0x23232323
 8003714:	000a0d0a 	.word	0x000a0d0a
 8003718:	74697865 	.word	0x74697865
 800371c:	000a      	.short	0x000a
 800371e:	7277      	.short	0x7277
 8003720:	3a6b6c62 	.word	0x3a6b6c62
 8003724:	20642520 	.word	0x20642520
 8003728:	25205825 	.word	0x25205825
 800372c:	30252058 	.word	0x30252058
 8003730:	25205838 	.word	0x25205838
 8003734:	0a583830 	.word	0x0a583830
 8003738:	7277000d 	.word	0x7277000d
 800373c:	3a6b6c62 	.word	0x3a6b6c62
 8003740:	53414320 	.word	0x53414320
 8003744:	3a302045 	.word	0x3a302045
 8003748:	206f6e20 	.word	0x206f6e20
 800374c:	6465656e 	.word	0x6465656e
 8003750:	206f7420 	.word	0x206f7420
 8003754:	74697277 	.word	0x74697277
 8003758:	6c622065 	.word	0x6c622065
 800375c:	0a6b636f 	.word	0x0a6b636f
 8003760:	7277000d 	.word	0x7277000d
 8003764:	3a6b6c62 	.word	0x3a6b6c62
 8003768:	53414320 	.word	0x53414320
 800376c:	3a322045 	.word	0x3a322045
 8003770:	61726520 	.word	0x61726520
 8003774:	62206573 	.word	0x62206573
 8003778:	6b636f6c 	.word	0x6b636f6c
 800377c:	66656220 	.word	0x66656220
 8003780:	2065726f 	.word	0x2065726f
 8003784:	74697277 	.word	0x74697277
 8003788:	0a676e69 	.word	0x0a676e69
 800378c:	7277000d 	.word	0x7277000d
 8003790:	3a6b6c62 	.word	0x3a6b6c62
 8003794:	53414320 	.word	0x53414320
 8003798:	3a312045 	.word	0x3a312045
 800379c:	69727720 	.word	0x69727720
 80037a0:	676e6974 	.word	0x676e6974
 80037a4:	6f6c6220 	.word	0x6f6c6220
 80037a8:	0d0a6b63 	.word	0x0d0a6b63
 80037ac:	62727700 	.word	0x62727700
 80037b0:	203a6b6c 	.word	0x203a6b6c
 80037b4:	5b796170 	.word	0x5b796170
 80037b8:	25205d31 	.word	0x25205d31
 80037bc:	61702058 	.word	0x61702058
 80037c0:	5d325b79 	.word	0x5d325b79
 80037c4:	0a582520 	.word	0x0a582520
 80037c8:	7277000d 	.word	0x7277000d
 80037cc:	3a6b6c62 	.word	0x3a6b6c62
 80037d0:	66656420 	.word	0x66656420
 80037d4:	746c7561 	.word	0x746c7561
 80037d8:	6425203a 	.word	0x6425203a
 80037dc:	46000d0a 	.word	0x46000d0a
 80037e0:	4853414c 	.word	0x4853414c
 80037e4:	4b4c4220 	.word	0x4b4c4220
 80037e8:	455a5320 	.word	0x455a5320
 80037ec:	6425203a 	.word	0x6425203a
 80037f0:	0d0a4b20 	.word	0x0d0a4b20
 80037f4:	414c4600 	.word	0x414c4600
 80037f8:	48204853 	.word	0x48204853
 80037fc:	44412049 	.word	0x44412049
 8003800:	203a5244 	.word	0x203a5244
 8003804:	58383025 	.word	0x58383025
 8003808:	43000d0a 	.word	0x43000d0a
 800380c:	49204e41 	.word	0x49204e41
 8003810:	0a732744 	.word	0x0a732744
 8003814:	4d43000d 	.word	0x4d43000d
 8003818:	25203a44 	.word	0x25203a44
 800381c:	0a583830 	.word	0x0a583830
 8003820:	4452000d 	.word	0x4452000d
 8003824:	25203a20 	.word	0x25203a20
 8003828:	0a583830 	.word	0x0a583830
 800382c:	5257000d 	.word	0x5257000d
 8003830:	25203a20 	.word	0x25203a20
 8003834:	0a583830 	.word	0x0a583830
 8003838:	414e000d 	.word	0x414e000d
 800383c:	3a304b43 	.word	0x3a304b43
 8003840:	20642520 	.word	0x20642520
 8003844:	25205825 	.word	0x25205825
 8003848:	58252064 	.word	0x58252064
 800384c:	38302520 	.word	0x38302520
 8003850:	30252058 	.word	0x30252058
 8003854:	0d0a5838 	.word	0x0d0a5838
 8003858:	43414e00 	.word	0x43414e00
 800385c:	203a4b31 	.word	0x203a4b31
 8003860:	25206425 	.word	0x25206425
 8003864:	64252058 	.word	0x64252058
 8003868:	20582520 	.word	0x20582520
 800386c:	58383025 	.word	0x58383025
 8003870:	38302520 	.word	0x38302520
 8003874:	000d0a58 	.word	0x000d0a58
 8003878:	64646170 	.word	0x64646170
 800387c:	6f726320 	.word	0x6f726320
 8003880:	64657373 	.word	0x64657373
 8003884:	6f6c6220 	.word	0x6f6c6220
 8003888:	62206b63 	.word	0x62206b63
 800388c:	646e756f 	.word	0x646e756f
 8003890:	3a797261 	.word	0x3a797261
 8003894:	38302520 	.word	0x38302520
 8003898:	70202058 	.word	0x70202058
 800389c:	3a646461 	.word	0x3a646461
 80038a0:	38302520 	.word	0x38302520
 80038a4:	000d0a78 	.word	0x000d0a78
 80038a8:	646e6553 	.word	0x646e6553
 80038ac:	43414e20 	.word	0x43414e20
 80038b0:	64203a4b 	.word	0x64203a4b
 80038b4:	6e20636c 	.word	0x6e20636c
 80038b8:	3820746f 	.word	0x3820746f
 80038bc:	6425203a 	.word	0x6425203a
 80038c0:	53000d0a 	.word	0x53000d0a
 80038c4:	20646e65 	.word	0x20646e65
 80038c8:	4b43414e 	.word	0x4b43414e
 80038cc:	61747320 	.word	0x61747320
 80038d0:	61207472 	.word	0x61207472
 80038d4:	20726464 	.word	0x20726464
 80038d8:	2074756f 	.word	0x2074756f
 80038dc:	7220666f 	.word	0x7220666f
 80038e0:	65676e61 	.word	0x65676e61
 80038e4:	3025203a 	.word	0x3025203a
 80038e8:	25205838 	.word	0x25205838
 80038ec:	30252058 	.word	0x30252058
 80038f0:	25205838 	.word	0x25205838
 80038f4:	0a583830 	.word	0x0a583830
 80038f8:	6148000d 	.word	0x6148000d
 80038fc:	43206472 	.word	0x43206472
 8003900:	6465646f 	.word	0x6465646f
 8003904:	64646120 	.word	0x64646120
 8003908:	73736572 	.word	0x73736572
 800390c:	65686320 	.word	0x65686320
 8003910:	6f206b63 	.word	0x6f206b63
 8003914:	6f2d7475 	.word	0x6f2d7475
 8003918:	61722d66 	.word	0x61722d66
 800391c:	3a65676e 	.word	0x3a65676e
 8003920:	5f637200 	.word	0x5f637200
 8003924:	33637263 	.word	0x33637263
 8003928:	25203a32 	.word	0x25203a32
 800392c:	20583830 	.word	0x20583830
 8003930:	58383025 	.word	0x58383025
 8003934:	38302520 	.word	0x38302520
 8003938:	000d0a58 	.word	0x000d0a58
 800393c:	646e6553 	.word	0x646e6553
 8003940:	63726320 	.word	0x63726320
 8003944:	3a32332d 	.word	0x3a32332d
 8003948:	38302520 	.word	0x38302520
 800394c:	000d0a58 	.word	0x000d0a58
 8003950:	66203a58 	.word	0x66203a58
 8003954:	6873616c 	.word	0x6873616c
 8003958:	636f6c62 	.word	0x636f6c62
 800395c:	7a69736b 	.word	0x7a69736b
 8003960:	25203a65 	.word	0x25203a65
 8003964:	58252058 	.word	0x58252058
 8003968:	20582520 	.word	0x20582520
 800396c:	0d0a5825 	.word	0x0d0a5825
 8003970:	3a345200 	.word	0x3a345200
 8003974:	61657220 	.word	0x61657220
 8003978:	64612064 	.word	0x64612064
 800397c:	203a7264 	.word	0x203a7264
 8003980:	25205825 	.word	0x25205825
 8003984:	58252058 	.word	0x58252058
 8003988:	20582520 	.word	0x20582520
 800398c:	25205825 	.word	0x25205825
 8003990:	000d0a58 	.word	0x000d0a58
 8003994:	675f6f64 	.word	0x675f6f64
 8003998:	72667465 	.word	0x72667465
 800399c:	61646d6f 	.word	0x61646d6f
 80039a0:	65726464 	.word	0x65726464
 80039a4:	203a7373 	.word	0x203a7373
 80039a8:	72646461 	.word	0x72646461
 80039ac:	746f6e20 	.word	0x746f6e20
 80039b0:	3a4b4f20 	.word	0x3a4b4f20
 80039b4:	38302520 	.word	0x38302520
 80039b8:	000d0a58 	.word	0x000d0a58
 80039bc:	41544547 	.word	0x41544547
 80039c0:	3a524444 	.word	0x3a524444
 80039c4:	61657220 	.word	0x61657220
 80039c8:	64612064 	.word	0x64612064
 80039cc:	203a7264 	.word	0x203a7264
 80039d0:	25205825 	.word	0x25205825
 80039d4:	58252058 	.word	0x58252058
 80039d8:	20582520 	.word	0x20582520
 80039dc:	0d0a5825 	.word	0x0d0a5825
 80039e0:	6e657300 	.word	0x6e657300
 80039e4:	203a3464 	.word	0x203a3464
 80039e8:	25205825 	.word	0x25205825
 80039ec:	58252058 	.word	0x58252058
 80039f0:	20582520 	.word	0x20582520
 80039f4:	25205825 	.word	0x25205825
 80039f8:	000d0a58 	.word	0x000d0a58
 80039fc:	20544547 	.word	0x20544547
 8003a00:	53414c46 	.word	0x53414c46
 8003a04:	61205048 	.word	0x61205048
 8003a08:	20726464 	.word	0x20726464
 8003a0c:	58252000 	.word	0x58252000
 8003a10:	474f4200 	.word	0x474f4200
 8003a14:	43205355 	.word	0x43205355
 8003a18:	4320444d 	.word	0x4320444d
 8003a1c:	3a45444f 	.word	0x3a45444f
 8003a20:	20582520 	.word	0x20582520
 8003a24:	58383025 	.word	0x58383025
 8003a28:	20582520 	.word	0x20582520
 8003a2c:	38302520 	.word	0x38302520
 8003a30:	30252058 	.word	0x30252058
 8003a34:	0d0a5838 	.word	0x0d0a5838
 8003a38:	00000000 	.word	0x00000000
 8003a3c:	00000043 	.word	0x00000043

08003a40 <msginit>:
 8003a40:	00000060 00000020 00000010 00000008     `... ...........

08003a50 <can_ldr_ready>:
 8003a50:	02400000 00000001 00000008 00000000     ..@.............

08003a60 <table>:
 8003a60:	08040402 02020202 04040402 02020202     ................

08003a70 <_global_impure_ptr>:
 8003a70:	2000000c                                ... 

08003a74 <pllmulxtbl>:
 8003a74:	0a080202 12100e0c 1a181614 20201e1c     ..............  

08003a84 <ahbtbl>:
 8003a84:	00010001 00010001 00010001 00010001     ................
 8003a94:	00040002 00100008 00800040 02000100     ........@.......

08003aa4 <crctable>:
 8003aa4:	00000000 77073096 ee0e612c 990951ba     .....0.w,a...Q..
 8003ab4:	076dc419 706af48f e963a535 9e6495a3     ..m...jp5.c...d.
 8003ac4:	0edb8832 79dcb8a4 e0d5e91e 97d2d988     2......y........
 8003ad4:	09b64c2b 7eb17cbd e7b82d07 90bf1d91     +L...|.~.-......
 8003ae4:	1db71064 6ab020f2 f3b97148 84be41de     d.... .jHq...A..
 8003af4:	1adad47d 6ddde4eb f4d4b551 83d385c7     }......mQ.......
 8003b04:	136c9856 646ba8c0 fd62f97a 8a65c9ec     V.l...kdz.b...e.
 8003b14:	14015c4f 63066cd9 fa0f3d63 8d080df5     O\...l.cc=......
 8003b24:	3b6e20c8 4c69105e d56041e4 a2677172     . n;^.iL.A`.rqg.
 8003b34:	3c03e4d1 4b04d447 d20d85fd a50ab56b     ...<G..K....k...
 8003b44:	35b5a8fa 42b2986c dbbbc9d6 acbcf940     ...5l..B....@...
 8003b54:	32d86ce3 45df5c75 dcd60dcf abd13d59     .l.2u\.E....Y=..
 8003b64:	26d930ac 51de003a c8d75180 bfd06116     .0.&:..Q.Q...a..
 8003b74:	21b4f4b5 56b3c423 cfba9599 b8bda50f     ...!#..V........
 8003b84:	2802b89e 5f058808 c60cd9b2 b10be924     ...(..._....$...
 8003b94:	2f6f7c87 58684c11 c1611dab b6662d3d     .|o/.LhX..a.=-f.
 8003ba4:	76dc4190 01db7106 98d220bc efd5102a     .A.v.q... ..*...
 8003bb4:	71b18589 06b6b51f 9fbfe4a5 e8b8d433     ...q........3...
 8003bc4:	7807c9a2 0f00f934 9609a88e e10e9818     ...x4...........
 8003bd4:	7f6a0dbb 086d3d2d 91646c97 e6635c01     ..j.-=m..ld..\c.
 8003be4:	6b6b51f4 1c6c6162 856530d8 f262004e     .Qkkbal..0e.N.b.
 8003bf4:	6c0695ed 1b01a57b 8208f4c1 f50fc457     ...l{.......W...
 8003c04:	65b0d9c6 12b7e950 8bbeb8ea fcb9887c     ...eP.......|...
 8003c14:	62dd1ddf 15da2d49 8cd37cf3 fbd44c65     ...bI-...|..eL..
 8003c24:	4db26158 3ab551ce a3bc0074 d4bb30e2     Xa.M.Q.:t....0..
 8003c34:	4adfa541 3dd895d7 a4d1c46d d3d6f4fb     A..J...=m.......
 8003c44:	4369e96a 346ed9fc ad678846 da60b8d0     j.iC..n4F.g...`.
 8003c54:	44042d73 33031de5 aa0a4c5f dd0d7cc9     s-.D...3_L...|..
 8003c64:	5005713c 270241aa be0b1010 c90c2086     <q.P.A.'..... ..
 8003c74:	5768b525 206f85b3 b966d409 ce61e49f     %.hW..o ..f...a.
 8003c84:	5edef90e 29d9c998 b0d09822 c7d7a8b4     ...^...)".......
 8003c94:	59b33d17 2eb40d81 b7bd5c3b c0ba6cad     .=.Y....;\...l..
 8003ca4:	edb88320 9abfb3b6 03b6e20c 74b1d29a      ..............t
 8003cb4:	ead54739 9dd277af 04db2615 73dc1683     9G...w...&.....s
 8003cc4:	e3630b12 94643b84 0d6d6a3e 7a6a5aa8     ..c..;d.>jm..Zjz
 8003cd4:	e40ecf0b 9309ff9d 0a00ae27 7d079eb1     ........'......}
 8003ce4:	f00f9344 8708a3d2 1e01f268 6906c2fe     D.......h......i
 8003cf4:	f762575d 806567cb 196c3671 6e6b06e7     ]Wb..ge.q6l...kn
 8003d04:	fed41b76 89d32be0 10da7a5a 67dd4acc     v....+..Zz...J.g
 8003d14:	f9b9df6f 8ebeeff9 17b7be43 60b08ed5     o.......C......`
 8003d24:	d6d6a3e8 a1d1937e 38d8c2c4 4fdff252     ....~......8R..O
 8003d34:	d1bb67f1 a6bc5767 3fb506dd 48b2364b     .g..gW.....?K6.H
 8003d44:	d80d2bda af0a1b4c 36034af6 41047a60     .+..L....J.6`z.A
 8003d54:	df60efc3 a867df55 316e8eef 4669be79     ..`.U.g...n1y.iF
 8003d64:	cb61b38c bc66831a 256fd2a0 5268e236     ..a...f...o%6.hR
 8003d74:	cc0c7795 bb0b4703 220216b9 5505262f     .w...G....."/&.U
 8003d84:	c5ba3bbe b2bd0b28 2bb45a92 5cb36a04     .;..(....Z.+.j.\
 8003d94:	c2d7ffa7 b5d0cf31 2cd99e8b 5bdeae1d     ....1......,...[
 8003da4:	9b64c2b0 ec63f226 756aa39c 026d930a     ..d.&.c...ju..m.
 8003db4:	9c0906a9 eb0e363f 72076785 05005713     ....?6...g.r.W..
 8003dc4:	95bf4a82 e2b87a14 7bb12bae 0cb61b38     .J...z...+.{8...
 8003dd4:	92d28e9b e5d5be0d 7cdcefb7 0bdbdf21     ...........|!...
 8003de4:	86d3d2d4 f1d4e242 68ddb3f8 1fda836e     ....B......hn...
 8003df4:	81be16cd f6b9265b 6fb077e1 18b74777     ....[&...w.owG..
 8003e04:	88085ae6 ff0f6a70 66063bca 11010b5c     .Z..pj...;.f\...
 8003e14:	8f659eff f862ae69 616bffd3 166ccf45     ..e.i.b...kaE.l.
 8003e24:	a00ae278 d70dd2ee 4e048354 3903b3c2     x.......T..N...9
 8003e34:	a7672661 d06016f7 4969474d 3e6e77db     a&g...`.MGiI.wn>
 8003e44:	aed16a4a d9d65adc 40df0b66 37d83bf0     Jj...Z..f..@.;.7
 8003e54:	a9bcae53 debb9ec5 47b2cf7f 30b5ffe9     S..........G...0
 8003e64:	bdbdf21c cabac28a 53b39330 24b4a3a6     ........0..S...$
 8003e74:	bad03605 cdd70693 54de5729 23d967bf     .6......)W.T.g.#
 8003e84:	b3667a2e c4614ab8 5d681b02 2a6f2b94     .zf..Ja...h].+o*
 8003e94:	b40bbe37 c30c8ea1 5a05df1b 2d02ef8d     7..........Z...-

08003ea4 <clocks>:
 8003ea4:	00010601 00000004 007a1200              ..........z.

08003eb0 <params>:
 8003eb0:	0007a120 00000001 010d0201 00000100      ...............
 8003ec0:	00000013 00000070 00000014 00000070     ....p.......p...
 8003ed0:	00000015 00000070                       ....p...

08003ed8 <fb0>:
 8003ed8:	00000000 ff800000 00000006              ............

08003ee4 <fb2>:
	...
 8003eec:	00000202                                ....

08003ef0 <led21green>:
 8003ef0:	40010c00 0002000f                       ...@....

08003ef8 <led20red>:
 8003ef8:	40011000 00020005                       ...@....

08003f00 <led19red>:
 8003f00:	40011000 00020004                       ...@....

08003f08 <can1rx0>:
 8003f08:	200015f8 000001b0 00000000              ... ........

08003f14 <can1rx1>:
 8003f14:	200015f8 000001c0 00000004              ... ........

08003f20 <can2rx0>:
 8003f20:	200015fc 000001b0 00000000              ... ........

08003f2c <can2rx1>:
 8003f2c:	200015fc 000001c0 00000004 40010800     ... ...........@
 8003f3c:	0003020c 40010c00 00030209 40011400     .......@.......@
 8003f4c:	00030201 40010800 0000070b 40010c00     .......@.......@
 8003f5c:	00000708 40011400 00000700 fffffffc     .......@........
 8003f6c:	fffffffc 00000200                       ........
